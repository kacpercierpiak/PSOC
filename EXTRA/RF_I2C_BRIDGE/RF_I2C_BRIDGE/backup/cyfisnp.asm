;;*****************************************************************************
;;*****************************************************************************
;;  FILENAME: CYFISNP.asm
;;  Version: 1.0, Updated on 2008/7/1 at 16:20:9
;;  Generated by PSoC Designer 5.1.2306
;;
;;  DESCRIPTION: CYFISPI main functions implemenatation file
;;-----------------------------------------------------------------------------
;;  Copyright (c) Cypress Semiconductor 2011. All Rights Reserved.
;;*****************************************************************************
;;*****************************************************************************

include "m8c.inc"
include "memory.inc"
include "CYFISNP.inc"


area InterruptRAM(ram)

 CYFISNP_DriverRamPage::                    ; used for page address only
_CYFISNP_XactConfig::
 CYFISNP_XactConfig::  BLK     1            ; Current value of XACT_CFG_ADDR.
                                                     ; The value of the Force End State bit in this variable is indeterminate.
_CYFISNP_RestingState::
 CYFISNP_RestingState::  BLK     1          ; Current state of RF core while not attempting a transaction (usually equal to XACT_CFG_ADR, but not always).
                                                     ; An exception to this is in receive mode (due to a workaround for a hardware issue).  If the user wants the end state to be SLEEP,
                                                     ; The RF core actually goes into IDLE, and EndReceive does the work of putting the RF core to sleep.  In this case,
                                                     ; CYFISNP_RestingState will be SLEEP even though the actual state may temporarily be IDLE.
                                                     ; In all cases, the values of the bits in this variable not corresponding to the state field of XACT_CFG_ADR are indeterminate.

_CYFISNP_State::
 CYFISNP_State::       BLK     1            ; The current rx or tx state.

 CYFISNP_TxCount::
 CYFISNP_ConstAddrLo:  BLK     1            ; Parameter to Radio TX / RX routines


;
; These variables are re-used to the point of confusion. They are commonly
;  used for different functions, but occasionally used together as a buffer
;  to burst into the radio registers.  The RadioPacketLength field is used
;  during async rx and tx operations and therefore it is NOT valid to call
;  any functions that use it for any other purpose between a start/end
;  rx/tx pair.
;
CYFISNP_ConstAddrHi:
CYFISNP_Temp1::       BLK     1            ; A work area used for short bursts.

CYFISNP_FileAddr:
CYFISNP_Temp2::       BLK     1            ;  and other temp uses.

_CYFISNP_RetryCount::
 CYFISNP_RetryCount::
 CYFISNP_Temp3::      BLK     1

_CYFISNP_lpGIE::
 CYFISNP_lpGIE::      BLK     1    ; Global Interrupt Enable at RadioInit()

CYFISNP_BytesRead::    BLK  1
CYFISNP_TxCtrlShadow:: BLK  1      ; That last value written to TX_CTRL_ADR.
CYFISNP_Scratch0:      BLK  1


CYFISNP_FIFO_SIZE:   EQU     16      ; Radio Rx/Tx FIFO size
CYFISNP_FIFO_HALF:   EQU     8       ; Radio Rx/Tx FIFO half-way mark (B8 flag)

;--------------------------------------------------------------------------;
;                                                                          ;
;                                 C O D E                                  ;
;                                                                          ;
;--------------------------------------------------------------------------;

        AREA    UserModules (ROM, REL)
        Suspend_CodeCompressor        ; Code breaks if "subroutinized".

;--------------------------------------------------------------------------;
;                                                                          ;
;                      I N I T I A L I Z A T I O N                         ;
;                                                                          ;
;--------------------------------------------------------------------------;


;-----------------------------------------------------------------------------
;  FUNCTION NAME: CYFISNP_Start
;  DESCRIPTION:
;-----------------------------------------------------------------------------
;  ARGUMENTS:    None
;  RETURNS:      Nothing
;  SIDE EFFECTS:
;    The A and X registers may be modified by this or future implementations
;    of this function.  The same is true for all RAM page pointer registers in
;    the Large Memory Model.  When necessary, it is the calling function's
;    responsibility to perserve their values across calls to fastcall16
;    functions.
;-----------------------------------------------------------------------------
IF (CYFISNP_RENAME_STARTSTOP)
.SECTION
 CYFISNP_PhyStart::
_CYFISNP_PhyStart::
ELSE
.SECTION
 CYFISNP_Start::
_CYFISNP_Start::
ENDIF
   RAM_PROLOGUE RAM_USE_CLASS_1
   CYFISNP_ENABLE_IRQ_PIN

 IF (CYFISNP_ARCH_TYPE_PSOC | CYFISNP_ARCH_TYPE_TMA300)
   or    reg[CYFISNP_CONTROL_REG], bfCONTROL_REG_START_BIT | CYFISNP_SPIM_MODE_0 | CYFISNP_SPIM_MSB_FIRST
  IF (CYFISNP_IRQ_MODE_DDB_IRQ)
   or    reg[CYFISNP_CONTROL_REG_IRQ], bfCONTROL_REG_START_BIT
  ENDIF
 ENDIF

 IF (CYFISNP_ARCH_TYPE_C20066)
   IF(CYFISNP_IRQ_Addr - PRT1DR)
      or    reg[CYFISNP_IRQ_Addr], CYFISNP_IRQ_MASK
      or    reg[PRT1DR], 0x20
   ELSE
      or    reg[CYFISNP_IRQ_Addr], CYFISNP_IRQ_MASK | 0x20
   ENDIF
  IF(CYFISNP_IRQ_MOSI_MUXED)
  ELSE
   or    reg[CYFISNP_CONTROL_REG], bfCONTROL_REG_START_BIT | CYFISNP_SPIM_MODE_0 | CYFISNP_SPIM_MSB_FIRST
  ENDIF
 ENDIF

 IF (CYFISNP_ARCH_TYPE_C20066 | CYFISNP_ARCH_TYPE_TMA300)
  IF(CYFISNP_FAST_SS_ACTUATION)
  ELSE
    IF(0x18 * 0x17)
      RAM_SETPAGE_CUR >Port_2_Data_SHADE
      or    [Port_2_Data_SHADE], CYFISNP_OD_MASK
    ENDIF
  ENDIF
 ENDIF

   mov   A, CYFISNP_DEF_ACK_ENABLE | CYFISNP_DEF_ACK_TIMEOUT | CYFISNP_DEF_END_STATE
   mov   X, CYFISNP_DEF_DATA_RATE | CYFISNP_DEF_TX_POWER
   call     CYFISNP_Init
   cmp   A, 0
   jz    .InitError
   mov   A, CYFISNP_DEF_SOP_EN | CYFISNP_DEF_SOP_LEN | CYFISNP_DEF_LEN_EN | CYFISNP_DEF_SOP_TSH
   call  CYFISNP_SetFrameConfig
   mov   A, CYFISNP_DEF_64_THOLD
   call  CYFISNP_SetThreshold64
   mov   A, CYFISNP_DEF_32_THOLD
   call  CYFISNP_SetThreshold32
   mov   A, CYFISNP_DEF_PREAMBLE_CNT
   call  CYFISNP_SetPreambleCount
   mov    A, 1
.InitError:
   RAM_EPILOGUE RAM_USE_CLASS_1
   ret
.ENDSECTION


;-----------------------------------------------------------------------------
;  FUNCTION NAME: CYFISNP_Stop
;  DESCRIPTION:
;-----------------------------------------------------------------------------
;  ARGUMENTS:    None
;  RETURNS:      Nothing
;  SIDE EFFECTS:
;    The A and X registers may be modified by this or future implementations
;    of this function.  The same is true for all RAM page pointer registers in
;    the Large Memory Model.  When necessary, it is the calling function's
;    responsibility to perserve their values across calls to fastcall16
;    functions.
;-----------------------------------------------------------------------------
IF (CYFISNP_RENAME_STARTSTOP)
.SECTION
 CYFISNP_PhyStop::
_CYFISNP_PhyStop::
ELSE
.SECTION
 CYFISNP_Stop::
_CYFISNP_Stop::
ENDIF
   RAM_PROLOGUE RAM_USE_CLASS_1
   call  CYFISNP_Abort
   mov   A,CYFISNP_END_STATE_SLEEP
   call  CYFISNP_ForceState
 IF (CYFISNP_ARCH_TYPE_PSOC | CYFISNP_ARCH_TYPE_TMA300)
   and   reg[CYFISNP_CONTROL_REG], ~bfCONTROL_REG_START_BIT
  IF (CYFISNP_IRQ_MODE_DDB_IRQ)
   and   reg[CYFISNP_CONTROL_REG_IRQ], ~bfCONTROL_REG_START_BIT
  ENDIF
 ENDIF
 IF (CYFISNP_ARCH_TYPE_C20066)
   and   reg[CYFISNP_CONTROL_REG], ~bfCONTROL_REG_START_BIT
 ENDIF
   CYFISNP_DISABLE_IRQ_PIN
   RAM_EPILOGUE RAM_USE_CLASS_1
   ret
.ENDSECTION



;-----------------------------------------------------------------------------
;  FUNCTION NAME: CYFISNP_EnableInt
;  DESCRIPTION:
;-----------------------------------------------------------------------------
;  ARGUMENTS:    None
;  RETURNS:      Nothing
;  SIDE EFFECTS:
;    The A and X registers may be modified by this or future implementations
;    of this function.  The same is true for all RAM page pointer registers in
;    the Large Memory Model.  When necessary, it is the calling function's
;    responsibility to perserve their values across calls to fastcall16
;    functions.
;-----------------------------------------------------------------------------
.SECTION
 CYFISNP_EnableInt::
_CYFISNP_EnableInt::
  IF (CYFISNP_RADIO_INTERRUPT)
   RAM_PROLOGUE RAM_USE_CLASS_1
   or    reg[CYFISNP_INT_REG], CYFISNP_INT_MASK
   RAM_EPILOGUE RAM_USE_CLASS_1
  ENDIF
   ret
.ENDSECTION


;-----------------------------------------------------------------------------
;  FUNCTION NAME: CYFISNP_DisableInt
;  DESCRIPTION:
;-----------------------------------------------------------------------------
;  ARGUMENTS:    None
;  RETURNS:      Nothing
;  SIDE EFFECTS:
;    The A and X registers may be modified by this or future implementations
;    of this function.  The same is true for all RAM page pointer registers in
;    the Large Memory Model.  When necessary, it is the calling function's
;    responsibility to perserve their values across calls to fastcall16
;    functions.
;-----------------------------------------------------------------------------
.SECTION
 CYFISNP_DisableInt::
_CYFISNP_DisableInt::
  IF (CYFISNP_RADIO_INTERRUPT)
   RAM_PROLOGUE RAM_USE_CLASS_1
   and   reg[CYFISNP_INT_REG], ~CYFISNP_INT_MASK
   RAM_EPILOGUE RAM_USE_CLASS_1
  ENDIF
   ret
.ENDSECTION


.section
;--------------------------------------------------------------------------
;
; RadioInit:       Initialize the Radio.
;
; 'C' Call:        void RadioInit(XACT_CONFIG xactConfig, TX_CONFIG txConfig);
;
; Assembly Call:   A: xactConfig
;                  X: txConfig
;
; Assembly Return: A: Garbage
;                  X: Garbage
;
_CYFISNP_Init::
 CYFISNP_Init::
        RAM_SETPAGE_CUR >CYFISNP_DriverRamPage

        MOV     [CYFISNP_Temp1], A
        MOV     [CYFISNP_Temp2], X

        MOV     [CYFISNP_XactConfig], CYFISNP_XACT_CFG_RST
        MOV     [CYFISNP_RestingState], CYFISNP_XACT_CFG_RST

        CALL    CYFISNP_Reset
        cmp     A, 0
        jz      .InitError

;
; We're going to want to force the RXF clock on in the streaming driver.
; Not necessary for nonstreaming driver but harmless.
;
        MOV     A, CYFISNP_CLK_EN_ADR
        MOV     X, CYFISNP_RXF
        CALL    CYFISNP_Write

;
; Set up to use auto-cal for VCO. Register 0x34 is left at its default value
; to allow auto-cal to be used.
;
        MOV     A, CYFISNP_AUTO_CAL_TIME_ADR    ; Extend autoCal time to max.
        MOV     X, CYFISNP_AUTO_CAL_TIME_MAX
        CALL    CYFISNP_Write

        MOV     A, CYFISNP_AUTO_CAL_OFFSET_ADR  ; AutoCal offset to -4.
        MOV     X, CYFISNP_AUTO_CAL_OFFSET_MINUS_4
        CALL    CYFISNP_Write

        MOV     A, CYFISNP_IO_CFG_ADR           ; Read IO_CFG_ADR, user may have
        CALL    CYFISNP_Read                    ;  changed it in RadioReset
        OR      A, CYFISNP_IRQ_POL              ; Set IRQ polarity to positive.
        MOV     X, CYFISNP_IO_CFG_ADR           ;  (Some have asked that this be
        CALL    CYFISNP_WriteSwapped            ;  left at the default negative.)

;
; Set the XTAL Startup delay to 150uSec to handle warm restarts of the XTAL.
;
        MOV     A, CYFISNP_XTAL_CFG_ADR
        MOV     X, 0x08
        CALL    CYFISNP_Write
;
; Enable HiLo for quick-turn-around. Use low side injection for receive - this
;  should result in non-inverted data, so no need to hit the invert bit.
; Turn off AGC and force the LNA on.
;
        MOV     A, CYFISNP_RX_CFG_ADR
        MOV     X, ((CYFISNP_RX_CFG_RST | CYFISNP_FASTTURN_EN | CYFISNP_LNA_EN) & ~(CYFISNP_HI | CYFISNP_RXOW_EN | CYFISNP_AUTO_AGC_EN))
        CALL    CYFISNP_Write
;
; Set the TX Offset to +1MHz.
;
; THIS MEANS THE ACTUAL TRANSMIT CARRIER WILL BE 1MHz ABOVE THE PLL
;  FREQUENCY PROGRAMMED IN THE CHANNEL OR A & N REGISTERS.
;  RadioSetFrequency COMPENSATES FOR THIS OFFSET.
;
        MOV     A, CYFISNP_TX_OFFSET_LSB_ADR
        MOV     X, 055h
        CALL    CYFISNP_Write
        MOV     A, CYFISNP_TX_OFFSET_MSB_ADR
        MOV     X, 005h
        CALL    CYFISNP_Write

; Set ALL_SLOW bit when operating in GFSK mode

IF (CYFISNP_DEF_DATA_RATE)
ELSE
        MOV     A, CYFISNP_ANALOG_CTRL_ADR
        MOV     X, CYFISNP_ALLSLOW
        CALL    CYFISNP_Write
ENDIF
;
; Set the radio transaction and TX configuration.
;
        MOV     A, [CYFISNP_Temp1]
        CALL    CYFISNP_SetXactConfig
        MOV     A, [CYFISNP_Temp2]
        CALL    CYFISNP_SetTxConfig

        MOV     [CYFISNP_State], CYFISNP_IDLE
        mov     A, 1
        ret
.InitError:
        ret
.endsection

;--------------------------------------------------------------------------;
;                                                                          ;
;                        C O N F I G U R A T I O N                         ;
;                                                                          ;
;--------------------------------------------------------------------------;
.section
;-----------------------------------------------------------------------------
;
; RadioSetChannel:
;                  Set the channel (frequency + 2MHz).
;
; 'C' Call:        void RadioSetChannel(BYTE channel);
;
; Assembly Call:   A: frequency
;                  X: Unused
;
; Assembly Return: A: Undefined
;                  X: Undefined
;
; Note:            FALL THROUGH INTO RadioSetFrequency.
;
 CYFISNP_SetChannel::
_CYFISNP_SetChannel::
        ADD     A, 2
        ; fallthru to RadioSetFrequency()

.endsection
.section
;-----------------------------------------------------------------------------
;
; RadioSetFrequency:
;                  Set the frequency on which future communications will occur.
;
;                  THIS DRIVER SETS TX OFFESET AT 1 WHICH MEANS THAT THE TX
;                  CARRIER WILL BE 1MHz HIGHER THAN CHANNEL NUMBER WE PROGRAM.
;                  THIS FUNCTION COMPENSATES FOR THAT OFFSET BY DECREMENTING
;                  THE CHANNEL NUMBER.
;
; 'C' Call:        void RadioSetFrequency(BYTE frequency);
;
; Assembly Call:   A: frequency
;                  X: Unused
;
; Assembly Return: A: Undefined
;                  X: Undefined
;
 CYFISNP_SetFrequency::
_CYFISNP_SetFrequency::
        CMP     A, 0
        JZ      .Chan0
        DEC     A
.Chan0: MOV     X, CYFISNP_CHANNEL_ADR          ; Write into the channel register.
        JMP     CYFISNP_WriteSwapped

.endsection
.section
;-----------------------------------------------------------------------------
;
; RadioGetChannel:
;                  Get the channel.
;
; 'C' Call:        BYTE RadioGetChannel(void);
;
; Assembly Call:   A: Unused
;                  X: Unused
;
; Assembly Return: A: channel
;                  X: Undefined
;
 CYFISNP_GetChannel::
_CYFISNP_GetChannel::
        CALL    CYFISNP_GetFrequency
        SUB     A, 2
        RET

.endsection
.section
;-----------------------------------------------------------------------------
;
; RadioGetFrequency:
;                  Returns the frequency in MHz above 2.4GHz.
;                  Example: 0 means 2.400GHz, 83 means 2.483GHz.
;
; 'C' Call:        BYTE RadioGetFrequency(void);
;
; Assembly Call:   A: Unused
;                  X: Unused
;
; Assembly Return: A: frequency
;                  X: Undefined
;
 CYFISNP_GetFrequency::
_CYFISNP_GetFrequency::
        MOV     A, CYFISNP_CHANNEL_ADR          ;  into the channel register.
        CALL    CYFISNP_Read
        INC     A
        RET

.endsection
.section
;-----------------------------------------------------------------------------
;
; RadioSetTxConfig:Set the transmitter configuration.
;
; 'C' Call:        void RadioSetTxConfig(TX_CONFIG config);
;
; Assembly Call:   A: config
;                  X: Unused
;
; Assembly Return: A: Undefined
;                  X: Undefined
;
_CYFISNP_SetTxConfig::
 CYFISNP_SetTxConfig::
        MOV     X, CYFISNP_TX_CFG_ADR
        JMP     CYFISNP_WriteSwapped

.endsection

.section
;-----------------------------------------------------------------------------
;
; RadioGetTxConfig:Return the transmitter configuration.
;
; 'C' Call:        TX_CONFIG RadioGetTxConfig(void);
;
; Assembly Call:   A: Unused
;                  X: Unused
;
; Assembly Return: A: config
;                  X: Undefined
;
_CYFISNP_GetTxConfig::
 CYFISNP_GetTxConfig::
        MOV     A, CYFISNP_TX_CFG_ADR
        JMP     CYFISNP_Read

.endsection

.section
;-----------------------------------------------------------------------------
;
; RadioSetXactConfig:
;                  Set the transaction configuration.
;
; 'C' Call:        void RadioSetXactConfig(XACT_CONFIG config);
;
; Assembly Call:   A: config (user shouldn't set FRC_END_STATE bit)
;                  X: Unused
;
; Assembly Return: A: Undefined
;                  X: Undefined
;
; Side Effects:
; 1. Modifies the CYFISNP_XactConfig variable.
;
; Notes:
; 1. This routine clears the Force End State bit prior to sending to the radio
;    and prior to saving the configuration to CYFISNP_XactConfig.
;-----------------------------------------------------------------------------
_CYFISNP_SetXactConfig::
 CYFISNP_SetXactConfig::
        RAM_SETPAGE_CUR >CYFISNP_DriverRamPage
        AND     A, ~CYFISNP_FRC_END_STATE  ; Disallow forcing the RF state
        MOV     [CYFISNP_XactConfig], A    ; use RadioSetState() goto a State.
        MOV     X, CYFISNP_XACT_CFG_ADR
        JMP     CYFISNP_WriteSwapped


.endsection
.section
;-----------------------------------------------------------------------------
;
; RadioGetXactConfig:
;                  Return the transaction configuration.
;
; 'C' Call:        XACT_CONFIG RadioGetXactConfig(void);
;
; Assembly Call:   A: Unused
;                  X: Unused
;
; Assembly Return: A: config
;                  X: Undefined
;
_CYFISNP_GetXactConfig::
 CYFISNP_GetXactConfig::
        MOV     A, CYFISNP_XACT_CFG_ADR
        JMP     CYFISNP_Read

.endsection
.section
;-----------------------------------------------------------------------------
;
; RadioSetFrameConfig:
;                  Set the framing configuration.
;
; 'C' Call:        void RadioSetFrameConfig(RADIO_FRAME_CONFIG config);
;
; Assembly Call:   A: config
;                  X: Unused
;
; Assembly Return: A: Undefined
;                  X: Undefined
;
_CYFISNP_SetFrameConfig::
 CYFISNP_SetFrameConfig::
        MOV     X, CYFISNP_FRAMING_CFG_ADR
        JMP     CYFISNP_WriteSwapped

.endsection

.section
;-----------------------------------------------------------------------------
;
; RadioGetFrameConfig:
;                  Set the framing configuration.
;
; 'C' Call:        RADIO_FRAME_CONFIG RadioGetFrameConfig(void);
;
; Assembly Call:   A: Unused
;                  X: Unused
;
; Assembly Return: A: config
;                  X: Undefined
;
_CYFISNP_GetFrameConfig::
 CYFISNP_GetFrameConfig::
        MOV     A, CYFISNP_FRAMING_CFG_ADR
        JMP     CYFISNP_Read

.endsection

.section
;-----------------------------------------------------------------------------
;
; RadioSetThreshold32:
;                  Set the threshold for the 32 chip data modes.
;
; 'C' Call:        void RadioSetThreshold32(BYTE threshold);
;
; Assembly Call:   A: threshold
;                  X: Unused
;
; Assembly Return: A: Undefined
;                  X: Undefined
;
_CYFISNP_SetThreshold32::
 CYFISNP_SetThreshold32::
        MOV     X, CYFISNP_DATA32_THOLD_ADR
        JMP     CYFISNP_WriteSwapped

.endsection

.section
;-----------------------------------------------------------------------------
;
; RadioGetThreshold32:
;                  Return the threshold for the 32 chip data modes.
;
; 'C' Call:        BYTE RadioGetThreshold32(void);
;
; Assembly Call:   A: unused
;                  X: unused
;
; Assembly Return: A: threshold
;                  X: Undefined
;
_CYFISNP_GetThreshold32::
 CYFISNP_GetThreshold32::
        MOV     A, CYFISNP_DATA32_THOLD_ADR
        JMP     CYFISNP_Read

.endsection

.section
;-----------------------------------------------------------------------------
;
; RadioSetThreshold64:
;                  Set the threshold for the 64 chip data modes.
;
; 'C' Call:        void RadioSetThreshold64(BYTE threshold);
;
; Assembly Call:   A: threshold
;                  X: Unused
;
; Assembly Return: A: Undefined
;                  X: Undefined
;
_CYFISNP_SetThreshold64::
 CYFISNP_SetThreshold64::
        MOV     X, CYFISNP_DATA64_THOLD_ADR
        JMP     CYFISNP_WriteSwapped

.endsection

.section
;-----------------------------------------------------------------------------
;
; RadioGetThreshold64:
;                  Return the threshold for the 64 chip data modes.
;
; 'C' Call:        BYTE RadioGetThreshold64(void);
;
; Assembly Call:   A: unused
;                  X: unused
;
; Assembly Return: A: threshold
;                  X: Undefined
;
_CYFISNP_GetThreshold64::
 CYFISNP_GetThreshold64::
        MOV     A, CYFISNP_DATA64_THOLD_ADR
        JMP     CYFISNP_Read

.endsection

.section
;-----------------------------------------------------------------------------
;
; RadioSetPreambleCount:
;                  Set the preamble repetition count.
;
; 'C' Call:        void RadioSetPreambleCount(BYTE count);
;
; Assembly Call:   A: preamble count
;                  X: Unused
;
; Assembly Return: A: Undefined
;                  X: Undefined
;
_CYFISNP_SetPreambleCount::
 CYFISNP_SetPreambleCount::
        MOV     X, CYFISNP_PREAMBLE_ADR         ; Write the preamble count...
        CALL    CYFISNP_WriteSwapped

        RAM_SETPAGE_CUR >CYFISNP_DriverRamPage
  IF (SYSTEM_LARGE_MEMORY_MODEL)
        MOV     [CYFISNP_WipPtr+1], >CYFISNP_Temp1 ; LMM: MSByte RadioWipPtr
  ENDIF
        MOV     [CYFISNP_WipPtr+0], <CYFISNP_Temp1 ; LSByte RadioWipPtr
                                                         ; Preamble file register is 3 bytes
        MOV     A, CYFISNP_PREAMBLE_ADR         ;  and must always be accessed 3 times
        MOV     X, 2                                     ;  so do a throw away burst read of 2
        JMP     CYFISNP_FileReadWip        ;  to move it a total of 3 bytes.

.endsection

.section
;-----------------------------------------------------------------------------
;
; RadioGetPreambleCount:
;                  Get the preamble repetition count.
;
; 'C' Call:        BYTE RadioGetPreambleCount(void);
;
; Assembly Call:   A: unused
;                  X: unused
;
; Assembly Return: A: preamble count
;                  X: Undefined
;
_CYFISNP_GetPreambleCount::
 CYFISNP_GetPreambleCount::
        RAM_SETPAGE_CUR >CYFISNP_DriverRamPage
  IF (SYSTEM_LARGE_MEMORY_MODEL)
        MOV     [CYFISNP_WipPtr+1], >CYFISNP_Temp1 ; LMM: MSB RadioWipPtr
  ENDIF
        MOV     [CYFISNP_WipPtr+0], <CYFISNP_Temp1 ; SMM: 8-bit RadioWipPtr
                                                         ; The preamble file register is 3 byte
        MOV     A, CYFISNP_PREAMBLE_ADR         ;  and must always be accessed 3 times
        MOV     X, 3                                     ;  so do a burst read of the whole 3
        MOV     [CYFISNP_WipLen], 3
        CALL    CYFISNP_FileReadWip        ;  byte file register.
        MOV     A, [CYFISNP_Temp1]         ; The first byte is the count.
        RET

.endsection

.section
;-----------------------------------------------------------------------------
;
; RadioSetPreamblePattern:
;                  Set the preamble pattern.
;
; 'C' Call:        void RadioSetPreamblePattern(WORD pattern);
;
; Assembly Call:   A: pattern low order
;                  X: pattern high order
;
; Assembly Return: A: Undefined
;                  X: Undefined
;
_CYFISNP_SetPreamblePattern::
 CYFISNP_SetPreamblePattern::
        RAM_SETPAGE_CUR >CYFISNP_DriverRamPage
        MOV     [CYFISNP_Temp1], A         ; Save the pattern.
        MOV     [CYFISNP_Temp2], X
        MOV     A, CYFISNP_PREAMBLE_ADR         ; Gotta access the whole 3 byte file -
        CALL    CYFISNP_Read               ;  do throw away read of preamblecount

  IF (SYSTEM_LARGE_MEMORY_MODEL)
        MOV     [CYFISNP_WipPtr+1], >CYFISNP_Temp1 ; LMM: MSB RadioWipPtr
  ENDIF
        MOV     [CYFISNP_WipPtr+0], <CYFISNP_Temp1 ; SMM: 8-bit RadioWipPtr
        MOV     A, CYFISNP_PREAMBLE_ADR         ; Write the pattern as a 2 byte
        MOV     X, 2                                     ;  file register burst.
        JMP     CYFISNP_FileWriteWip

.endsection

.section
;-----------------------------------------------------------------------------
;
; RadioGetPreamblePattern:
;                  Get the preamble pattern.
;
; 'C' Call:        WORD RadioGetPreamblePattern(void);
;
; Assembly Call:   A: unused
;                  X: unused
;
; Assembly Return: A: preamble count
;                  X: Undefined
;
_CYFISNP_GetPreamblePattern::
 CYFISNP_GetPreamblePattern::
        RAM_SETPAGE_CUR >CYFISNP_DriverRamPage
  IF (SYSTEM_LARGE_MEMORY_MODEL)
        MOV     [CYFISNP_WipPtr+1], >CYFISNP_Temp1 ; LMM: MSB RadioWipPtr
  ENDIF
        MOV     [CYFISNP_WipPtr+0], <CYFISNP_Temp1 ; SMM: 8-bit RadioWipPtr
                                                         ; Preamble file register is 3 bytes
        MOV     A, CYFISNP_PREAMBLE_ADR         ;  and must always be accessed 3 times
        MOV     X, 3                                     ;  so do a burst read of the whole 3
        MOV     [CYFISNP_WipLen], 3
        CALL    CYFISNP_FileReadWip        ;  byte file register.
        MOV     A, [CYFISNP_Temp2]         ; The first byte is the count and the
        MOV     X, [CYFISNP_Temp3]         ;  pattern is the 2nd and 3rd bytes.
        RET

.endsection

.section
;-----------------------------------------------------------------------------
;
; RadioSetCrcSeed: Sets CRC seed value used for both Tx and Rx
;
; 'C' Call:        void RadioSetCrcSeed(WORD crcSeed);
;
; Assembly Call:   A: crcSeed low order
;                  X: crcSeed high order
;
; Assembly Return: A: Undefined
;                  X: Undefined
;
 CYFISNP_SetCrcSeed::
_CYFISNP_SetCrcSeed::
        RAM_SETPAGE_CUR >CYFISNP_DriverRamPage
        MOV     [CYFISNP_Temp1], A         ; Save pattern in local work buffer
        MOV     [CYFISNP_Temp2], X
  IF (SYSTEM_LARGE_MEMORY_MODEL)
        MOV     [CYFISNP_WipPtr+1], >CYFISNP_Temp1 ; LMM: MSB RadioWipPtr
  ENDIF
        MOV     [CYFISNP_WipPtr+0], <CYFISNP_Temp1 ; SMM: 8-bit RadioWipPtr
        MOV     A, CYFISNP_CRC_SEED_LSB_ADR     ;  Write the pattern as a 2 byte file
        MOV     X, 2                                     ;  register burst.
        JMP     CYFISNP_BurstWriteWip

.endsection

.section
;-----------------------------------------------------------------------------
;
; RadioGetCrcSeed: Return CRC seed value used for both Tx and Rx
;
; 'C' Call:        WORD RadioGetCrcSeed(void);
;
; Assembly Call:   A: unused
;                  X: unused
;
; Assembly Return: A: crcSeed low order
;                  X: crcSeed high order
;
 CYFISNP_GetCrcSeed::
_CYFISNP_GetCrcSeed::
        RAM_SETPAGE_CUR >CYFISNP_DriverRamPage
  IF (SYSTEM_LARGE_MEMORY_MODEL)
        MOV     [CYFISNP_WipPtr+1], >CYFISNP_Temp1 ; LMM: MSB RadioWipPtr
  ENDIF
        MOV     [CYFISNP_WipPtr+0], <CYFISNP_Temp1 ; SMM: 8-bit RadioWipPtr
        MOV     A, CYFISNP_CRC_SEED_LSB_ADR
        MOV     X, 2                    ;  2-Byte burst read
        MOV     [CYFISNP_WipLen], 2    ; 2-Byte burst read

        CALL    CYFISNP_BurstReadWip       ;  byte file register.
        MOV     A, [CYFISNP_Temp1]         ; The first byte is the count and the
        MOV     X, [CYFISNP_Temp2]         ;  pattern is the 2nd and 3rd bytes.
        RET

.endsection

.section
;-----------------------------------------------------------------------------
;
; RadioGetFuses:   Get the fuse values from the radio.
;
;               Caller should have ALREADY called _SetLength() and _SetPtr().
;
; 'C' Call:        void RadioGetFuses(void);
;
; Assembly Call:   A: unused
;                  X: unused
;
; Assembly Return: A: Undefined
;                  X: Undefined
;
 CYFISNP_GetFuses::
_CYFISNP_GetFuses::
        MOV     A, CYFISNP_MFG_ID_ADR  ; Turn on fuse read bias.
        MOV     X, 0FFh
        CALL    CYFISNP_Write

        RAM_SETPAGE_CUR >CYFISNP_DriverRamPage
        MOV     X, 6
        MOV     A, CYFISNP_MFG_ID_ADR
        CALL    CYFISNP_FileRead       ; Read the fuses.

; RAM_SETPAGE_CUR >_DriverRamPage  already done by RadioWrite()
  IF (SYSTEM_LARGE_MEMORY_MODEL)
        MOV     A, [CYFISNP_Ptr+1]     ; MSB RadioPtr (page number)
        RAM_SETPAGE_IDX A                       ; IDX_PP = MSB
        RAM_X_POINTS_TO_INDEXPAGE               ; IDX instructions use IDX_PP reg
  ENDIF
        MOV     X, [CYFISNP_Ptr+0]     ; LSB of pointer
        MOV     A, [CYFISNP_Len]
.Loop:  XOR     [X+0], 0xFF
        INC     X
        DEC     A
        JNZ     .Loop

        RAM_RESTORE_NATIVE_PAGING

        MOV     A, CYFISNP_MFG_ID_ADR  ; Turn off fuse read bias.
        MOV     X, 0
        JMP     CYFISNP_Write
.endsection

.section
;-----------------------------------------------------------------------------
;
; RadioSetConstSopPnCode:  Set SOP PN Code.
;
; 'C' Call:        void RadioSetConstSopPnCode(const BYTE *patternAddr);
;
; Assembly Call:   A: Code address high
;                  X: Code address low
;
; Assembly Return: A: Undefined
;                  X: Undefined
;
_CYFISNP_SetConstSopPnCode::
 CYFISNP_SetConstSopPnCode::
        RAM_SETPAGE_CUR >CYFISNP_DriverRamPage
        MOV     [CYFISNP_FileAddr], CYFISNP_SOP_CODE_ADR
CYFISNP_SetConstCode2:
        MOV     [CYFISNP_ConstAddrHi], A
        MOV     [CYFISNP_ConstAddrLo], X
CYFISNP_SetConstCode:
        MOV     [CYFISNP_Temp3], 8
.loop:  MOV     A, [CYFISNP_ConstAddrHi]
        MOV     X, [CYFISNP_ConstAddrLo]
        ROMX
        INC     [CYFISNP_ConstAddrLo]
        JNZ     .S1
        INC     [CYFISNP_ConstAddrHi]
.S1:    MOV     X, [CYFISNP_FileAddr]
        CALL    CYFISNP_WriteSwapped
        DEC     [CYFISNP_Temp3]
        JNZ     .loop
        RET

.endsection

.section
;-----------------------------------------------------------------------------
;
; RadioSetConstDataPnCode: Set DATA PN Code.
;
; 'C' Call:        void RadioSetConstDataPnCode(const BYTE *patternAddr);
;
; Assembly Call:   A: Code address high
;                  X: Code address low
;
; Assembly Return: A: Undefined
;                  X: Undefined
;
_CYFISNP_SetConstDataPnCode::
 CYFISNP_SetConstDataPnCode::
        RAM_SETPAGE_CUR >CYFISNP_DriverRamPage
        MOV     [CYFISNP_FileAddr], CYFISNP_DATA_CODE_ADR
        CALL    CYFISNP_SetConstCode2
        JMP     CYFISNP_SetConstCode

.endsection

.section
;-----------------------------------------------------------------------------
;
; RadioSetSopPnCode: Set the Start Of Packet PN Code.
;
; 'C' Call:        void RadioSetSopPnCode(BYTE patternNum);
;
; Assembly Call:   A: Code number
;                  X: unused
;
; Assembly Return: A: Undefined
;                  X: Undefined
;
_CYFISNP_SetSopPnCode::
 CYFISNP_SetSopPnCode::
        ASL     A                           ; PN Codes are 8 bytes.
        ASL     A
        ASL     A
        MOV     X, >CYFISNP_PnCodeTable
        ADD     A, <CYFISNP_PnCodeTable
        JNC     .S1
        INC     X
.S1:    SWAP    A, X
        JMP     _CYFISNP_SetConstSopPnCode

;--------------------------------------------------------------------------;
;                                                                          ;
;                        P N   C o d e   T a b l e s                       ;
;                                                                          ;
;--------------------------------------------------------------------------;

;-----------------------------------------------------------------------------
;
; These are the 20 Multiplicative codes documented in RWW-87. The first 10 are
;  the set recommended as the best at the conclusion of that memo.
;
; Bit ordering for these codes:
;  The LSB of the first byte is the first bit transceived.
;  The MSB of the first byte is the eighth bit transceived.
;  The MSB of the eighth byte is the last bit transceived.
;

CYFISNP_PnCodeTable:
IF (CYFISNP_SOP_SET_A)
                             DB   3Ch, 37h, CCh, 91h, E2h, F8h, CCh, 91h ; PN Code 0
                             DB   9Bh, C5h, A1h, 0Fh, ADh, 39h, A2h, 0Fh ; PN Code 1
                             DB   EFh, 64h, B0h, 2Ah, D2h, 8Fh, B1h, 2Ah ; PN Code 2
                             DB   66h, CDh, 7Ch, 50h, DDh, 26h, 7Ch, 50h ; PN Code 3
                             DB   5Ch, E1h, F6h, 44h, ADh, 16h, F6h, 44h ; PN Code 4
                             DB   5Ah, CCh, AEh, 46h, B6h, 31h, AEh, 46h ; PN Code 5
                             DB   A1h, 78h, DCh, 3Ch, 9Eh, 82h, DCh, 3Ch ; PN Code 6
                             DB   B9h, 8Eh, 19h, 74h, 6Fh, 65h, 18h, 74h ; PN Code 7
                             DB   DFh, B1h, C0h, 49h, 62h, DFh, C1h, 49h ; PN Code 8
                             DB   97h, E5h, 14h, 72h, 7Fh, 1Ah, 14h, 72h ; PN Code 9
ENDIF
IF (CYFISNP_SOP_SET_B)
                             DB   82h, C7h, 90h, 36h, 21h, 03h, FFh, 17h ; PN Code 10
                             DB   E2h, F8h, CCh, 91h, 3Ch, 37h, CCh, 91h ; PN Code 11
                             DB   ADh, 39h, A2h, 0Fh, 9Bh, C5h, A1h, 0Fh ; PN Code 12
                             DB   D2h, 8Fh, B1h, 2Ah, EFh, 64h, B0h, 2Ah ; PN Code 13
                             DB   DDh, 26h, 7Ch, 50h, 66h, CDh, 7Ch, 50h ; PN Code 14
                             DB   ADh, 16h, F6h, 44h, 5Ch, E1h, F6h, 44h ; PN Code 15
                             DB   B6h, 31h, AEh, 46h, 5Ah, CCh, AEh, 46h ; PN Code 16
                             DB   9Eh, 82h, DCh, 3Ch, A1h, 78h, DCh, 3Ch ; PN Code 17
                             DB   6Fh, 65h, 18h, 74h, B9h, 8Eh, 19h, 74h ; PN Code 18
                             DB   62h, DFh, C1h, 49h, DFh, B1h, C0h, 49h ; PN Code 19
ENDIF
.endsection


.section

;-------------------------------------------------------------------------------
; CYFISNP_WriteSwapped
;
; Writes a single byte to a register.  Parameter order is swapped compared to
; CYFISNP_Write.
;
; M8C Registers
;    A: Value to write.  Trashed on exit.
;    X: Address of register to write.  Trashed on exit.
;
; Assumptions
;    1. All assumptions of called/jumped subroutines apply.
;-------------------------------------------------------------------------------
 CYFISNP_WriteSwapped::
        SWAP    A, X
        ; Fall through to CYFISNP_Write

;-------------------------------------------------------------------------------
; CYFISNP_Write
;
; Writes a single byte to a register.
;
; M8C Registers
;    A: Address of register to write.  Trashed on exit.
;    X: Value to write.  Trashed on exit.
;
; Assumptions
;    1. All assumptions of called/jumped subroutines apply.
;-------------------------------------------------------------------------------
 CYFISNP_Write::
_CYFISNP_Write::
  IF (CYFISNP_SPI_MODE_SDIO)
        CALL    CYFISNP_SaveAndClearGIE
        CALL    CYFISNP_WriteRaw
        JMP     CYFISNP_RestoreGIE
  ELSE
        OR      A, CYFISNP_bSPI_WRITE           ; Set the Write Bit.
        ; Fall through to CYFISNP_Read
  ENDIF


;-------------------------------------------------------------------------------
; CYFISNP_Read
;
; Reads a single byte from a register.
;
; M8C Registers
;    A: Address of register to read.  On exit, the read value is returned in
;       this register.
;    X: Trashed on exit.
;
; Assumptions
;    1. All assumptions of called/jumped subroutines apply.
;-------------------------------------------------------------------------------
 CYFISNP_Read::
_CYFISNP_Read::
        CALL    CYFISNP_SaveAndClearGIE
        CALL    CYFISNP_ReadRaw
        JMP     CYFISNP_RestoreGIE


;-------------------------------------------------------------------------------
; CYFISNP_ReadStatusDebounced
;
; Reads status flags from an appropriate register and performs a second read
; with some sticky bits if a couple bits are not equal to each other.
;
; M8C Registers
;    A: Address of the register to read.  On exit, the debounced read value is
;       returned in this register.
;    X: Trashed on exit.
;
; Assumptions
;    1. All assumptions of called/jumped subroutines apply.
;-------------------------------------------------------------------------------
 CYFISNP_ReadStatusDebounced::
_CYFISNP_ReadStatusDebounced::
        CALL   CYFISNP_SaveAndClearGIE
        CALL   CYFISNP_ReadStatusDebouncedRaw
        JMP    CYFISNP_RestoreGIE


;-------------------------------------------------------------------------------
; CYFISNP_BurstWrite
; CYFISNP_BurstWriteWip
; CYFISNP_FileWrite
; CYFISNP_FileWriteWip
;
; These routines handle burst writes of multiple consecutive registers or writes
; of multiple bytes to a register file.
;
; M8C Registers
;    A: Address of register to write.  Trashed on exit.
;    X: Number of bytes to write.  Trashed on exit.
;
; Assumptions
;    1. All assumptions of called/jumped subroutines apply.
;-------------------------------------------------------------------------------
 CYFISNP_BurstWriteWip::
        OR      A, CYFISNP_bSPI_AUTO_INC        ; Set increment flag
        JMP     CYFISNP_FileWriteWip            ; Use existing WIP ptr/ctr

 CYFISNP_BurstWrite::
_CYFISNP_BurstWrite::
        OR      A, CYFISNP_bSPI_AUTO_INC        ; Set increment flag.

 CYFISNP_FileWrite::
_CYFISNP_FileWrite::
        RAM_SETPAGE_CUR >CYFISNP_DriverRamPage
  IF (SYSTEM_LARGE_MEMORY_MODEL)
        MOV     [CYFISNP_WipPtr+1], [CYFISNP_Ptr+1] ; Copy MSByte buffer pointer.
  ENDIF
        MOV     [CYFISNP_WipPtr+0], [CYFISNP_Ptr+0] ; Copy LSByte buffer pointer.

 CYFISNP_FileWriteWip::
        CALL   CYFISNP_SaveAndClearGIE
        CALL   CYFISNP_FileWriteWipRaw
        JMP    CYFISNP_RestoreGIE



;-------------------------------------------------------------------------------
; CYFISNP_BurstRead
; CYFISNP_BurstReadWip
; CYFISNP_FileRead
; CYFISNP_FileReadWip
;
; These routines handle burst reads of multiple consecutive registers or reads
; of multiple bytes from a register file.
;
; M8C Registers
;    A: Address of register to read.  Trashed on exit.
;    X: Number of bytes to read.  Trashed on exit.
;
; Assumptions
;    1. All assumptions of called/jumped subroutines apply.
;-------------------------------------------------------------------------------
 CYFISNP_BurstReadWip::
        OR      A, CYFISNP_bSPI_AUTO_INC        ; Set the increment flag.
        JMP     CYFISNP_FileReadWip


 CYFISNP_BurstRead::
_CYFISNP_BurstRead::
        OR      A,CYFISNP_bSPI_AUTO_INC         ; Set the increment flag.


 CYFISNP_FileRead::
_CYFISNP_FileRead::
        RAM_SETPAGE_CUR >CYFISNP_DriverRamPage
  IF (SYSTEM_LARGE_MEMORY_MODEL)
        MOV     [CYFISNP_WipPtr+1], [CYFISNP_Ptr+1] ; LMM: MSB working pointer
  ENDIF
        MOV     [CYFISNP_WipPtr+0], [CYFISNP_Ptr+0] ; Initialize working pointer

        MOV     [CYFISNP_WipLen], [CYFISNP_Len]     ;  and length.


CYFISNP_FileReadWip::
        CALL    CYFISNP_SaveAndClearGIE
        CALL    CYFISNP_FileReadWipRaw
        ; Fall through to CYFISNP_RestoreGIE


;-------------------------------------------------------------------------------
; CYFISNP_RestoreGIE
;
; Restores the global interrupt enable flag (GIE) to the state it had prior to
; the most recent call to CYFISNP_SaveAndClearGIE.
; It's primary purpose is as the GIE restoration mechanism for interrupt-safe
; SPI operation.
;
; M8C Registers
;    A: Unused and unaffected
;    X: Unused and unaffected
;
; Assumptions
;    1. On entry, the current page pointer (CUR_PP) points at the RAM page
;       containing CYFISNP_lpGIE.
;    2. On entry, the global interrupt enable (GIE) flag is cleared.
;-------------------------------------------------------------------------------
 CYFISNP_RestoreGIE::
        TST    [CYFISNP_lpGIE], FLAG_GLOBAL_IE
        JZ     .Done
        M8C_EnableGInt
.Done:
        RET



;-------------------------------------------------------------------------------
; CYFISNP_SaveAndClearGIE
;
; Saves a copy of the M8C F register and clears the M8C global interrupt enable
; (GIE) flag.  The saved copy of F will be used in a later call to
; CYFISNP_RestoreGIE in order to restore the GIE flag to its previous
; state.  This function's primary purpose is as the GIE saving/disabling
; mechanim for interrupt-safe SPI operation.
;
; M8C Registers
;    A: Unused and unaffected
;    X: Unused and unaffected
;
; Assumptions
;    None
;-------------------------------------------------------------------------------
 CYFISNP_SaveAndClearGIE::
        RAM_SETPAGE_CUR >CYFISNP_DriverRamPage
        PUSH   A
        MOV    A, reg[CPU_F]
        M8C_DisableGInt
        MOV    [CYFISNP_lpGIE], A
        POP    A
        RET
.endsection


.section
;-----------------------------------------------------------------------------
;
; RadioSetPtr:     Set the buffer pointer address for RadioBurstRead,
;                  RadioFileRead, RadioBurstWrite and RadioFileWrite functions
;
; 'C' Call:        void RadioSetPtr(unsigned char ramPtr);
;
; Return:     CUR_PP: Large Memory Model sets to RadioDriverRamPage
;-----------------------------------------------------------------------------
 CYFISNP_SetPtr::
_CYFISNP_SetPtr::
        RAM_SETPAGE_CUR >CYFISNP_DriverRamPage
        MOV     [CYFISNP_Ptr+0], X         ; LSByte of pointer
  IF (SYSTEM_LARGE_MEMORY_MODEL)
        MOV     [CYFISNP_Ptr+1], A         ; LMM: MSB 16-bit pointer
  ENDIF
        RET

.endsection


.section
;-----------------------------------------------------------------------------
;
; RadioSetLength:  Set the buffer length for RadioBurstRead & RadioFileRead.
;
; 'C' Call:        void RadioSetLength(unsigned char length);
;
; Return:     CUR_PP: Large Memory Model sets to RadioDriverRamPage
;-----------------------------------------------------------------------------
 CYFISNP_SetLength::
_CYFISNP_SetLength::
        RAM_SETPAGE_CUR >CYFISNP_DriverRamPage
        MOV     [CYFISNP_Len], A
        RET

.endsection


.section
;-----------------------------------------------------------------------------
;
; RadioReset: Send Soft Reset command to radio.
;
; 'C' Call:        void RadioReset(void);
;
; Assembly Call:   A: none
;                  X: none
;
; Assembly Return: A: 1 on successful execution.  0 if unsuccessful.
;                  X: lost
;             CUR_PP: Large Memory Model sets to RadioDriverRamPage
; Notes
; 1. To conserve RAM usage, CYFISNP_WipLen and
;    CYFISNP_WipPtr are accessed.  These variables are declared in
;    CYFISNP_PSoC_SPIm.asm or CYFISNP_E2_SPIm.asm.  It is
;    assumed that at the time, this function is called, these variables
;    contain no meaningful value.
;
; Side Effects
; 1. Modifes global variables CYFISNP_WipLen and
;    CYFISNP_WipPtr.
;-----------------------------------------------------------------------------
_CYFISNP_Reset::
 CYFISNP_Reset::
        RAM_SETPAGE_CUR >CYFISNP_DriverRamPage

        CYFISNP_RADIO_DESELECT

        ;---------------------------------------------------------------------
        ; This CYFISPI_RST only NEEDS to work during soft-reset (NOT POR) to
	;  ensure Radio starts in 4-wire mode because in Minimum Power Mode
	;  4-wire mode is temporarily set to 3-wire mode to unfloat MISO.
        ;---------------------------------------------------------------------
        MOV     A, CYFISNP_MODE_OVERRIDE_ADR       ; Reset Radio via SPI soft reset
        MOV     X, CYFISNP_RST                     ;  (don't use RST pin)
        CALL    CYFISNP_Write                      ; Issue soft-reset

        ;---------------------------------------------------------------------
        ; Wait for the radio to emerge from POR.  At max SPI rate of 4 Mbps,
        ; One loop through this wait takes at least 8 microseconds.  To get a
        ; minimum of 20 ms, 2500 loops are required.  At a SPI rate of 500
        ; kbps, this loop would take 160 ms.
        ;---------------------------------------------------------------------

        ; Initialize timeout counter for 2500 (0x09C4) iterations max.
        mov  [CYFISNP_WipLen], 0x09                ; CYFISNP_WipLen is the timeout counter MSB
        mov  [CYFISNP_WipPtr], 0xC4                ; CYFISNP_WipPtr is the timeout counter LSB
.wait:
        M8C_ClearWDT
        DEC    [CYFISNP_WipPtr]
        SBB    [CYFISNP_WipLen], 0
        JC     .InitError


IF CYFISNP_SPI_MODE_SDIO
        MOV A,CYFISNP_IO_CFG_ADR
        MOV X,CYFISNP_SPI_3_PIN
        CALL CYFISNP_Write
        MOV A, CYFISNP_IO_CFG_ADR
        CALL CYFISNP_Read                          ; Try and readback using 3-Wire SPI
        CMP A, CYFISNP_SPI_3_PIN
ELSE
        MOV    A, CYFISNP_CHANNEL_ADR
        MOV    X, 5
        CALL   CYFISNP_Write
        MOV    A, CYFISNP_CHANNEL_ADR
        CALL   CYFISNP_Read
        CMP    A, 5
ENDIF
        JNZ    .wait


        ;---------------------------------------------------------------------
    	; Soft reset CYFISPI
        ;---------------------------------------------------------------------
        MOV     A, CYFISNP_MODE_OVERRIDE_ADR    ; Reset Radio through SPI (soft reset)
        MOV     X, CYFISNP_RST                  ;  (don't use RST pin)

IF (CYFISNP_IRQ_MOSI_MUXED & CYFISNP_SPI_MODE_SDIO)
        CALL    CYFISNP_Write              ; Issue soft-reset
        MOV     A, CYFISNP_IO_CFG_ADR           ;
        MOV     X, CYFISNP_SPI_3_PIN | CYFISNP_IRQ_GPIO ; Enable IRQ/MOSI mux + 3-wire SPI
ELSE
    IF CYFISNP_IRQ_MOSI_MUXED                        ; and non-3-wire SPI
        CALL    CYFISNP_Write              ; Issue soft-reset
        MOV     A, CYFISNP_IO_CFG_ADR           ;
        MOV     X, CYFISNP_IRQ_GPIO             ; Only enable IRQ muxed on MOSI pin
    ENDIF
    IF CYFISNP_SPI_MODE_SDIO                   ; and non-Muxed IRQ
        CALL    CYFISNP_Write              ; Issue soft-reset
        MOV     A, CYFISNP_IO_CFG_ADR           ;
        MOV     X, CYFISNP_SPI_3_PIN            ; Only enable 3-wire SPI
    ENDIF
ENDIF
        call CYFISNP_Write
        mov  A, 1
        ret

.InitError:
        mov  A, 0
        ret
.endsection




.section
;-----------------------------------------------------------------------------
;
; RadioStartTransmit:
;                  Start the transmission of a packet. The location of the
;                  packet buffer to transmit must have previously been set
;                  by calling RadioSetPtr().
;
;                  After starting the transmission of a packet with this call,
;                  the transmit operation should be monitored via
;                  RadioGetTransmitState(). When RadioGetTransmitState()
;                  indicates that the transmission has completed, then
;                  RadioEndTransmit() should be called.
;
;                  After calling RadioStartTransmit() NO CALLS can be made to
;                  configuration access routines until transmit operation is
;                  terminated by calling RadioEndTransmit() or RadioAbort().
;                  Until a call is made to end the transmit operation
;                  the only other call supported is RadioGetTransmitState().
;
; 'C' Call:        void RadioStartTransmit(BYTE retryCount, RADIO_LENGTH len);
;                  (A call to RadioSetPtr must have been made prior to the
;                  call to RadioStartTransmit.)
;
; Assembly Call:   A: retry count
;                  X: packet length
;
; Assembly Return: A: State
;                  X: Undefined
;-----------------------------------------------------------------------------
_CYFISNP_StartTransmit::
 CYFISNP_StartTransmit::
        RAM_SETPAGE_CUR >CYFISNP_DriverRamPage
        MOV     [CYFISNP_RetryCount], A             ; Save retry count
        MOV     [CYFISNP_Temp1], X                  ;  and length.

;-----------------------------------------------------------------------------
; Start the transmission and a maximum of 16 Data Bytes.
; For packets larger than 16 Bytes, the TXB8 IRQ is exposed, so the GIE is
;  disabled.  Also the lpGIE image is "disabled" to prevent the GIE being
;  re-enabled at SPI Write or Read returns.  Because RadioRestartTransmit()
;  is called from either ISR or polled, it must be very careful to enable
;  GIE as desired ONLY after the first 16-bytes are written.
;-----------------------------------------------------------------------------
        CALL    CYFISNP_SaveAndClearGIE

        CALL    CYFISNP_RestartTransmit

        JMP     CYFISNP_RestoreGIE


;-----------------------------------------------------------------------------
; CYFISNP_RestartTransmit - Starts burst and initial TxFIFO load.
;       When using CYFISNP_Interrupt(), it's called via non-ISR for first burst
;        and via ISR for retransmits.
;
; Assumptions
;    1. Interrupts are disabled on entry.
;-----------------------------------------------------------------------------
_CYFISNP_RestartTransmit::
 CYFISNP_RestartTransmit::

        CALL    CYFISNP_WakeupForXact

        MOV     [CYFISNP_State], CYFISNP_TX
        MOV     [CYFISNP_Temp2], (CYFISNP_TX_GO | CYFISNP_TX_CLR | CYFISNP_TXC_IRQ | CYFISNP_TXE_IRQ) ; CDT-15618
        ; --------------------------------------------------------------------
        ; If packet is longer than TxFIFO, load 16 bytes and leave remainder.
        ; --------------------------------------------------------------------
        MOV     X, [CYFISNP_Temp1]                          ; X = burst-size to radio
        MOV     [CYFISNP_TxCount], 0                        ; default to nothing extra
        MOV     A, X                                                 ; Subtract 16 from the packet size.
        SUB     A, CYFISNP_FIFO_SIZE                     ; Is radio buf big enough
        JC      .OneFIFO                                             ; Yes, send entire data
        MOV     [CYFISNP_TxCount], A                        ; No, save "extra" byte count
        MOV     X, CYFISNP_FIFO_SIZE                     ;  Limit burst to radio buf size
        OR      [CYFISNP_Temp2], CYFISNP_TXB8_IRQ  ;  Extra bytes: need to use TXB8 IRQ

        ; --------------------------------------------------------------------
        ; Issue TX_GO to start the radio transmitting and copy first TxFIFO
        ;
        ;  GIE is kept disabled throughout this because:
        ;   1) TXB8_IRQ must be blocked until TxFIFO first loaded.
        ;   2) First TxFIFO may need quick loading, depending on Synth state.
        ; --------------------------------------------------------------------
.OneFIFO:
        MOV     [CYFISNP_TxCtrlShadow], [CYFISNP_Temp2]
        PUSH    X                                        ; Save data Tx Buf write len

        MOV     [CYFISNP_WipPtr], <CYFISNP_Temp1 ; Burst write the
IF (SYSTEM_LARGE_MEMORY_MODEL)
        MOV        [CYFISNP_WipPtr+1], >CYFISNP_Temp1
ENDIF
        MOV     A, CYFISNP_TX_LENGTH_ADR        ;  to start the TX.
        MOV     X, 2
        MOV     [CYFISNP_WipLen], X
        CALL    CYFISNP_BurstWriteWipRaw      ; Write length and TX control as burst.

        POP     X                                        ; # bytes to burst to radio Tx Buf
        MOV     A, CYFISNP_TX_BUFFER_ADR
        CALL    CYFISNP_FileWriteRaw          ; Burst the data in

        MOV     A, [CYFISNP_State]
        RET
.endsection


.section
;-----------------------------------------------------------------------------
;
; RadioGetTransmitState:
;                  Returns the state of the current transmit operation.
;                  This call should be made after starting a transmit
;                  operation with the RadioStartTransmit function.
;
;                  Although bits in the status register in the hardware clear
;                  automatically, we make them sticky until RadioEndReceive.
;
;  IF USING RadioInterrupt(), DON'T CALL RadioGetTransmitState(),
;    READ RadioState DIRECTLY
;
; 'C' Call:        RADIO_STATE RadioGetTransmitState(void);
;
; Assembly Call:   A: Unused
;                  X: Unused
;
; Assembly Return: A: State
;                  X: Undefined
;-----------------------------------------------------------------------------
_CYFISNP_GetTransmitState::
 CYFISNP_GetTransmitState::
        RAM_SETPAGE_CUR >CYFISNP_DriverRamPage

  IF CYFISNP_RADIO_INTERRUPT
        JMP     exitTx                  ; Service by Interrupt only: CDT-15694
  ELSE
        CALL    CYFISNP_SaveAndClearGIE
        CYFISNP_TST_IRQ_PIN    ; Has interrupt asserted?
        JZ      exitTx                  ;  No, just return the state.
  ENDIF


        ;
        ; Something interesting is happening at IRQ, find out what.
        ;
_CYFISNP_GetTransmitStateIsr::
 CYFISNP_GetTransmitStateIsr::
        MOV     A, CYFISNP_TX_IRQ_STATUS_ADR
        CALL    CYFISNP_ReadStatusDebouncedRaw
        AND     A, (CYFISNP_TXB8_IRQ | CYFISNP_TXE_IRQ | CYFISNP_TXC_IRQ)
        AND     A, [CYFISNP_TxCtrlShadow]
        OR      [CYFISNP_State], A
        XOR     A, CYFISNP_TXB8_IRQ
        JNZ     CYFISNP_TxDontMoveData

        ; Moving data, set TX IRQ mask to B8 only to simplify checking
        ;  when subsequent data can be moved after the first burst.
        ;
        MOV     X, CYFISNP_TXB8_IRQ             ; End of the data, clear the B8
        MOV     A, CYFISNP_TX_CTRL_ADR          ;  flag in the TX control register.
        CALL    CYFISNP_WriteRaw

        ; Is the remaining data is longer than the 8 free bytes in TxFIFO.
        ;  Start by assuming a short packet.  In that case...
        ;
.MoveDataLoop:
        MOV     X, [CYFISNP_TxCount]       ; First burst is PacketLength bytes
        MOV     [CYFISNP_TxCount], 0       ;  and we will have no data left.
        MOV     A, X                                ; Subtract 8 from the packet size.
        SUB     A, CYFISNP_FIFO_HALF
        JC      .lastChunk                          ; If packet size >= 8 fall through
        MOV     [CYFISNP_TxCount], A       ;  save the difference as remaining
        MOV     X, CYFISNP_FIFO_HALF         ;  count and use 8 for this burst.
.lastChunk:
        MOV     A, CYFISNP_TX_BUFFER_ADR
        CALL    CYFISNP_FileWriteWipRaw       ; Burst the data in.

        MOV     X, (CYFISNP_TXC_IRQ | CYFISNP_TXE_IRQ)  ; TX_CTRL value assuming no more data.
        MOV     A, [CYFISNP_TxCount]       ; Was that the end of the data?
        JZ      .NoMoreData             ;  Yes, that will be all.

        CYFISNP_TST_IRQ_PIN                     ; Is there room for more data?
        JNZ     .MoveDataLoop           ;  Yes, go move some more data.

        MOV     X, (CYFISNP_TXB8_IRQ | CYFISNP_TXC_IRQ | CYFISNP_TXE_IRQ)
                                        ; No more room, put TX_CTRL back.
.NoMoreData:
        MOV     [CYFISNP_TxCtrlShadow], X
        MOV     A, CYFISNP_TX_CTRL_ADR          ;  Update the TX control register.
        CALL    CYFISNP_WriteRaw

CYFISNP_TxCheckTxErrors:
        MOV     A, [CYFISNP_State]
        AND     A, (CYFISNP_TXE_IRQ | CYFISNP_TXBERR_IRQ)
        JZ      CYFISNP_TxNoErrors
CYFISNP_TxIsError:
        OR      [CYFISNP_State], CYFISNP_TXC_IRQ
CYFISNP_TxNoErrors:
        TST     [CYFISNP_State], CYFISNP_TXE_IRQ
        JZ      exitTx                    ; Tx was error-free, done

        DEC     [CYFISNP_RetryCount]       ; Decrement and test Tx retry count
        JC      exitTx
        CALL    CYFISNP_RestartTransmit

exitTx:
        MOV     A, [CYFISNP_State]
  IF (CYFISNP_RADIO_INTERRUPT)
        RET
  ELSE
        JMP     CYFISNP_RestoreGIE
  ENDIF

;-----------------------------------------------------------------------------
; We're here, but NOT to move data. 'A' contains the last TX status read with
;  TXC masked out. RadioState has had the last TX status read OR'd in
;  including TXC bit. If TXC, TXE, and TXBERR are all clear that is an error.
;-----------------------------------------------------------------------------
CYFISNP_TxDontMoveData:
        TST     [CYFISNP_State], CYFISNP_TXC_IRQ
        JNZ     CYFISNP_TxCheckTxErrors
        AND     A, (CYFISNP_TXE_IRQ | CYFISNP_TXBERR_IRQ)
        JNZ     CYFISNP_TxIsError
        MOV     A, CYFISNP_RX_IRQ_STATUS_ADR    ; Radio saw SOP during AAck Rx window
        CALL    CYFISNP_ReadRaw                 ; (RXE/RXC asserted), clear RXC/RXE
        JMP     CYFISNP_TxIsError               ; and treat as Tx Error
.endsection


.section
;-----------------------------------------------------------------------------
;
; RadioEndTransmit: Completes a transmit operation.
;
; 'C' Call:        void RadioEndTransmit(void);
;
; Assembly Call:   A: Unused
;                  X: Unused
;
; Assembly Return: A: Preserved
;                  X: Undefined
;
_CYFISNP_EndTransmit::
 CYFISNP_EndTransmit::
        RAM_SETPAGE_CUR >CYFISNP_DriverRamPage
        MOV     [CYFISNP_State], CYFISNP_IDLE        ; Clear our status.
        RET
.endsection

.section
;-----------------------------------------------------------------------------
;
; RadioBlockingTransmit:
;                  Transmit a packet. Block execution until it completes.
;                  This function attempts to transmit a packet. The address
;                  of the packet buffer should have previously been set with
;                  a call to RadioSetPtr.
;
;                  This routine gives the user very little control - probably
;                  less than most applications will require. This function is
;                  primarily intended for very simple applications that have
;                  no use for a time-out.
;
; 'C' Call:        RADIO_STATE RadioBlockingTransmit(BYTE retryCt,
;                                                    RADIO_LENGTH len);
;                  (A call to RadioSetPtr must have been made prior to the
;                  call to RadioBlockingTransmit.)
;
; Assembly Call:   A: retryCount
;                  X: length
;                  RadioPtr: Address of packet buffer
;
; Assembly Return: A: RADIO_STATE
;                  X: Undefined
;-----------------------------------------------------------------------------
_CYFISNP_BlockingTransmit::
 CYFISNP_BlockingTransmit::
        CALL    CYFISNP_StartTransmit

.Wait:  CALL    CYFISNP_GetTransmitState
        AND     A, CYFISNP_TXC_IRQ | CYFISNP_TXE_IRQ    ; CDT-15709
        JZ      .Wait

        JMP     CYFISNP_EndTransmit        ; A = RADIO_STATE
.endsection


;--------------------------------------------------------------------------;
;                                                                          ;
;                 R E C E I V E                                            ;
;                                                                          ;
;--------------------------------------------------------------------------;
.section
;-----------------------------------------------------------------------------
;
; RadioStartReceive:
;                  Start the reception of a packet. The location and length of
;                  the packet buffer to receive the data into must have
;                  previously been set with a call to RadioSetPtr and
;                  RadioSetLength.
;
;                  After starting the reception of a packet with this call,
;                  the state of the receive operation should be checked by
;                  calling RadioGetReceiveState. When RadioGetReceiveState
;                  indicates that the transmission has completed a call
;                  should be made to RadioEndReceive.
;
;                  Receive is started by setting RX_GO" bit. All interesting
;                  interrupt enables are set and RadioGetReceiveState
;                  can be called in a polling loop in systems that do not use
;                  interrupts, or can be called directly in an interrupt
;                  handler.
;
;                  After calling RadioStartReceive NO CALLS can be made to the
;                  configuration access routines until receive operation is
;                  terminated with a call to RadioEndReceive or RadioAbort.
;                  Until a call is made to end the receive operation
;                  the only other calls supported are RadioGetReceiveState and
;                  RadioGetRssi.
;
; 'C' Call:        void RadioStartReceive(void);
;                  (A call to RadioSetPtr must have been made prior to the
;                  call to RadioStartReceive.)
;
; Assembly Call:   A: Unused
;                  X: Unused
;
; Assembly Return: A: Undefined
;                  X: Undefined
;-----------------------------------------------------------------------------
_CYFISNP_StartReceive::
 CYFISNP_StartReceive::
        RAM_SETPAGE_CUR >CYFISNP_DriverRamPage
  IF (SYSTEM_LARGE_MEMORY_MODEL)
        MOV     [CYFISNP_WipPtr+1], [CYFISNP_Ptr+1] ; MSByte of pointer
  ENDIF
        MOV     [CYFISNP_WipPtr+0], [CYFISNP_Ptr+0]
        MOV     [CYFISNP_WipLen],   [CYFISNP_Len]   ; sizeof(RadioPtr)
        MOV     [CYFISNP_State], CYFISNP_RX
        MOV     [CYFISNP_BytesRead], 0

; ----------------------------------------------------------------------------
; If Radio's End State (and implied current State) is SLEEP, need:
;       1) Workaround to startup oscillator.
;       2) Workaround to keep awake briefly at end of receive.
; ----------------------------------------------------------------------------
        CALL    CYFISNP_SaveAndClearGIE
        CALL    CYFISNP_Wakeup
        CALL    CYFISNP_RestoreGIE

        CYFISNP_IsSleepDesired
        JNZ     .StayAwakeWhenDone

        ; Set the radio end State to IDLE so it has time to clean up at RXE/RXC
        ; However, don't change the value of CYFISNP_XactConfig
        MOV     A, [CYFISNP_XactConfig]
        MOV     [CYFISNP_RestingState], A       ; Save the desired end state as the resting state since this wasn't done in CYFISNP_Wakeup
        AND     A, ~CYFISNP_END_STATE_MSK
        OR      A,  CYFISNP_END_STATE_IDLE
        MOV     X, CYFISNP_XACT_CFG_ADR
        CALL    CYFISNP_WriteSwapped

.StayAwakeWhenDone:
        MOV     A, CYFISNP_CLK_OVERRIDE_ADR     ;
        MOV     X, CYFISNP_RXF                  ; Keep Rx clock running at RXE/RXC
        CALL    CYFISNP_Write              ;

        MOV     A, CYFISNP_RX_CTRL_ADR
        MOV     X, (CYFISNP_RX_GO | CYFISNP_RXB8_IRQ | CYFISNP_RXC_IRQ | CYFISNP_RXE_IRQ)
        CALL    CYFISNP_Write

        MOV     A, CYFISNP_RX_IRQ_STATUS_ADR
        JMP     CYFISNP_Read               // Clr SOP detect bit
.endsection

.section
;-----------------------------------------------------------------------------
;
; RadioGetReceiveState:
;                  Returns the state of the current receive operation.
;                  This call should be made after RadioStartReceive()
;
;                  Although  bits in the state register in the hardware clear
;                  automatically, we make them sticky until RadioEndReceive.
;
;  IF USING RadioInterrupt(), DON'T CALL RadioGetReceiveState(),
;    READ RadioState DIRECTLY
;
; 'C' Call:        RADIO_STATE RadioGetReceiveState(void);
;
; Assembly Call:   A: Unused
;                  X: Unused
;
; Assembly Return: A: State
;                  X: Undefined
;-----------------------------------------------------------------------------
_CYFISNP_GetReceiveState::
 CYFISNP_GetReceiveState::
        RAM_SETPAGE_CUR >CYFISNP_DriverRamPage
  IF CYFISNP_RADIO_INTERRUPT
        JMP     exitRx                  ; Service by Interrupt only: CDT-15694
  ELSE
        CALL    CYFISNP_SaveAndClearGIE
  ENDIF

GetRxStatePinTest:
        CYFISNP_TST_IRQ_PIN
        JZ      exitRx                  ; Nothing interesting, exit

_CYFISNP_GetReceiveStateIsr::
 CYFISNP_GetReceiveStateIsr::                ; Entry via RadioInterrupt() wrapper
        MOV     A, CYFISNP_RX_IRQ_STATUS_ADR
        CALL    CYFISNP_ReadStatusDebouncedRaw
        OR      [CYFISNP_State], A         ; Make bits sticky

        ; RXBERR and RXE imply RXC, so any of these 3 flags implies there's
        ;  no rush to unload RFIFO.
        AND     A, (CYFISNP_RXBERR_IRQ | CYFISNP_RXE_IRQ | CYFISNP_RXC_IRQ | CYFISNP_RXB8_IRQ)
        XOR     A, CYFISNP_RXB8_IRQ             ; If more than RXB8_IRQ is SET, then
        JNZ     .rxEnded                ;  Rx ended, RadioEndReceive unloads

        MOV     A, CYFISNP_RX_BUFFER_ADR        ; Get RFIFO data on-the-fly
        MOV     X, CYFISNP_FIFO_HALF
        CALL    CYFISNP_FileReadWipRaw
        ADD     [CYFISNP_BytesRead], CYFISNP_FIFO_HALF

        MOV     A, CYFISNP_RX_CTRL_ADR          ;
        MOV     X, CYFISNP_RXB8_IRQ             ;
        CALL    CYFISNP_WriteRaw                ; Only expose RXB8
        JMP     .RXB8_tst               ;

.RXB8_set:
        MOV     A, CYFISNP_RX_BUFFER_ADR        ; Only RXB8 is exposed on IRQ
        MOV     X, CYFISNP_FIFO_HALF         ;  so we know least 8 bytes in RFIFO
        CALL    CYFISNP_FileReadWipRaw
        ADD     [CYFISNP_BytesRead], CYFISNP_FIFO_HALF
.RXB8_tst:
        CYFISNP_TST_IRQ_PIN
        JNZ     .RXB8_set               ; Only RXB8 is exposed on IRQ

        MOV     A, CYFISNP_RX_CTRL_ADR          ; Expose RXE and RXC also
        MOV     X, (CYFISNP_RXB8_IRQ | CYFISNP_RXC_IRQ | CYFISNP_RXE_IRQ)
        CALL    CYFISNP_WriteRaw
        JMP     GetRxStatePinTest

;
; RXC and/or RXE, RXBERR are set, so radio Rx has ended
;
.rxEnded:
        TST     [CYFISNP_State], (CYFISNP_RXBERR_IRQ | CYFISNP_RXE_IRQ) ; If Error,
        JZ      exitRx                             ;  then set RXC/RXE
        OR      [CYFISNP_State], (CYFISNP_RXC_IRQ | CYFISNP_RXE_IRQ)    ;  because radio is done

exitRx:
        MOV     A, [CYFISNP_State]         ;  State calls and return them.
  IF (CYFISNP_RADIO_INTERRUPT)
        RET
  ELSE
        JMP     CYFISNP_RestoreGIE
  ENDIF

.endsection

.section
;-----------------------------------------------------------------------------
;
; RadioEndReceive: Complete a receive operation.
;
; 'C' Call:        RADIO_LENGTH RadioEndReceive(void);
;
; Assembly Call:   A: Unused
;                  X: Unused
;
; Assembly Return: A: # of bytes copied to User's Buf
;                  X: Undefined
;-----------------------------------------------------------------------------
_CYFISNP_EndReceive::
 CYFISNP_EndReceive::
        MOV     A, CYFISNP_RX_CFG_ADR           ; Read current VLD_EN setting
        CALL    CYFISNP_Read                    ; (RadioRead also sets CUR_PP)
        MOV     [CYFISNP_Temp3], A              ;

        MOV     A, CYFISNP_RX_COUNT_ADR         ; Total # bytes through RFIFO
        CALL    CYFISNP_Read                    ; (RadioRead also sets CUR_PP)
        TST     [CYFISNP_Temp3], CYFISNP_VLD_EN
        JZ      .S2                                      ; Normal (VLD_EN == 0)
        ASL     A                                        ; 2x, every data byte has a valid byte
.S2:    MOV     [CYFISNP_Temp3], A              ; # Bytes in RFIFO

        SUB     A, [CYFISNP_BytesRead]          ; Subtract # bytes we've extracted
                                                         ;  leaves # bytes sitting in RFIFO
        TST     [CYFISNP_State], CYFISNP_RXE_IRQ   ;
        JZ      .S1                                      ; No error, unload the final byte(s)
        MOV     A, CYFISNP_FIFO_SIZE         ; RXE, purge full RFIFO to recove
.S1:
        MOV     X, CYFISNP_RX_BUFFER_ADR
        SWAP    A, X
        CALL    CYFISNP_FileReadWip             ; Final RFIFO unload

        ; --------------------------------------------------------------------
        ; If User wanted CYFISNP_END_STATE_SLEEP, then undo
        ;  CYFISNP_StartReceive()'s intermediate CYFISNP_END_STATE_IDLE override.
        ; --------------------------------------------------------------------
        CYFISNP_IsSleepDesired                  ; If user's desired end state != SLEEP
        JNZ     isAwake                                  ;  then no workaround was invoked.

        ; --------------------------------------------------------------------
        ; CYFISNP_RxCleanup() - end of CYFISNP_Abort()
        ; --------------------------------------------------------------------
CYFISNP_RxCleanup:
        MOV     A, [CYFISNP_XactConfig]    ;
        OR      A, CYFISNP_FRC_END_STATE        ; Force to User's desired end-state
        MOV     X, CYFISNP_XACT_CFG_ADR
        CALL    CYFISNP_WriteSwapped
.wait:  MOV     A, CYFISNP_XACT_CFG_ADR         ; Wait for FRC_END_STATE bit in
        CALL    CYFISNP_Read                    ;  XACT_CFG register to clear
        AND     A, CYFISNP_FRC_END_STATE        ;  indicating the Force End is
        JNZ     .wait                                    ;  complete.
        ; ------------------------------

isAwake:
        MOV     A, CYFISNP_CLK_OVERRIDE_ADR     ; Done receiving, stop forcing the
        MOV     X, 0                    ;  RXF clock.
        CALL    CYFISNP_Write

        MOV     A, [CYFISNP_Temp3]         ; Byte count
        JMP     CYFISNP_EndTransmit
.endsection


.section
;-----------------------------------------------------------------------------
;
; RadioAbort:      Abort a receive operation.
;
; 'C' Call:        RADIO_LENGTH RadioAbort(void);
;
; Assembly Call:   A: Unused
;                  X: Unused
;
; Assembly Return: A: RADIO_ABORT_SUCCESS or Length of valid Rx packet
;                  X: Undefined
;-----------------------------------------------------------------------------
_CYFISNP_Abort::
 CYFISNP_Abort::
        RAM_SETPAGE_CUR >CYFISNP_DriverRamPage
        TST     [CYFISNP_State], CYFISNP_RX  ; This Abort handling is RX specific.
        JZ      .Abort

        ;  Don't issue Force End if receive has started.
        MOV     X, CYFISNP_ABORT_EN             ; Try to avoid committing to a Receive
        MOV     A, CYFISNP_RX_ABORT_ADR         ;  packet by invoking Digital Loopback
        CALL    CYFISNP_Write              ;
        ; ------------------------------
        MOV     X, 128                   ; Delay to see if SOP arrives
.L1:    DEC     X       ; 4 cycles      ;
        JNZ     .L1     ; 5 cycles      ; (9 * 128) / 12 MHz = 96 uS
        ; ------------------------------
        MOV     A, CYFISNP_RX_IRQ_STATUS_ADR    ; See if Rx packet has started
        CALL    CYFISNP_ReadStatusDebounced;
        OR      [CYFISNP_State], A         ; Make bits sticky
        TST     [CYFISNP_State], CYFISNP_SOPDET_IRQ
        JNZ     .RxOk                   ; Rx packet has started, finish it
        CALL    CYFISNP_RxCleanup          ; Rx packet blocked, issue FORCE_END

.Abort: MOV     A, CYFISNP_ABORT_SUCCESS
        JMP     .AbortExit

; ----------------------------------------------------------------------------
; Receiving a packet, allow to finish naturally.
; Probably has errors (RXE) because we activated Digital Loopback,
;  but if Loopback activated during AutoAck, we'll have a valid packet
;  (which was AutoAcked, so we'd better not discard it!).
; ----------------------------------------------------------------------------
.RxOk:  CALL    CYFISNP_GetReceiveState    ; Keep servicing receiver
        TST     [CYFISNP_State], CYFISNP_RXE_IRQ | CYFISNP_RXC_IRQ
        JZ      .RxOk

        TST     [CYFISNP_State], CYFISNP_RXE_IRQ   ; CDT 16852
        JNZ     .rxe                    ; Rx packet was BAD
.rxc:   CALL    CYFISNP_EndReceive         ; Rx packet was Good
        JMP     .AbortExit              ; Exit w/Acc = # bytes loaded

.rxe:   CALL    CYFISNP_EndReceive
        MOV     A, CYFISNP_ABORT_SUCCESS  ; Exit w/Acc = ABORT SUCCESS

.AbortExit:
        PUSH    A
        MOV     X, 0
        MOV     A, CYFISNP_RX_ABORT_ADR        ; Remove digital Loopback
        CALL    CYFISNP_Write
        POP     A
        RET
.endsection


.section
;-----------------------------------------------------------------------------
;
; RadioGetReceiveStatus:
;                  Returns the receiver status register.
;
; 'C' Call:        RADIO_RX_STATUS RadioGetReceiveStatus(void);
;
; Assembly Call:   A: Unused
;                  X: Unused
;
; Assembly Return: A: Status
;                  X: Undefined
;-----------------------------------------------------------------------------
_CYFISNP_GetReceiveStatus::
 CYFISNP_GetReceiveStatus::
        MOV     A, CYFISNP_RX_STATUS_ADR
        JMP     CYFISNP_Read                        ; This JMP saves 14 CPU clock cycles over a CALL.
                                                             ; (6 for the difference between JMP and CALL, and 8 for one less RET to execute.)
                                                             ; It also saves 1 byte of ROM.
.endsection


.section
;-----------------------------------------------------------------------------
;
; RadioForceState:  Force radio to desired state NOW.
;                   Updates global RadioXacConfig shadow variable.
;                   Sometimes used to wake/sleep radio to measure voltage.
;
;  We must ensure SLEEP only transitions to IDLE (and recovers if problem).
;  RadioForceState(END_STATE_IDLE) MUST be called prior to TX_GO or RX_GO
;   whenever radio may be in SLEEP.
;
; 'C' Call:        void RadioForceState(XACT_CONFIG endStateBitsOnly);
;
; Assembly Call:   A: RadioXactConfig END_STATE bits only, no ACK_EN, ACK_TO
;                  X: Undefined
;
; Assembly Return: A,X: Undefined
;
; Side Effects:
; 1. Modifies the CYFISNP_XactConfig global variable.
;
; Assumptions:
; 1. CYFISNP_RestingState contains the new state after the call to
;    CYFISNP_ChangeState.  Furthermore, all non-state field bits
;    in CYFISNP_RestingState are cleared on return from
;    CYFISNP_ChangeState.
;-----------------------------------------------------------------------------
_CYFISNP_ForceState::
 CYFISNP_ForceState::
        RAM_SETPAGE_CUR >CYFISNP_DriverRamPage

        CALL    CYFISNP_SaveAndClearGIE

        PUSH    A                                                                ; Save target state
        CALL    CYFISNP_Wakeup
        POP     A                                                                ; Restore target state

        CALL    CYFISNP_ChangeState                                     ; Set the new state

        MOV     A, [CYFISNP_RestingState]                               ; Obtain the new state that was stored by CYFISNP_ChangeState
        AND     [CYFISNP_XactConfig], ~CYFISNP_END_STATE_MSK
        OR      [CYFISNP_XactConfig], A                                 ; Save the new state in CYFISNP_XactConfig

        JMP     CYFISNP_RestoreGIE                                      ; This JMP saves 14 CPU clock cycles over a CALL.
                                                                                 ; (6 for difference between JMP and CALL, and 8 for one less RET to execute.)
                                                                                 ; It also saves 1 byte of ROM.


; END OF CYFISNP_ForceState


; ----------------------------------------------------------------------------
; CYFISNP_WakeupForXact - Wake up the radio.  Then restore the
;       end state.
;
; CYFISNP_RestoreXactConfig - Restore the end state currently held
;       in CYFISNP_XactConfig
;
; Assembly Call (both functions):   A: Unused
;                                   X: Unused
;
; Return Value
;    None
;
; Side Effects:
; 1. Modifies the CYFISNP_RestingState global variable.
;
; Notes:
; 1. The Force End State bit of CYFISNP_RestingState is always
;    cleared on exit from this function.  All other bits are set equal to
;    the values of their corresponding bits in CYFISNP_XactConfig.
; 2. This routine cannot be safely executed with interrupts enabled.
; ----------------------------------------------------------------------------
CYFISNP_WakeupForXact:
        CALL     CYFISNP_Wakeup

CYFISNP_RestoreXactConfig:
        ; Restore the unforced END state to its originally desired value from CYFISNP_XactConfig
        MOV     A, [CYFISNP_XactConfig]
        AND     A, ~CYFISNP_FRC_END_STATE           ; Clear the force state bit
        MOV     [CYFISNP_RestingState], A           ; Save the new resting state.

        JMP     CYFISNP_WriteXactConfigRegUnsafe    ; This JMP saves 14 CPU clock cycles over a CALL.
                                                             ; (6 for difference between JMP and CALL, and 8 for one less RET to execute.)
                                                             ; It also saves 1 byte of ROM.


; ----------------------------------------------------------------------------
; CYFISNP_Wakeup - If radio is in SLEEP, wake it up.
;
; Assembly Call:   A: Unused
;                  X: Unused
;
; CYFISNP_ChangeState
;               Does the actual changing of radio state.
;
; Assembly Call:   A: State to change to.
;                  X: Unused
;
; Return Value
;    None
;
; Side Effects
; 1. Modifies the CYFISNP_Scratch0 global variable.
;
; Notes
; 1. Both these routines share the CYFISNP_return label.
; 2. These routines cannot be safely executed with interrupts enabled.
; ----------------------------------------------------------------------------
CYFISNP_Wakeup:
        CYFISNP_IsRadioSleep
        JNZ     CYFISNP_return                     ; Skip this routine if the radio is awake.

        ; Force the radio from SLEEP to IDLE
        MOV     A, CYFISNP_END_STATE_IDLE

        ; Fall through to CYFISNP_ChangeState

CYFISNP_ChangeState:
        CALL    CYFISNP_WriteForcedState           ;
        MOV     [CYFISNP_Scratch0], 0              ; Initialize 256 iteration timeout counter
.wait5:
        MOV     A, CYFISNP_XACT_CFG_ADR            ;
        CALL    CYFISNP_ReadRaw                    ;
        AND     A, CYFISNP_FRC_END_STATE           ;
        JZ     CYFISNP_return                      ; Wait for Force End State completion
        DEC     [CYFISNP_Scratch0]
        JNZ     .wait5                                      ; Check for timeout.  Timeout possible ONLY when going SLEEP to IDLE

        ; Timeout occurred.  Retry going back to sleep and transitioning to idle.  This time, assume success.
        MOV     A, CYFISNP_END_STATE_SLEEP
        CALL    CYFISNP_WriteForcedState
        MOV     A, CYFISNP_END_STATE_IDLE
        JMP     CYFISNP_WriteForcedState           ; This JMP saves 14 CPU clock cycles over a CALL.
                                                            ; (6 for the difference between JMP and CALL, and 8 for one less RET to execute.)
CYFISNP_return:
        RET

; END OF CYFISNP_WakeupForXact, CYFISNP_RestoreXactConfig, CYFISNP_Wakeup, & CYFISNP_ChangeState.


;-----------------------------------------------------------------------------
; @INSTANCE_NAME_WriteForcedState
;    Merges existing ACK_EN, ACK_TO bits from CYFISNP_XactConfig
;    with end state bits in A.  Sets the force end state bit and passes A on
;    to CYFISNP_WriteXactConfigRegUnsafe.
;
; Return Value
;    None
;
; Assembly Call:   A: State to write
;                  X: Unused
;
; Side Effects
; 1. Modifies the CYFISNP_RestingState global variable.
;
; Notes
; 1. This routine cannot be safely executed with interrupts enabled.
; 2. All bits of CYFISNP_RestingState that do not correspond to the
;    state field of XACT_CONFIG_ADDR are cleared on exit.
;-----------------------------------------------------------------------------
CYFISNP_WriteForcedState:
        ; Save the new state in CYFISNP_RestingState and combine the new state with
        ; the existing ACK_EN and ACK_TO bits from CYFISNP_XactConfig.
        AND     A, CYFISNP_END_STATE_MSK            ; Clear non-state field bits.
        MOV     [CYFISNP_RestingState], A           ; Save the new state in CYFISNP_RestingState
        MOV     A, [CYFISNP_XactConfig]             ; Copy CYFISNP_XactConfig into A for further manipulation (to preserve CYFISNP_XactConfig's contents)
        AND     A, ~CYFISNP_END_STATE_MSK           ; Clear the old state field
        OR      A, [CYFISNP_RestingState]           ; Copy the new state field into A
        OR      A, CYFISNP_FRC_END_STATE            ; Set the Force State bit

        ; Allow execution to fall through to CYFISNP_WriteXactConfigRegUnsafe.
        ; This saves 19 CPU clock cycles and 3 bytes of ROM that using a CALL followed by a RET would have incurred.

;-----------------------------------------------------------------------------
; CYFISNP_WriteXactConfigRegUnsafe
;    Sends a transaction configuration to the radio.
;
; Return Value
;    None
;
; Assembly Call:   A: Value to write to the register.
;                  X: Unused
; Notes
; 1. This routine cannot be safely executed with interrupts enabled.
;-----------------------------------------------------------------------------

CYFISNP_WriteXactConfigRegUnsafe:
        MOV     X, CYFISNP_XACT_CFG_ADR
        JMP     CYFISNP_WriteSwappedRaw             ; This JMP saves 14 CPU clock cycles over a CALL.
                                                             ; (6 for the difference between JMP and CALL, and 8 for one less RET to execute.)
                                                             ; It also saves 1 byte of ROM.

; END OF CYFISNP_WriteForcedState & CYFISNP_WriteXactConfigRegUnsafe


.endsection


.section
;-----------------------------------------------------------------------------
;
; RadioGetRssi:    Returns the receiver signal strength indicator.
;
; 'C' Call:        RADIO_RSSI RadioGetRssi(void);
;
; Assembly Call:   A: Unused
;                  X: Unused
;
; Assembly Return: A: Rssi
;                  X: Undefined
;-----------------------------------------------------------------------------
_CYFISNP_GetRssi::
 CYFISNP_GetRssi::
        MOV     A, CYFISNP_RSSI_ADR
        JMP     CYFISNP_Read                        ; This JMP saves 14 CPU clock cycles over a CALL.
                                                             ; (6 for the difference between JMP and CALL, and 8 for one less RET to execute.)
                                                             ; It also saves 1 byte of ROM.
.endsection

        Resume_CodeCompressor
; ############################################################################
; END OF CYFISNP.asm
; ############################################################################

