;;*****************************************************************************
;;*****************************************************************************
;;  FILENAME: CYFISNP_PSoC_SPIm.asm
;;  Version: 2.00, Updated on 2011/6/28 at 6:7:54
;;  Generated by PSoC Designer 5.1.2306
;;
;;  DESCRIPTION: CYFISPI PSoC-specific SPI routines
;;-----------------------------------------------------------------------------
;;  Copyright (c) Cypress Semiconductor 2011. All Rights Reserved.
;;*****************************************************************************
;;*****************************************************************************

;--------------------------------------------------------------------------;
;                                                                          ;
;                      I N C L U D E   F I L E S                           ;
;                                                                          ;
;--------------------------------------------------------------------------;

include "m8c.inc"
include "Memory.inc"
include "CYFISNP.inc"


; This parameter is used to tune the SPI read/write routines
CPU_CYCLES_PER_SPI_BYTE:                  EQU     0x40

;-----------------------------------------------------------------------------
; Just shorter names for SPI I/O for local scope
CYFISNP_SPI_CTRL_REG:   EQU     CYFISNP_CONTROL_REG
CYFISNP_SPI_TX_REG:     EQU     CYFISNP_TX_BUFFER_REG
CYFISNP_SPI_RX_REG:     EQU     CYFISNP_RX_BUFFER_REG
CYFISNP_SPI_TX_EMPTY:   EQU     CYFISNP_SPIM_TX_BUFFER_EMPTY
CYFISNP_SPI_DONE:       EQU     CYFISNP_SPIM_SPI_COMPLETE
CYFISNP_SPI_RX_FULL:    EQU     CYFISNP_SPIM_RX_BUFFER_FULL
CYFISNP_SPI_RX_OVERRUN: EQU     CYFISNP_SPIM_RX_OVERRUN_ERROR


;--------------------------------------------------------------------------;
;                                                                          ;
;                            V A R I A B L E S                             ;
;                                                                          ;
;--------------------------------------------------------------------------;
AREA    InterruptRAM(ram)       ; Variables on RAM Page 0

IF SYSTEM_LARGE_MEMORY_MODEL
        ; Although contrary to the big-endian ImageCraft compiler,
        ;  Little-endian makes cleaner LMM/SMM macros.
CYFISNP_WipPtr::   BLK     2       ; Working pointer (LSB, MSB, little-endian)
CYFISNP_WipLen::   BLK     1       ; Working buffer length.
CYFISNP_Ptr::      BLK     2       ; SPI access routine parameter (little-endian)
CYFISNP_Len::      BLK     1       ; SPI access routines parameter - length.
ELSE
CYFISNP_WipPtr::   BLK     1       ; Working pointer.
CYFISNP_WipLen::   BLK     1       ; Working buffer length.
CYFISNP_Ptr::      BLK     1       ; Parameter to SPI access routines - address.
CYFISNP_Len::      BLK     1       ; Parameter to SPI access routines - length.
ENDIF

CYFISNP_SpiTemp:   BLK     1       ; Local working temp.


;-----------------------------------------------------------------------------
CYFISNP_SPI_USE:        equ     0x80
CYFISNP_OUTPUT_EN:      equ     0x01
CYFISNP_SPI_SWAP:       equ     0x80
;-----------------------------------------------------------------------------

;-----------------------------------------------------------------------------
macro   CYFISNP_SPI_TX_EMPTY_WAIT
.L2:    TST     REG[CYFISNP_SPI_CTRL_REG], CYFISNP_SPI_TX_EMPTY ; (TST opcode preserves CRY)
        JZ      .L2
endm
;-----------------------------------------------------------------------------
macro   CYFISNP_SPI_RX_FULL_WAIT
.L2:    TST     REG[CYFISNP_SPI_CTRL_REG], CYFISNP_SPI_RX_FULL ; (TST opcode preserves CRY)
        JZ      .L2
endm
;-----------------------------------------------------------------------------
macro   CYFISNP_SPI_RX_OVERRUN_WAIT
.L2:    TST     REG[CYFISNP_SPI_CTRL_REG], CYFISNP_SPI_RX_OVERRUN ; (TST opcode preserves CRY)
        JZ      .L2
endm

;-----------------------------------------------------------------------------

AREA    UserModules (ROM, REL)

    Suspend_CodeCompressor

;-----------------------------------------------------------------------------
;
; Some comments on the operation of the SPI PSoC block:
;
; The SPI_DONE and SPI_TX_EMPTY status
;  bits are self-clearing. After you've read SPI_CTRL_REG these
;  bits will be cleared. During a multibyte SPI transaction we use the
;  SPI_TX_EMPTY status to pace the data, but at the end
;  of a transaction we use SPI_DONE to determine that
;  we can de-assert the slave select.
;
; Although the hardware generates the SPI_CTRL_REG status
;  one full byte time before SPI_TX_EMPTY if you are
;  not reading the SPI_CTRL_REG register fast enough you might
;  see both of those status indications occur together, and after you've
;  read the SPI_CTRL_REG status it will clear and you will not see
;  it again. In the case that the SPI clock is very fast, or if interrupts
;  are left enabled during the execution of these routines then it is very
;  possible to see both of these indications occur together.
;
; In order for these routines to allow interrupts to be enabled during their
;  execution they are structured to allow the assertion of the two status
;  bits SPI_DONE and SPI_TX_EMPTY
;  on the same read of SPI_CTRL_REG. Although this is a real world
;  condition, you will only see it under stressed conditions.
;
; One other strangeness of the PSoC SPI block is that the
;  SPI_DONE status ONLY INDICATES THE STATE OF THE
;  SHIFTER - it does not include the state of the holding register. This
;  means that when we need to poll SPI_DONE at the
;  end of a transaction we need to make sure we see the status incdication
;  SPI_TX_EMPTY to know that the complete wasn't for
;  the previous byte.
;
;-----------------------------------------------------------------------------


;-------------------------------------------------------------------------------
; Interrupt Unsafe SPI API
;
; This portion of CYFISNP_PSoC_SPIm.asm does not manipulate the GIE
; flag in any way.  However, the GIE flag must be cleared when these routines
; are executing.  Therefore, they may only be directly called by interrupt
; service routines (which do not nest interrupts).
;-------------------------------------------------------------------------------


.section
;-----------------------------------------------------------------------------
;
; CYFISNP_WriteSwappedRaw: Write a single byte to Radio register.
;                  Same as CYFISNP_WriteRaw(), except A and X are
;                  swapped because C calling convention makes it easier to set
;                  registers.
;
; Assembly Call:   A: Value to write to selected register.
;                  X: Register number to write, high 2 bits MUST be ZERO !
; -------------------
;
; CYFISNP_WriteRaw:      Write a single byte to an Radio register.
;
; 'C' Call:        void CYFISNP_WriteRaw(RADIO_REG_ADDR regAddr, BYTE value);
;
; Assembly Call:   A: Register number to write, high 2 bits MUST be ZERO !
;                  X: Value to write to the selected register.
;
; Assembly Return: A: lost
;                  X: lost
;             CUR_PP: Large Memory Model sets to RadioDriverRamPage
;
; Assumptions:
;    1. The global interrupt enable flag is cleared on entry.
;-----------------------------------------------------------------------------
 CYFISNP_WriteSwappedRaw::
        SWAP    A, X

 CYFISNP_WriteRaw::
_CYFISNP_WriteRaw::
        OR      A, CYFISNP_bSPI_WRITE           ; Set the Write Bit.

        ; Fall-thru to use RadioRead() to perform the Write

;-----------------------------------------------------------------------------
;
; CYFISNP_ReadRaw:       Read a single byte from an Radio register.
;
; 'C' Call:        BYTE CYFISNP_ReadRaw(RADIO_REG_ADDR regAddr);
;
; Assembly Call:   A: The register number to read
;                  X: READ=unused, fallthru from WRITE=Data
;
;                  (For both the 'C' and assembly call the top two bits of
;                   the register number MUST be clear.)
;
; Assembly Return: A: Value from register
;                  X: lost
;             CUR_PP: Large Memory Model sets to RadioDriverRamPage
;
; Assumptions:
;    1. The global interrupt enable flag is cleared on entry.
;    2. The SPI bus is idle on entry.
;-----------------------------------------------------------------------------
 CYFISNP_ReadRaw::
_CYFISNP_ReadRaw::
        RAM_SETPAGE_CUR >CYFISNP_DriverRamPage

        CYFISNP_RADIO_SELECT

        MOV     REG[CYFISNP_SPI_TX_REG], A      ; Write SPI address
        MOV     A, REG[CYFISNP_SPI_RX_REG]      ; Empty the SPI RX register


        ; Wait for the TX register to empty, and simultaneously clear the RX overrun flag.
        ; Reading the SPI RX register takes 6 CPU cycles.
        ; Reading the SPI status register with a MOV to clear the RX overrun flag takes 6 CPU cycles.
        ; Loading A with the contents of the data byte (in X) takes 4 CPU cycles.
        ; This totals 16 CPU cycles.
        ; If it takes the SPI block less than 16 CPU cycles to shift out 1.5 bits
        ; (less than 85 CPU cycles per byte), we can assume that the TX register
        ; will already be empty after these instructions execute and thereby skip the wait.
        ; Note: 1.5 bits is equal to 3 input clocks to the SPI block.  This gives a margin of safety
        ;    that the TX register is really empty.
IF (CPU_CYCLES_PER_SPI_BYTE / 85)
        CYFISNP_SPI_TX_EMPTY_WAIT
ELSE
        ; CYFISNP_SPI_TX_EMPTY_WAIT clears the RX overrun flag.  Do the same for fast SPI.
        MOV     A, REG[CYFISNP_SPI_CTRL_REG]
ENDIF

        MOV     A, X                                     ; Load A with the next byte to write
        MOV     REG[CYFISNP_SPI_TX_REG], A      ; Write SPI data
        CYFISNP_SPI_RX_OVERRUN_WAIT             ; Wait for SPI RX register to overrun


        ; When RX overrun goes true, there is an additional 1 SPI bit time before
        ; the SPI done bit goes true indicating that the transaction is over.
        ; The JZ instruction inside CYFISNP_SPI_RX_OVERRUN_WAIT
        ; provides a delay of 5 CPU cycles.  These 5 cycles provide a safety margin on
        ; top of software delays below.
IF (CPU_CYCLES_PER_SPI_BYTE / 128)
        ; 128 <= CPU cycles per SPI byte
        ;  16 <= CPU cycles per SPI bit
        ; The CPU is really fast compared to the SPI.
        ; Wait for the SPI Done bit to become true (this occurs 1 SPI bit clock after overrun)
.WaitSPIDone:
        TST     REG[CYFISNP_SPI_CTRL_REG], CYFISNP_SPI_DONE
        JZ      .WaitSPIDone
ELSE
  IF (CPU_CYCLES_PER_SPI_BYTE / 96)
        ; 96 <= CPU cycles per SPI byte < 128
        ; 12 <= CPU cycles per SPI bit < 16
        ; Delay an additional 16 CPU clock cycles to ensure the RX register is full.
        ; 16 + 5 = 21 total CPU cycles of delay.
        NOP
        NOP
        NOP
        NOP
  ENDIF
ENDIF


IF (CPU_CYCLES_PER_SPI_BYTE / 96)
ELSE
  IF (CPU_CYCLES_PER_SPI_BYTE / 64)
        ; 64 <= CPU cycles per SPI byte < 96
        ;  8 <= CPU cycles per SPI bit < 12
        ; Delay an additional 12 CPU clock cycles to ensure the RX register is full.
        ; 12 + 5 = 17 total CPU cycles of delay.
        NOP
        NOP
        NOP
  ENDIF
ENDIF


IF (CPU_CYCLES_PER_SPI_BYTE / 64)
ELSE
  IF (CPU_CYCLES_PER_SPI_BYTE / 32)
        ; 32 <= CPU cycles per SPI byte < 64
        ;  4 <= CPU cycles per SPI bit < 8
        ; Delay an additional 8 CPU clock cycles to ensure the RX register is full.
        ; 8 + 5 = 13 total CPU cycles of delay.
        NOP
        NOP
  ENDIF
ENDIF


IF (CPU_CYCLES_PER_SPI_BYTE / 32)
ELSE
  IF (CPU_CYCLES_PER_SPI_BYTE / 24)
        ; 24 <= CPU cycles per SPI byte < 32
        ;  3 <= CPU cycles per SPI bit < 4
        ; Delay an additional 4 CPU clock cycles to ensure the RX register is full.
        ; 4 + 5 = 9 total CPU cycles of delay.
        NOP
  ELSE
        ; CPU Cycles per SPI byte < 24
        ; CPU cycles per SPI bit < 3.5
        ; There is no need to provide additional delay to ensure the RX register is full.
        ; 0 + 5 = 5 total CPU cycles of delay.
  ENDIF
ENDIF

        MOV     A, REG[CYFISNP_SPI_RX_REG]      ; Get SPI Rx data
                                                         ; A = return value

        CYFISNP_RADIO_DESELECT

        RET
.endsection


.section
;-----------------------------------------------------------------------------
;
; CYFISNP_ReadStatusDebouncedRaw:
;                  Read a single byte from the RX_IRQ_STATUS_ADR register and
;                  debounce the update of the RXC and RXE bits. If only one of
;                  those two bits is set, read the register a second time and
;                  or them together. This second read happens in the same
;                  SPI transaction as a burst to the same address.
;
; 'C' Call:        BYTE CYFISNP_ReadStatusDebouncedRaw(RADIO_REG_ADDR regAddr);
;
; Assembly Call:   A: Register # to read
;                  X: none
;
; Assembly Return: A: Value from register
;                  X: Untouched
;             CUR_PP: Large Memory Model sets to RadioDriverRamPage
;
; Assumptions:
;    1. The global interrupt enable flag is cleared on entry.
;    2. The SPI bus is idle on entry.
;-----------------------------------------------------------------------------
 CYFISNP_ReadStatusDebouncedRaw::
_CYFISNP_ReadStatusDebouncedRaw::
        RAM_SETPAGE_CUR >CYFISNP_DriverRamPage

        CYFISNP_RADIO_SELECT

        MOV     REG[CYFISNP_SPI_TX_REG], A      ; Write SPI address.
        MOV     A, REG[CYFISNP_SPI_RX_REG]      ; Empty the SPI RX register

        ; Wait for the TX register to empty, and simultaneously clear the RX overrun flag.
        ; Reading the SPI RX register takes 6 CPU cycles.
        ; Reading the SPI status register with a MOV to clear the RX overrun flag takes 6 CPU cycles.
        ; This totals 12 CPU cycles.
        ; If it takes the SPI block less than 12 CPU cycles to shift out 1.5 bits
        ; (less than 64 CPU cycles per byte), we can assume that the TX register
        ; will already be empty after these instructions execute and thereby skip the wait.
        ; Note: 1.5 bits is equal to 3 input clocks to the SPI block.  This gives a margin of safety
        ;    that the TX register is really empty.
IF (CPU_CYCLES_PER_SPI_BYTE / 64)
        CYFISNP_SPI_TX_EMPTY_WAIT
ELSE
        ; CYFISNP_SPI_TX_EMPTY_WAIT clears the RX overrun flag.  Do the same for fast SPI.
        MOV     A, REG[CYFISNP_SPI_CTRL_REG]
ENDIF

        MOV     REG[CYFISNP_SPI_TX_REG], A      ; Write an arbitrary byte
        CYFISNP_SPI_RX_OVERRUN_WAIT

        ; When RX overrun goes true, there is an additional 1 SPI bit time before
        ; the SPI done bit goes true indicating that the transaction is over.
        ; The JZ instruction inside CYFISNP_SPI_RX_OVERRUN_WAIT
        ; provides a delay of 5 CPU cycles.  These 5 cycles provide a safety margin on
        ; top of software delays below.
IF (CPU_CYCLES_PER_SPI_BYTE / 128)
        ; 128 <= CPU cycles per SPI byte
        ;  16 <= CPU cycles per SPI bit
        ; The CPU is really fast compared to the SPI.
        ; Wait for the SPI Done bit to become true (this occurs 1 SPI bit clock after overrun)
.WaitSPIDone:
        TST     REG[CYFISNP_SPI_CTRL_REG], CYFISNP_SPI_DONE
        JZ      .WaitSPIDone
ELSE
  IF (CPU_CYCLES_PER_SPI_BYTE / 96)
        ; 96 <= CPU cycles per SPI byte < 128
        ; 12 <= CPU cycles per SPI bit < 16
        ; Delay an additional 16 CPU clock cycles to ensure the RX register is full.
        ; 16 + 5 = 21 total CPU cycles of delay.
        NOP
        NOP
        NOP
        NOP
  ENDIF
ENDIF


IF (CPU_CYCLES_PER_SPI_BYTE / 96)
ELSE
  IF (CPU_CYCLES_PER_SPI_BYTE / 64)
        ; 64 <= CPU cycles per SPI byte < 96
        ;  8 <= CPU cycles per SPI bit < 12
        ; Delay an additional 12 CPU clock cycles to ensure the RX register is full.
        ; 12 + 5 = 17 total CPU cycles of delay.
        NOP
        NOP
        NOP
  ENDIF
ENDIF


IF (CPU_CYCLES_PER_SPI_BYTE / 64)
ELSE
  IF (CPU_CYCLES_PER_SPI_BYTE / 32)
        ; 32 <= CPU cycles per SPI byte < 64
        ;  4 <= CPU cycles per SPI bit < 8
        ; Delay an additional 8 CPU clock cycles to ensure the RX register is full.
        ; 8 + 5 = 13 total CPU cycles of delay.
        NOP
        NOP
  ENDIF
ENDIF


IF (CPU_CYCLES_PER_SPI_BYTE / 32)
ELSE
  IF (CPU_CYCLES_PER_SPI_BYTE / 24)
        ; 24 <= CPU cycles per SPI byte < 32
        ;  3 <= CPU cycles per SPI bit < 4
        ; Delay an additional 4 CPU clock cycles to ensure the RX register is full.
        ; 4 + 5 = 9 total CPU cycles of delay.
        NOP
  ELSE
        ; CPU Cycles per SPI byte < 24
        ; CPU cycles per SPI bit < 3.5
        ; There is no need to provide additional delay to ensure the RX register is full.
        ; 0 + 5 = 5 total CPU cycles of delay.
  ENDIF
ENDIF

        ; If RXC and RXE (or TXC and TXE) bits match,
        ; then skip the debounce read
        MOV     A, REG[CYFISNP_SPI_RX_REG]      ; Get SPI Rx data
        MOV     [CYFISNP_SpiTemp], A
        AND     A, CYFISNP_RXC_IRQ | CYFISNP_RXE_IRQ
        JZ      .Done                   ; Both bits are ZERO
        CMP     A, CYFISNP_RXC_IRQ | CYFISNP_RXE_IRQ
        JZ      .Done                   ; Both bits are ONE

        ; The Complete and Error bits are different.
        ; Read again to ensure both bits have updated.
        MOV     REG[CYFISNP_SPI_TX_REG], A
        CYFISNP_SPI_RX_FULL_WAIT

        MOV     A, REG[CYFISNP_SPI_RX_REG]      ; Get SPI Rx data
        OR      [CYFISNP_SpiTemp], A

.Done:  MOV     A, [CYFISNP_SpiTemp]       ; Get the return value.

        CYFISNP_RADIO_DESELECT

        RET
.endsection


.section
;-----------------------------------------------------------------------------
;
; CYFISNP_BurstWriteWipRaw:
;                  Write sequence of bytes to sequence of Radio registers.
;                  Uses RadioWipPtr instead of RadioPtr as the data pointer.
;
; ---------------------
;
; CYFISNP_FileWriteWipRaw:
;                  Write sequence of bytes to singleRadio register.
;                  Uses RadioWipPtr instead of RadioPtr as the data pointer.
;
; ---------------------
;
; CYFISNP_BurstWriteRaw: Write sequence of bytes to sequence of Radio registers.
;
; 'C' Call:        void CYFISNP_BurstWriteRaw(BYTE regAddr, BYTE cnt);
;                  Must set RadioPtr via CYFISNP_SetPtr() before CYFISNP_BurstWriteRaw
;
; ---------------------
;
; CYFISNP_FileWriteRaw:  Write sequence of bytes to single Radio register.
;
; 'C' Call:        void CYFISNP_FileWriteRaw(LS_REG_ADDR regAddr, BYTE cnt);
;                  (Must set RadioPtr via CYFISNP_SetPtr() before CYFISNP_FileWriteRaw)
; ---------------------
;
; Assembly Call:   A: Register number to write, top two bits MUST be clear!
;                  X: Length of buffer.
;           RadioPtr: Address of buffer to write.
;
; Assembly Return: A: Undefined
;                  X: Undefined
;             CUR_PP: Large Memory Model sets to RadioDriverRamPage
;             MVR_PP: Large Memory Model sets to RadioWipPtr page
;
; Assumptions:
;    1. The global interrupt enable flag is cleared on entry.
;    2. The SPI bus is idle on entry.
;    3. Maximum write length is 16 bytes.
;-----------------------------------------------------------------------------
 CYFISNP_BurstWriteWipRaw::
        OR      A, CYFISNP_bSPI_AUTO_INC        ; Set increment flag
        JMP     CYFISNP_FileWriteWipRaw       ; Use existing WIP ptr/ctr

 CYFISNP_BurstWriteRaw::
_CYFISNP_BurstWriteRaw::
        OR      A, CYFISNP_bSPI_AUTO_INC        ; Set increment flag.
        ; Fall through to CYFISNP_FileWriteRaw

 CYFISNP_FileWriteRaw::
_CYFISNP_FileWriteRaw::
        RAM_SETPAGE_CUR >CYFISNP_DriverRamPage
  IF (SYSTEM_LARGE_MEMORY_MODEL)
        MOV     [CYFISNP_WipPtr+1], [CYFISNP_Ptr+1] ; Copy MSByte buffer pointer.
  ENDIF
        MOV     [CYFISNP_WipPtr+0], [CYFISNP_Ptr+0] ; Copy LSByte buffer pointer.
        ; Fall through to CYFISNP_FileWriteWipRaw

CYFISNP_FileWriteWipRaw::
        RAM_SETPAGE_CUR >CYFISNP_DriverRamPage

        DEC     X
        JC      .Done                                    ; If the length is zero do nothing at all.
        OR      A, CYFISNP_bSPI_WRITE           ; Set the write flag.

        CYFISNP_RADIO_SELECT

        MOV     REG[CYFISNP_SPI_TX_REG], A      ; Write the address


    IF (SYSTEM_LARGE_MEMORY_MODEL)
        MOV     A, [CYFISNP_WipPtr+1]           ; MSByte adr
        RAM_SETPAGE_MVR A               ; MVR operates on RadioWipPtr page
    ENDIF

.Burst:
        ; Pre-load A with the value to transfer
        MVI     A, [CYFISNP_WipPtr+0]           ; Get the data


        ; Wait for the TX register to empty.  The components of the .Burst loop
        ; for transferring data and tracking take 24 CPU cycles total.
IF (CPU_CYCLES_PER_SPI_BYTE / 37)
        ; 37 <=CPU cycles per byte.  Monitor the TX empty flag.
        CYFISNP_SPI_TX_EMPTY_WAIT
ELSE
  IF (CPU_CYCLES_PER_SPI_BYTE / 33)
        ; 33 <= CPU cycles per byte < 37.  Wait an additional 12 cycles
        ; 24 + 12 = 36 CPU clock cycles total loop time.
        NOP
        NOP
        NOP
  ENDIF
ENDIF


IF (CPU_CYCLES_PER_SPI_BYTE / 33)
ELSE
  IF (CPU_CYCLES_PER_SPI_BYTE / 29)
        ; 29 <= CPU cycles per byte < 33.  Wait an additional 8 cycles
        ; 24 + 8 = 32 CPU clock cycles total loop time.
        NOP
        NOP
  ENDIF
ENDIF


IF (CPU_CYCLES_PER_SPI_BYTE / 29)
ELSE
  IF (CPU_CYCLES_PER_SPI_BYTE / 25)
        ; 25 <= CPU cycles per byte < 29.  Wait an additional 4 cycles
        ; 24 + 4 = 28 CPU clock cycles total loop time.
        NOP
  ELSE
        ; CPU cycles per byte < 25.  Assume the TX register is already empty.
        ; 24 + 0 = 24 CPU clock cycles total loop time.
  ENDIF
ENDIF


        MOV     REG[CYFISNP_SPI_TX_REG], A          ; Write the next byte
        DEC     X                                            ; Update the number of bytes transferred
        JNC     .Burst                                       ; Continue the transfer if not done

        ; All done bursting, wait for last byte to leave the holding register
        CYFISNP_SPI_TX_EMPTY_WAIT               ; 14 cycles per iteration

        ; Wait for shifting to complete and the SPI transaction to finish.
        ; (1 SPI byte time minimum after the TX register empties)
        ; There are 5 cycles of delay guaranteed by the JZ instruction inside
        ; CYFISNPSPI_TX_EMPTY_WAIT before this section executes.
        ; CYFISNP_RADIO_DESELECT also provides 13 cycles of delay before
        ; deactivating the nSS.  Therefore, 18 cycles of delay are guaranteed.
IF (CPU_CYCLES_PER_SPI_BYTE / 34)
        ; The SPI is slow enough that the SPI_DONE bit can be monitored.
.L1:    TST     REG[CYFISNP_SPI_CTRL_REG],CYFISNP_SPI_DONE
        JZ      .L1
ELSE
  IF (CPU_CYCLES_PER_SPI_BYTE / 30)
        ; 30 <= CPU cycles per SPI byte < 34
        ; Delay for 20 additional clock cycles.
        ; 20 + 18 = 38 CPU cycles total delay
        NOP
        NOP
        NOP
        NOP
        NOP
  ENDIF
ENDIF


IF (CPU_CYCLES_PER_SPI_BYTE / 30)
ELSE
  IF (CPU_CYCLES_PER_SPI_BYTE / 26)
        ; 26 <= CPU cycles per SPI byte < 30
        ; The SPI is too fast for SPI_DONE monitoring.
        ; Delay for 16 additional clock cycles.
        ; 16 + 18 = 34 CPU cycles total delay
        NOP
        NOP
        NOP
        NOP
  ENDIF
ENDIF


IF (CPU_CYCLES_PER_SPI_BYTE / 26)
ELSE
  IF (CPU_CYCLES_PER_SPI_BYTE / 22)
        ; 22 <= CPU cycles per SPI byte < 26
        ; The SPI is too fast for SPI_DONE monitoring.
        ; Delay for 12 additional clock cycles.
        ; 12 + 18 = 30 CPU cycles total delay
        NOP
        NOP
        NOP
  ENDIF
ENDIF


IF (CPU_CYCLES_PER_SPI_BYTE / 22)
ELSE
  IF (CPU_CYCLES_PER_SPI_BYTE / 18)
        ; 18 <= CPU cycles per SPI byte < 22
        ; SPI is too fast for SPI_DONE monitoring.
        ; Delay for 8 additional clock cycles.
        ; 8 + 18 = 26 CPU cycles total delay
        NOP
        NOP
  ENDIF
ENDIF


IF (CPU_CYCLES_PER_SPI_BYTE / 18)
ELSE
  IF (CPU_CYCLES_PER_SPI_BYTE / 14)
        ; 14 <= CPU cycles per SPI byte < 18
        ; SPI is too fast for SPI_DONE monitoring.
        ; Delay for 4 additional clock cycles.
        ; 4 + 18 = 22 CPU cycles total delay
        NOP
  ELSE
        ; CPU cycles per SPI byte < 14
        ; SPI is too fast for SPI_DONE monitoring.
        ; No additional delay required.
        ; 0 + 18 = 18 CPU cycles total delay
  ENDIF
ENDIF


        CYFISNP_RADIO_DESELECT
.Done:

        RET
.endsection

.section
;-----------------------------------------------------------------------------
;
; CYFISNP_BurstReadWipRaw:
;                  Read a sequence of bytes from a sequence of Radio registers
;                  using RadioWipPtr as the buffer pointer.
;
; Assembly Call:   RadioWipPtr: Address of buffer to read.
;                  A: The register number to write.
;                     (Top two bits MUST be clear.)
;                  X: Length of the buffer.
;
; Assembly Return: A: Undefined
;                  X: Undefined
;
; Assumptions:
;    1. The global interrupt enable flag is cleared on entry.
;    2. The SPI bus is idle on entry.
;-----------------------------------------------------------------------------
 CYFISNP_BurstReadWipRaw::
        OR      A, CYFISNP_bSPI_AUTO_INC        ; Set the increment flag.
        JMP     CYFISNP_FileReadWipRaw

.endsection

.section
;-----------------------------------------------------------------------------
;
; CYFISNP_BurstReadRaw:  Read a sequence of bytes from a sequence of
;                  Radio registers
;
; 'C' Call:        void CYFISNP_BurstReadRaw(unsigned char cnt);
;                  Must set RadioPtr via CYFISNP_SetPtr() before
;                  CYFISNP_BurstReadRaw.
;
; See CYFISNP_FileReadRaw() for entry/exit parameters
;
; Assumptions:
;    1. The global interrupt enable flag is cleared on entry.
;    2. The SPI bus is idle on entry.
;-----------------------------------------------------------------------------
 CYFISNP_BurstReadRaw::
_CYFISNP_BurstReadRaw::
        OR      A,CYFISNP_bSPI_AUTO_INC         ; Set the increment flag.
        ; Fall through to CYFISNP_FileReadRaw

;-----------------------------------------------------------------------------
;
; CYFISNP_FileReadRaw:   Read a sequence of bytes from a single Radio registers.
;
;                      time->           |8spiclk|8spiclk|8spiclk|
;                  Assert Slave Select  |       |       |       |
;                  Write Address        |       |       |       |
;                  Wait for Empty(1)----+       |       |       |
;                  Write Nul Data               |       |       |
;                  Wait for Empty(2)------------+       |       |
;                  Write Nul Data                       |       |
;                  Read Nul Data                        |       |
;                  Wait for Empty(3)--------------------+       |
;                  Write Nul Data                               |
;                  Read Data                                    |
;                  Wait for Empty and complete------------------+
;                  Read Data
;                  De-assert Slave Select
;
;                  The main loop of this routine is a littler slower than it
;                  should be. With a 12MHz CPU the burst is not always
;                  continuous. There are occasional gaps between bytes in the
;                  burst. It should be possible to correct this, but it's a
;                  minor problem and this is already pretty convoluted to deal
;                  with the latency caused by the TX and RX holding buffers.
;
;                  Properly handles all length cases, including zero and one.
;
; 'C' Call:        (Must set RadioPtr and RadioLen by calling RadioSetPtr
;                  prior to CYFISNP_FileReadRaw.)
;                  void CYFISNP_FileReadRaw(BYTE regAddr, BYTE cnt);
;
; Assembly Call:   A: The register number to write, top 2 bits MUST be clear!
;                  X: Length of the buffer.
;           RadioPtr: Address of buffer to read.
;           RadioLen: Size of buffer
;
; Assembly Return: A: Undefined
;                  X: Undefined
;             CUR_PP: Large Memory Model sets to RadioDriverRamPage
;             STK_PP: Large Memory Model sets to SYSTEM_STACK_PAGE
;
; Assumptions:
;    1. The global interrupt enable flag is cleared on entry.
;    2. The SPI bus is idle on entry.
;-----------------------------------------------------------------------------
 CYFISNP_FileReadRaw::
_CYFISNP_FileReadRaw::
        RAM_SETPAGE_CUR >CYFISNP_DriverRamPage
  IF (SYSTEM_LARGE_MEMORY_MODEL)
        MOV     [CYFISNP_WipPtr+1], [CYFISNP_Ptr+1] ; LMM: MSB working pointer
  ENDIF
        MOV     [CYFISNP_WipPtr+0], [CYFISNP_Ptr+0] ; Initialize working pointer


        ;---------------------------------------------------------------------
        ; RadioWipLen = Remaining space in RAM buffer.  Streaming driver moves
        ;               8 Byte chunks, needs to remember how much physical
        ;               space remains after each 8-byte chunk in loaded.
        ;---------------------------------------------------------------------
        MOV     [CYFISNP_WipLen], [CYFISNP_Len]     ;  and length.
        ; Fall through to CYFISNP_FileReadWipRaw


;-----------------------------------------------------------------------------
; CYFISNP_FileReadWipRaw - Streaming driver is primary caller when
;                    moving 8-byte chunks during a multi-chunk reception.
;
; Assumptions:
;    1. The global interrupt enable flag is cleared on entry.
;    2. The SPI bus is idle on entry.
;-----------------------------------------------------------------------------
CYFISNP_FileReadWipRaw::
        RAM_SETPAGE_CUR >CYFISNP_DriverRamPage

        DEC     X                       ; Check for zero length case.
        JC      .exit0                  ; If zero, nothing to do.


        ;---------------------------------------------------
        ; Here, X = number of bytes in the file read - 1.
        ;---------------------------------------------------

        CYFISNP_RADIO_SELECT

        MOV     REG[CYFISNP_SPI_TX_REG], A      ; Write SPI address.
        MOV     A, REG[CYFISNP_SPI_RX_REG]      ; Empty the SPI RX register

        ; --------------------------------------------------------------------
        ; Using the SP as a write data pointer is 6-cycles faster than MVI.
        ;       (Since GIE is already disabled, using SP is safe).
        ; --------------------------------------------------------------------
        SWAP    A, SP
        SWAP    A, [CYFISNP_WipPtr+0]      ; LSByte of pointer
        SWAP    A, SP                   ; SP = RadioWipPtr
IF (SYSTEM_LARGE_MEMORY_MODEL)
        MOV     A, [CYFISNP_WipPtr+1]      ; MSByte of pointer (page #)
        MOV     REG[STK_PP], A
ENDIF


        ; Wait for the TX register to empty.  The four instructions after the write of the SPI address
        ; take 23 CPU cycles total to execute.  If it takes the SPI block less than 23 CPU cycles to
        ; shift out 1.5 bits (less than 122 CPU cycles per byte), we can assume that the TX register
        ; is already empty and thereby skip the wait.
        ; Secondly, we need to ensure that the RX overrun flag is clear if we are using it to
        ; determine when the first data byte is ready to fetch from the RX register.
        ; Note 1: 1.5 bits is equal to 3 input clocks to the SPI block.  This gives a margin of safety
        ;    that the TX register is really empty.
        ; Note 2: The large memory model instructions are ignored in this analysis.  This ignorance is
        ;    safe as these instructions merely add some more delay.
IF (CPU_CYCLES_PER_SPI_BYTE / 122)
        CYFISNP_SPI_TX_EMPTY_WAIT
ELSE
  IF (CPU_CYCLES_PER_SPI_BYTE / 50)
        ; 50 <= CPU cycles per SPI byte < 122
        ; CYFISNP_SPI_TX_EMPTY_WAIT automatically clears the RX overrun flag.
        ; Do the same here for faster SPI operation that relies on the RX overrun flag to
        ; determine when the RX register contains the first data byte.
        MOV     A, REG[CYFISNP_SPI_CTRL_REG]
  ENDIF
ENDIF



        MOV     REG[CYFISNP_SPI_TX_REG], A      ; Write null data.


        ;---------------------------------------------------------------------------
        ; At this point the following data is needed to determine whether all data
        ; can be saved, or if some data must be discarded.
        ;
        ; Number of bytes to retrieve  = X + 1
        ; Available user buffer size   = [CYFISNP_WipLen]
        ;
        ; When the calculations complete the following data will result.
        ;
        ; If no bytes will be discarded:
        ; Number of bytes to save            = X + 1
        ; Number of bytes to discard         = [CYFISNP_SpiTemp] = 0
        ; Available user buffer size on exit = [CYFISNP_WipLen] - 1
        ;     Note: This will be corrected by decrementing at exit.
        ;
        ; If some bytes will be discarded:
        ; Number of bytes to save            = X = initial value of [@INSTANCE_NAME_WipLen]
        ; Number of bytes to discard         = [CYFISNP_SpiTemp] + 1
        ; Available user buffer size on exit = [CYFISNP_WipLen] = 0
        ;---------------------------------------------------------------------------
        MOV     A, X
        SUB     A, [CYFISNP_WipLen]        ; CRY = 1 if user's buffer has enough space
        JNC     .tooMuch

        ;----------------------------------------
        ; Receive data size fits in remaining UserBuf.
        ;----------------------------------------
        ; Set [@INSTANCE_NAME_SpiTemp] to 0
        MOV     [CYFISNP_SpiTemp], 0
        MOV     A, X

        ;---------------------------------------------------------------------------
        ; Set [CYFISNP_WipLen] to one byte more than the space available
        ; at exit.  A correction will be made at exit.  See the comment in .tooMuch
        ; to understand why.
        ;---------------------------------------------------------------------------
        SUB     [CYFISNP_WipLen], A        ; Decrease UserBuf for EXIT

        JMP     .WaitFirstDataByte

        ;----------------------------------------
        ; Receive data size is too big for remaining UserBuf.
        ;----------------------------------------
.tooMuch:
        ; Set [CYFISNP_SpiTemp] to the number of bytes to discard - 1
        MOV     [CYFISNP_SpiTemp], A

        ; Set X to the size of the available user buffer space
        MOV     X, [CYFISNP_WipLen]

        ;----------------------------------------------------------------------------
        ; Setting [CYFISNP_WipLen] to 0 does two things.  First, it serves
        ; as an indicator at exit that the user buffer is full.  Second, before exit,
        ; it serves as an indicator that the last byte of the transfer will be
        ; discarded.
        ;----------------------------------------------------------------------------
        MOV     [CYFISNP_WipLen], 0


.WaitFirstDataByte:
        ; Wait for the RX buffer to fill with the 1st data byte
        ; 62 cycles minimum after writing the address byte to get here
        ; 34 cycles minimum after writing the first data byte to get here
        ; 19 cycles in the save loop entry. (81/53 cycles total)
        ; Note: There are 28 cycles between the write of the address byte and the
        ;   the write of the first data byte.  For a SPI byte that takes less
        ;   than 28 CPU cycles to transfer, reference to the write of the first
        ;   data byte would be required.  However, the minimum delay after writing
        ;   the first data byte is 53 cycles.  Therefore, no wait is required for these,
        ;   and all other speeds can be referenced to the write of the first byte.
IF (CPU_CYCLES_PER_SPI_BYTE / 50)
        ; 50 <= CPU cycles per byte.  100 <= CPU cycles for 2 bytes
        ; Wait for RX overrun.  This precedes the availability of the received
        ; byte in the RX register by 1 SPI bit time.  The 5 cycles in the JZ instruction inside
        ; CYFISNP_SPI_RX_OVERRUN_WAIT plus the 19 cycles in the save
        ; loop entry allow 24 CPU cycles total time for the byte to become available.
        ; (equivalent to 192 CPU cycles per SPI bit
        CYFISNP_SPI_RX_OVERRUN_WAIT

        ; For really slow SPI, check for the SPI done bit before continuing
  IF (CPU_CYCLES_PER_SPI_BYTE / 188)
.WaitFirstSPIDone:
        TST     REG[CYFISNP_SPI_CTRL_REG], CYFISNP_SPI_DONE ;
        JZ      .WaitFirstSPIDone
  ENDIF
ELSE
  IF (CPU_CYCLES_PER_SPI_BYTE / 48)
        ; 48 <= CPU cycles per byte < 50.
        ; 96 <= CPU cycles for 2 bytes < 100
        ; Wait an additional 20 cycles
        ; 81 + 20 = 101 CPU clock cycles total from address byte write to RX register retrieval.
        NOP
        NOP
        NOP
        NOP
  ENDIF
ENDIF


IF (CPU_CYCLES_PER_SPI_BYTE / 48)
ELSE
  IF (CPU_CYCLES_PER_SPI_BYTE / 46)
        ; 44 <= CPU cycles per byte < 46.
        ; 92 <= CPU cycles for 2 bytes < 96
        ; Wait an additional 16 cycles
        ; 81 + 16 = 97 CPU clock cycles total from address byte write to RX register retrieval.
        NOP
        NOP
        NOP
        NOP
  ENDIF
ENDIF


IF (CPU_CYCLES_PER_SPI_BYTE / 46)
ELSE
  IF (CPU_CYCLES_PER_SPI_BYTE / 44)
        ; 44 <= CPU cycles per byte < 46.
        ; 88 <= CPU cycles for 2 bytes < 92
        ; Wait an additional 12 cycles
        ; 81 + 12 = 93 CPU clock cycles total from address byte write to RX register retrieval.
        NOP
        NOP
        NOP
  ENDIF
ENDIF


IF (CPU_CYCLES_PER_SPI_BYTE / 44)
ELSE
  IF (CPU_CYCLES_PER_SPI_BYTE / 42)
        ; 42 <= CPU cycles per byte < 44.
        ; 84 <= CPU cycles for 2 bytes < 88
        ; Wait an additional 8 cycles
        ; 81 + 8 = 89 CPU clock cycles total from address byte write to RX register retrieval.
        NOP
        NOP
  ENDIF
ENDIF


IF (CPU_CYCLES_PER_SPI_BYTE / 42)
ELSE
  IF (CPU_CYCLES_PER_SPI_BYTE / 40)
        ; 40 <= CPU cycles per byte < 42.
        ; 80 <= CPU cycles for 2 bytes < 84
        ; Wait an additional 4 cycles
        ; 81 + 4 = 85 CPU clock cycles total from address byte write to RX register retrieval.
        NOP
  ELSE
        ; CPU cycles per byte < 40.
        ; CPU cycles for 2 bytes < 80 CPU cycles.
        ; No additional waiting required.
        ; 81 + 0 = 81 CPU clock cycles total from address byte write to RX register retrieval.
  ENDIF
ENDIF


.Save:
        jmp     .SaveLoopEntry


        ; ----------------------------------------
        ; Loop for copying received byte to user's Buffer
        ; ----------------------------------------
.SaveLoop:
        MOV     REG[CYFISNP_SPI_TX_REG], A         ; Write null data.
        MOV     A, REG[CYFISNP_SPI_RX_REG]         ; Get SPI Rx data
        PUSH    A                                           ; Save data in buffer, not real stack

        ;----------------------------------------------------------------------------------------
        ; The top of .SaveLoop is 15 cycles long.  The bottom (.SaveLoopEntry) is 9 cycles long.
        ; Delay long enough to allow the byte shifting in to be completely received
        ; by the time the MOV REG[CYFISNP_SPI_TX_REG], A instruction completes.
        ;----------------------------------------------------------------------------------------

IF (CPU_CYCLES_PER_SPI_BYTE / 128)
        ; 128 <= CPU cycles per SPI byte
        ; This is a slow SPI clock.  Just monitor the RX full flag.
        CYFISNP_SPI_RX_FULL_WAIT
ELSE
  IF (CPU_CYCLES_PER_SPI_BYTE / 44)
        ; 44 <= CPU cycles per SPI byte < 128
        ; This is a relatively slow SPI clock.  The CYFISNP_RX_FULL_WAIT macro
        ; is 14 CPU cycles long.  This delay loop has a 9 cycle iteration time so as to
        ; provide a little less waste of time.  In addition, it accounts for delays incurred
        ; by the other instructions in the loop.  Set the number of iterations to delay
        ; According to the number of CPU cycles that execute in transferring a single byte.
        ; The factor +4 in the calculation of A is a safety factor to ensure a byte is in
        ; the RX register.
    IF ((CPU_CYCLES_PER_SPI_BYTE - 24 + 4 - 4) % 9)
        MOV     A, (CPU_CYCLES_PER_SPI_BYTE - 24 + 4 - 4) / 9 + 1   ; 4 cycles
    ELSE
        MOV     A, (CPU_CYCLES_PER_SPI_BYTE - 24 + 4 - 4) / 9       ; 4 cycles
    ENDIF

.SaveLoopDelay1:
        DEC     A                                                   ; 4 cycles
        JNZ     .SaveLoopDelay1                                     ; 5 cycles
                                                                    ;---------
                                                                    ; 4 + 9 * A total CPU clock cycles of delay
  ENDIF
ENDIF


IF (CPU_CYCLES_PER_SPI_BYTE / 44)
ELSE
  IF (CPU_CYCLES_PER_SPI_BYTE / 40)
        ; 40 <= CPU cycles per SPI byte < 44
        ; Delay for 20 CPU clock cycles to ensure that the RX buffer is full
        ; when it is retrieved.
        ; 20 + 15 + 9 = 44 total CPU clock cycles per loop iteration.
        NOP
        NOP
        NOP
        NOP
        NOP
  ENDIF
ENDIF


IF (CPU_CYCLES_PER_SPI_BYTE / 40)
ELSE
  IF (CPU_CYCLES_PER_SPI_BYTE / 36)
        ; 36 <= CPU cycles per SPI byte < 40
        ; Delay for 16 CPU clock cycles to ensure that the RX buffer is full
        ; when it is retrieved.
        ; 16 + 15 + 9 = 40 total CPU clock cycles per loop iteration.
        NOP
        NOP
        NOP
        NOP
  ENDIF
ENDIF


IF (CPU_CYCLES_PER_SPI_BYTE / 36)
ELSE
  IF (CPU_CYCLES_PER_SPI_BYTE / 32)
        ; 32 <= CPU cycles per SPI byte < 36
        ; Delay for 12 CPU clock cycles to ensure that the RX buffer is full
        ; when it is retrieved.
        ; 12 + 15 + 9 = 36 total CPU clock cycles per loop iteration.
        NOP
        NOP
        NOP
  ENDIF
ENDIF


IF (CPU_CYCLES_PER_SPI_BYTE / 32)
ELSE
  IF (CPU_CYCLES_PER_SPI_BYTE / 28)
        ; 28 <= CPU cycles per SPI byte < 32
        ; Delay for 8 CPU clock cycles to ensure that the RX buffer is full
        ; when it is retrieved.
        ; 8 + 15 + 9 = 32 total CPU clock cycles per loop iteration.
        NOP
        NOP
  ENDIF
ENDIF


IF (CPU_CYCLES_PER_SPI_BYTE / 28)
ELSE
  IF (CPU_CYCLES_PER_SPI_BYTE / 24)
        ; 24 <= CPU cycles per SPI byte < 28
        ; Delay for 4 clock cycles to ensure that the RX buffer is full
        ; when it is retrieved.
        ; 4 + 15 + 9 = 28 total CPU clock cycles per loop iteration.
        NOP
  ELSE
        ; CPU cycles per SPI byte < 24
        ; The loop instructions below provide enough delay
        ; to ensure that the RX register is full when it is retrieved.
        ; No additional delay is necessary.
        ; 0 + 15 + 9 = 24 total CPU clock cycles per loop iteration.
  ENDIF
ENDIF


.SaveLoopEntry:
        ; Determine if the loop is done
        DEC     X                                           ; Update the number of bytes to left to retrieve
        JNC     .SaveLoop                                   ; Continue the data retrieval loop if not done retrieving data




.Discard:
        ; --------------------------------------------------------------------
        ; RadioSpiTmp = number of remaining bytes to read and discard.
        ; --------------------------------------------------------------------
        MOV     X, [CYFISNP_SpiTemp]
        JMP     .DiscardLoopEntry

.DiscardLoop:
        MOV     REG[CYFISNP_SPI_TX_REG], A       ; Start shifting in another byte
        MOV     A, REG[CYFISNP_SPI_RX_REG]       ; Empty the SPI RX register


        ;----------------------------------------------------------------------------------------
        ; The top of .DiscardLoop is 11 cycles long.  The bottom (.DiscardLoopEntry) is 9 cycles
        ; long.  Delay long enough to allow the byte shifting in to be completely received
        ; by the time the MOV REG[CYFISNP_SPI_TX_REG], A instruction completes.
        ;----------------------------------------------------------------------------------------

IF (CPU_CYCLES_PER_SPI_BYTE / 128)
        ; 128 <= CPU cycles per SPI byte
        ; This is a really slow SPI clock.  Just monitor the RX full flag.
        CYFISNP_SPI_RX_FULL_WAIT
ELSE
  IF (CPU_CYCLES_PER_SPI_BYTE / 40)
        ; 40 <= CPU cycles per SPI byte < 128
        ; This is a relatively slow SPI clock.  The CYFISNP_RX_FULL_WAIT macro
        ; is 14 CPU cycles long.  This delay loop has a 9 cycle iteration time so as to
        ; provide a little less waste of time.  In addition, it accounts for delays incurred
        ; by the other instructions in the loop.  Set the number of iterations to delay
        ; According to the number of CPU cycles that execute in transferring a single byte.
        ; The factor +4 in the calculation of A is a safety factor to ensure a byte is in
        ; the RX register.
    IF ((CPU_CYCLES_PER_SPI_BYTE - 20 + 4 - 4) % 9)
        MOV     A, (CPU_CYCLES_PER_SPI_BYTE - 20 + 4 - 4) / 9 + 1
    ELSE
        MOV     A, (CPU_CYCLES_PER_SPI_BYTE - 20 + 4 - 4) / 9       ; 4 cycles
    ENDIF

.DiscardLoopDelay1:
        DEC     A                                     ; 4 cycles
        JNZ     .DiscardLoopDelay1                    ; 5 cycles
                                                      ;---------
                                                      ; 4 + 9 * A iterations
  ENDIF
ENDIF


IF (CPU_CYCLES_PER_SPI_BYTE / 40)
ELSE
  IF (CPU_CYCLES_PER_SPI_BYTE / 36)
        ; 36 <= CPU cycles per SPI byte < 40
        ; Delay for 20 CPU clock cycles to ensure that the RX buffer is full
        ; when it is retrieved.
        ; 20 + 11 + 9 = 40 total CPU clock cycles per loop iteration.
        NOP
        NOP
        NOP
        NOP
        NOP
  ENDIF
ENDIF


IF (CPU_CYCLES_PER_SPI_BYTE / 36)
ELSE
  IF (CPU_CYCLES_PER_SPI_BYTE / 32)
        ; 32 <= CPU cycles per SPI byte < 36
        ; Delay for 16 CPU clock cycles to ensure that the RX buffer is full
        ; when it is retrieved.
        ; 16 + 11 + 9 = 36 total CPU clock cycles per loop iteration.
        NOP
        NOP
        NOP
        NOP
  ENDIF
ENDIF


IF (CPU_CYCLES_PER_SPI_BYTE / 32)
ELSE
  IF (CPU_CYCLES_PER_SPI_BYTE / 28)
        ; 28 <= CPU cycles per SPI byte < 32
        ; Delay for 12 CPU clock cycles to ensure that the RX buffer is full
        ; when it is retrieved.
        ; 12 + 11 + 9 = 32 total CPU clock cycles per loop iteration.
        NOP
        NOP
        NOP
  ENDIF
ENDIF


IF (CPU_CYCLES_PER_SPI_BYTE / 28)
ELSE
  IF (CPU_CYCLES_PER_SPI_BYTE / 24)
        ; 24 <= CPU cycles per SPI byte < 28
        ; Delay for 8 CPU clock cycles to ensure that the RX buffer is full
        ; when it is retrieved.
        ; 8 + 11 + 9 = 28 total CPU clock cycles per loop iteration.
        NOP
        NOP
  ENDIF
ENDIF


IF (CPU_CYCLES_PER_SPI_BYTE / 24)
ELSE
  IF (CPU_CYCLES_PER_SPI_BYTE / 20)
        ; 20 <= CPU cycles per SPI byte < 24
        ; Delay for 4 CPU clock cycles to ensure that the RX buffer is full
        ; when it is retrieved.
        ; 4 + 11 + 9 = 24 total CPU clock cycles per loop iteration.
        NOP
  ELSE
        ; CPU cycles per SPI byte < 20
        ; The loop instructions below provide enough delay
        ; to ensure that the RX register is full when it is retrieved.
        ; No additional delay is necessary.
        ; Delay for 20 CPU clock cycles to ensure that the RX buffer is full
        ; when it is retrieved.
        ; 0 + 11 + 9 = 20 total CPU clock cycles per loop iteration.
  ENDIF
ENDIF


.DiscardLoopEntry:
        DEC     X                                         ; Update the number of bytes to discard
        JNC     .DiscardLoop                              ; Continue the discard loop if not done discarding
.DiscardLoopDone:



        ; --------------------------------------------------------------------
        ; Moved all data except for one last byte. Wait for it and if
        ;  we have room in the buffer, get it and store it.
        ; --------------------------------------------------------------------
.LastByte:
        ; By the time this point is reached, the last byte is in the SPI RX register
        ; If this byte is to be discarded, it can be left in the RX register as any
        ; further SPI subroutine call will do cleanup before starting.
        CMP     [CYFISNP_WipLen], 0             ; Determine if the byte is to be discarded or saved.
        JZ      .exit1

        ; The byte is to be saved
        MOV     A, REG[CYFISNP_SPI_RX_REG]          ; Get SPI RX data
        PUSH    A                                        ; Save data in buffer, not real stack
        DEC     [CYFISNP_WipLen]                ; Correct the size of the unfilled user buffer space

.exit1:
        ; Restore SP to point at the stack
        SWAP    A, SP
        SWAP    A, [CYFISNP_WipPtr]
        SWAP    A, SP
  IF (SYSTEM_LARGE_MEMORY_MODEL)
        MOV     REG[STK_PP], SYSTEM_STACK_PAGE
  ENDIF
        CYFISNP_RADIO_DESELECT

.exit0:
        RET
.endsection


IF (CYFISNP_SPIM_API_EXPOSED)

.SECTION
;-----------------------------------------------------------------------------
;  FUNCTION NAME: CYFISNP_SendTxData
;
;  DESCRIPTION:
;     Initiates an SPI data transfer.
;
;-----------------------------------------------------------------------------
 CYFISNP_SendTxData::
_CYFISNP_SendTxData::
   RAM_PROLOGUE RAM_USE_CLASS_1
   mov REG[CYFISNP_SPI_TX_REG], A
   RAM_EPILOGUE RAM_USE_CLASS_1
   ret

.ENDSECTION

.SECTION
;-----------------------------------------------------------------------------
;  FUNCTION NAME: CYFISNP_bReadRxData
;
;  DESCRIPTION:
;     Reads the RX buffer register.  Should check the status regiser to make
;     sure data is valid.
;
;-----------------------------------------------------------------------------
 CYFISNP_bReadRxData::
_CYFISNP_bReadRxData::
 bCYFISNP_ReadRxData::
_bCYFISNP_ReadRxData::
   RAM_PROLOGUE RAM_USE_CLASS_1
   mov A, REG[CYFISNP_SPI_RX_REG]
   RAM_EPILOGUE RAM_USE_CLASS_1
   ret


.ENDSECTION

.SECTION
;-----------------------------------------------------------------------------
;  FUNCTION NAME: CYFISNP_ReadStatus
;
;  DESCRIPTION:
;     Reads the SPIM Status bits in the Control/Status register.
;
;-----------------------------------------------------------------------------
 CYFISNP_bReadStatus::
_CYFISNP_bReadStatus::
 bCYFISNP_ReadStatus::
_bCYFISNP_ReadStatus::
   RAM_PROLOGUE RAM_USE_CLASS_1
   mov A,  REG[CYFISNP_SPI_CTRL_REG]
   RAM_EPILOGUE RAM_USE_CLASS_1
   ret

.ENDSECTION

ENDIF

        Resume_CodeCompressor

; ############################################################################
; END OF CYFISPI_PSoC_SPIm.asm
; ############################################################################
