//*****************************************************************************
//*****************************************************************************
//  FILENAME: CYFISNP_Protocol.c
//  Version: 2.00, Updated on 2015/3/4 at 22:21:19
//  Generated by PSoC Designer 5.4.3191
//
//  DESCRIPTION: <NODE> Star Network Protocol Protocol implementation
//-----------------------------------------------------------------------------
//  Copyright (c) Cypress Semiconductor 2015. All Rights Reserved.
//*****************************************************************************
//*****************************************************************************

#define CYFISNP_PROTOCOL_C

#include <m8c.h>        // part specific constants and macros
#include <FlashBlock.h>
#include "PSoCAPI.h"    // PSoC API definitions for all User Modules
#include "psocGpioInt.h"
#include "CYFISNP.h"

#define NO_RX_PACKET    CYFISNP_ABORT_SUCCESS     // Better name

#define CYFISNP_nSS_IS_PPSOC_FN (0x18 > 100)

// ---------------------------------------------------------------------------
// Calculate the battery powered node's "Response Delay" (dominated by CPU_CLK)
//  This is passed in the BindRequest so the can delay Responses as needed.
//  RULE: HUB IS NEVER SLOWER THAN THE NODE (the node is presumed battery
//        powered and establishes the response time that the hub must meet,
//        it's not negotiated).
// ---------------------------------------------------------------------------
#if   (CYFISNP_CPU_CLK == 24)
    #define SNP_RSP_DELAY   (160/10)    // 160 uS
#elif (CYFISNP_CPU_CLK == 12)
    #define SNP_RSP_DELAY   (280/10)    // 280 uS
#elif (CYFISNP_CPU_CLK == 6)
    #define SNP_RSP_DELAY   (450/10)    // 450 uS
#elif (CYFISNP_CPU_CLK == 3)
    #define SNP_RSP_DELAY   (830/10)    // 830 uS
#else
    // ERROR - CPU CLOCK TOO SLOW FOR CYFISNP
    // DRC should generate this warning
    #define SNP_RSP_DELAY (830/10)    // Dirty workaround to allow compilation with default parameters
#endif

//#define TEST_DISABLE_DYNAMIC_PA       // (testing only)


// ---------------------------------------------------------------------------
// SNP PACKET HEADERS
// ---------------------------------------------------------------------------
#define PKT_PING_TYPE       0x00
#define PKT_PING_LEN        2       // Protocol + DevID

#define PKT_BINDREQ_TYPE    0x00
#define PKT_BINDREQ_LEN     7

#define PKT_BINDRSP_TYPE    0x10
#define PKT_BINDRSP_LEN     10

#define PKT_CONREQ_TYPE    0x00
#define PKT_CONREQ_LEN     6

#define PKT_CONRSP_TYPE    0x10
#define PKT_CONRSP_LEN     6

#define PKT_UNBIND_TYPE     0x10
#define PKT_UNBIND_LEN      2

#define PKT_SEQBIT_MASK     0x03
#define PKT_SEQSYNC         0x02
#define PKT_DATA_FCD_TYPE   0x20
#define PKT_DATA_BCD_TYPE   0x30
#define PKT_BCDR_MASK       0x04


// ---------------------------------------------------------------------------
//
// PUBLIC VARIABLES
//
// ---------------------------------------------------------------------------
CYFISNP_PROT_STATE  CYFISNP_eProtState;

BYTE CYFISNP_bCurrentChannel;


// ---------------------------------------------------------------------------
// CYFISNP_txBuf - Holds Tx Packets, ONLY for Private Protocol use
// ---------------------------------------------------------------------------
#define SNP_PROT_PKT_TX_MAX 7                   // Largest Tx Protocol Packet
#define SNP_PROT_PKT_RX_MAX 10                  // Largest Rx Protocol Packet
static BYTE SNP_txBuf[SNP_PROT_PKT_TX_MAX];

// ---------------------------------------------------------------------------
// PHYSICAL_BCD_PACKET_MAX = biggest physical BCD buffer required.
// ---------------------------------------------------------------------------
#if CYFISNP_BCD_PAYLOAD_MAX >= SNP_PROT_PKT_RX_MAX
#define PHYSICAL_BCD_PACKET_MAX     (CYFISNP_BCD_PAYLOAD_MAX + 1)
#else
#define PHYSICAL_BCD_PACKET_MAX     SNP_PROT_PKT_RX_MAX
#endif

// ---------------------------------------------------------------------------
// RX_PKT - Holds Rx Packets, shared between API and Private Protocol use
// ---------------------------------------------------------------------------
typedef union {
    struct {            // Structure passed to API
        BYTE length;
        BYTE rssi;
        BYTE type;
        BYTE devId;
        BYTE payload[CYFISNP_BCD_PAYLOAD_MAX]; // Holds Rx API pkt
    } api;
    struct {            // Structure passed from Radio
        BYTE length;
        BYTE rssi;
        BYTE devId;
        BYTE pkt[SNP_PROT_PKT_RX_MAX];      // Holds Rx protocol packet
    } snp;
} SNP_RX_PKT;
static SNP_RX_PKT  SNP_rxBuf;


// ---------------------------------------------------------------------------
//
// Dynamic DataRate and Dynamic PA
//
// ---------------------------------------------------------------------------


BYTE CYFISNP_radioTxConfig;        // [4:3] = GFSK or 8DR
// GFSK_INUSE - macro to check whether GFSK is currently specified
#define GFSK_INUSE ((CYFISNP_radioTxConfig   \
                   & CYFISNP_TX_DATMODE_MSK) \
                  == CYFISNP_DATMODE_1MBPS)
// --------------------------
BYTE CYFISNP_paLevel;              // logical PA level
#define PA_LEVEL_MAX 7
#define PA_LEVEL_MIN 0


// -----------------------------------------------------------------------
// GFSK (dpwrQualGfsk) and 8DR (dpwrQual8dr) channel quality metrics.
//   these are driven by each transmission AutoAck success or failure.
// -----------------------------------------------------------------------
#define QUAL_KSHIFT       3
#define QUAL_KVAL       (1<<QUAL_KSHIFT)
#define QUAL_ROUNDOFF   (QUAL_KVAL-1)           // round-off so 0 is possible
#define QUAL_MAX       ((QUAL_KVAL * QUAL_KVAL) - QUAL_ROUNDOFF)
#define QUAL_AVE        (QUAL_MAX /2)
#define QUAL_THRESHOLD  (QUAL_MAX * 0.70)
static BYTE         dpwrQualGfsk;
static BYTE         dpwrQual8dr;

// -----------------------------------------------------------------------
// QUAL_CONSEC_MAX - Number of consecutive transmissions at MAX metric before
//                   Tx power is reduced by 1 step.
// -----------------------------------------------------------------------
#define QUAL_CONSEC_MAX 8
static BYTE         dpwrMaxConsecGfsk;
static BYTE         dpwrMaxConsec8dr;
static char         dpwrStayCt;



// ---------------------------------------------------------------------------
//
// PRIVATE VARIABLES
//
// ---------------------------------------------------------------------------
static BOOL         fTsb;       // Transmit Sequence Bit
static BOOL         fEsb;       // Expected Sequence Bit

static BOOL         rxBufPend;

static RADIO_STATE  radioStateCopy;
static BYTE         rxLen;


// ---------------------------------------------------------------------------
// CYFISNP_IdleReceive
//      XACT_STATE_SYNTH - CYFISNP_XACT_CFG_ADR settings when in SYNTH
//      XACT_STATE_IDLE1 - CYFISNP_XACT_CFG_ADR settings when in IDLE
//      XACT_STATE_IDLE2 - CYFISNP_XACT_CFG_ADR settings when in IDLE
//
//
//  wall-powered            battery-powered
//   IDLE = SYNTH           tx->idle1->idle2
// ---------------------------------------------------------------------------

static BOOL idleReceive;            // TRUE = Idle Radio in Rx, not Sleep
#define XACT_COMMON         (CYFISNP_ACK_EN | CYFISNP_ACK_TO_8X)
#define XACT_STATE_SYNTH    (XACT_COMMON    | CYFISNP_END_STATE_RXSYNTH)
#define XACT_STATE_IDLE     (XACT_COMMON    | CYFISNP_END_STATE_IDLE)
#define XACT_STATE_SLEEP    (XACT_COMMON    | CYFISNP_END_STATE_SLEEP)



// ---------------------------------------------------------------------------
// CYFISNP_DATA_PACKET_RETRIES - Max Tx data attempts before Timeout
// ---------------------------------------------------------------------------
#define CYFISNP_DATA_PACKET_RETRIES 10
static BYTE         bDataRetryCt;
static CYFISNP_API_PKT *pTxStruct;
static BOOL         txPending;



// ---------------------------------------------------------------------------
// Response Window - How long to wait for a Response to a Request
// ---------------------------------------------------------------------------
#if CYFISNP_PWR_TYPE == CYFISNP_PWR_COIN
#define RSP_WINDOW_TIMER   (3000/200)               //  3 mS
#else                                               //
#define RSP_WINDOW_TIMER   (50/CYFISNP_TIMER_UNITS)     // 50 mS
#endif
static WORD     rspWindowTimer;                     // Response Window Timer


// ---------------------------------------------------------------------------
// onChanTxLeft - How many Connect Requests to send before changing channels.
// ---------------------------------------------------------------------------
#define ON_NEW_CHAN_TX_MAX  1       // Retry count if no AutoAck
#define ON_ACK_CHAN_TX_MAX  (10-1)  // Retry count if AutoAck
static BYTE     onChanTxLeft;
static BOOL     fGotChanAck;

#define CON_MODE_COUNT_MAX  200     // Max # Con Req to send before timeout
#define PING_MODE_COUNT_MAX 200     // Max # PingReq to send before timeout
static WORD     wModeCounter;

static WORD wModeDelay;
#define CON_MODE_FAST_TIME  (1/CYFISNP_TIMER_UNITS)
#define CON_MODE_SLOW_TIME  (200/CYFISNP_TIMER_UNITS)
#define PING_MODE_FAST_TIME (1/CYFISNP_TIMER_UNITS)
#define PING_MODE_SLOW_TIME (200/CYFISNP_TIMER_UNITS)



// ---------------------------------------------------------------------------
//
// Binding variables
//
// ---------------------------------------------------------------------------

static char bindChIdx;

// ---------------------------------------------------------------------------
// RX_WINDOW - Max time to wait for a Hub Bind Respone.
// ---------------------------------------------------------------------------
#define CYFISNP_RX_WINDOW   (3000 / 100)    // 3 mS (via 100 uS delay loop)

// ---------------------------------------------------------------------------
// BIND_MODE_COUNT_MAX - Number of Bind Requests sent before TIMEOUT
// ---------------------------------------------------------------------------
#define BIND_MODE_COUNT_MAX  500        // Give Hub time to write its Flash
static WORD wBindModeCounter;
    // ------------------------------------------------------------------------
    // bindReqTimer - Throttle BindReq to something reasonable (20 mS)
    //   If send as fast as possible, application may be sending every 2 mS and
    //   we'll burn-through BIND_MODE_COUNT_MAX so fast the person may not
    //   have time to move and push bind button on hub.
    // ------------------------------------------------------------------------
static WORD bindReqTimer;
#define BIND_REQ_TIME   (1 + 10/CYFISNP_TIMER_UNITS) // 10mS or 1 tick



// ---------------------------------------------------------------------------
//
// Wall Powered Node: Beacon Timeout Timer
//
// ---------------------------------------------------------------------------
#define BEACON_MAX_TIME     (3000 / CYFISNP_TIMER_UNITS)
static WORD beaconMaxTimer;

static BOOL CYFISNP_inRxGo;


// ---------------------------------------------------------------------------
//
// LOCAL FUNCTIONS
//
// ---------------------------------------------------------------------------
static void runConnectMode      (void);
static void gotoDataMode        (void);
static void runDataMode         (void);
static void runDataModeTx       (void);
static void runDataModeRx       (void);
static void runDataModeRxCrc0   (void);
static void gotoPingMode        (void);
static void runPingMode         (void);
static void gotoUnboundMode     (void);
static void gotoDefaultMode     (void);
// -----------------------------------
static void nextNetCh           (void);
static void putNetParams        (BYTE * pConRspPkt);
static void copyMidToTxPkt      (void);
static BOOL rxMidEquNodeMid     (BYTE *pRxMid);
// -----------------------------------
static void setMaxPaLevel       (void);
static void setPaLevel          (BYTE paLevel);
static void writeHwPa           (void);
static void decPaLevel          (void);
static void dynPaApply          (void);
static void dynPaUpdate         (BOOL ackResult);
static void toggleDataRate      (void);
static void externalPaDisable   (void);
static void externalPaEnable    (void);
static void issueRxGo           (void);
// -----------------------------------
static void gotoConnectModeBase (void);
static void gotoConnectMode     (void);
static void setBindPaLevel      (void);
static void bindRun             (void);
static BOOL netParamsPresent    (void);
static void crc0AutoAck         (BOOL enable);

static void setIdleReceive      (BOOL enable);



// -----------------------------------
static void flashWrite          (BYTE *pSrc);
// ---------------------------------------------------------------------------


static void setNodeSeed(void) {
    CYFISNP_SetCrcSeed ((CYFISNP_EEP_NET_REC_ADR->nodeSeedMsb << 8)
                               | (CYFISNP_EEP_NET_REC_ADR->nodeSeedLsb     ));
}
static void setHubSeed(void) {
    CYFISNP_SetCrcSeed ((CYFISNP_EEP_NET_REC_ADR->hubSeedMsb << 8)
                               | (CYFISNP_EEP_NET_REC_ADR->hubSeedLsb     ));
}



// ---------------------------------------------------------------------------
//
// CYFISNP_Start() - Powerup initialization (Radio powers-up in IDLE)
//
// ---------------------------------------------------------------------------
BYTE CYFISNP_Start(void)
{
    if (CYFISNP_eProtState != 0
     && CYFISNP_eProtState != CYFISNP_STOP_MODE) {
        return 0;         // START only works at powerup and from STOP
    }

#if(CYFISNP_PSOC_EXPRESS_PROJECT == 0)
    CYFISNP_SleepTimer_Set64Hz();
    M8C_EnableIntMask(INT_MSK0, INT_MSK0_SLEEP);
#endif

    if(!CYFISNP_PhyStart())
    {
        CYFISNP_OutStr("\n\rRadio Init Failed!\n\r");
        return 0;
    }

#if !CYFISNP_DEBUG  // Stop 750KHz default on XOUT (reduce noise)
    CYFISNP_Write(CYFISNP_XTAL_CTRL_ADR, CYFISNP_XOUT_FNC_GPIO);
#endif

	CYFISNP_SetPreambleCount(CYFISNP_DEF_PREAMBLE_CNT);
    CYFISNP_ForceState(CYFISNP_END_STATE_SLEEP);  // Min radio current
    CYFISNP_SetPtr(&SNP_txBuf[0]);
    CYFISNP_SetLength(SNP_PROT_PKT_TX_MAX);
    crc0AutoAck(FALSE);

    gotoDefaultMode();
    CYFISNP_spiSleep();

    bDataRetryCt = 0;           // No more retries
    txPending = FALSE;          // Empty API's Tx buffer

    return 1;
}


// ---------------------------------------------------------------------------
//
// CYFISNP_Stop() - Can be used to "abort" a pending transmission.
//
// ---------------------------------------------------------------------------
void CYFISNP_Stop(void)
{
    CYFISNP_PhyStop();

#if(CYFISNP_PSOC_EXPRESS_PROJECT == 0)
    M8C_DisableIntMask(INT_MSK0, INT_MSK0_SLEEP);
#endif

    CYFISNP_eProtState = CYFISNP_STOP_MODE;

}



// ---------------------------------------------------------------------------
//
// CYFISNP_Jog() - Wakeup from a Time-Out power-conservation state.
//
// ---------------------------------------------------------------------------
void CYFISNP_Jog(void)
{
    CYFISNP_spiWake();
    switch (CYFISNP_eProtState) {
        case CYFISNP_CON_MODE_TIMEOUT:
             gotoConnectMode();
             break;
        case CYFISNP_PING_MODE_TIMEOUT:
            gotoPingMode();
            break;
    }
}



// ---------------------------------------------------------------------------
//
// CYFISNP_Run() = Punctuated periodic polling
//
// ---------------------------------------------------------------------------
void CYFISNP_Run(void)
{
    switch (CYFISNP_eProtState) {
        // -------------------------------------------------------------------
    case CYFISNP_BIND_MODE:
            CYFISNP_spiWake();
            bindRun();
            break;
        // -------------------------------------------------------------------
        case CYFISNP_CON_MODE:
            CYFISNP_spiWake();
            runConnectMode();
            break;
        // -------------------------------------------------------------------
        case CYFISNP_DATA_MODE:
            CYFISNP_spiWake();
            runDataMode();
            CYFISNP_spiSleep();
            break;
        // -------------------------------------------------------------------
        case CYFISNP_PING_MODE:
            CYFISNP_spiWake();
            runPingMode();
            break;
        // -------------------------------------------------------------------
        default:
            break;
    }
}


// ---------------------------------------------------------------------------
//
// gotoDefaultMode() - Goto Connect mode if are bound, otherwise go Unbound
//
// ---------------------------------------------------------------------------
static void gotoDefaultMode(void) {
    if (netParamsPresent()) {
        gotoConnectModeBase();
    }
    else {
        gotoUnboundMode();
    }
}


// ---------------------------------------------------------------------------
//
// gotoUnboundMode() - Do nothing until _BindStart() is called
//
// ---------------------------------------------------------------------------
static void gotoUnboundMode(void)
{
    CYFISNP_eProtState = CYFISNP_UNBOUND_MODE;
    CYFISNP_OutStr("<Unbound: STOP>");
}

// ---------------------------------------------------------------------------
//
//  CYFISNP_BindStart() - From Data Mode to Bind Mode
//
// ---------------------------------------------------------------------------
void CYFISNP_BindStart(BYTE DevID)
{
    CYFISNP_OutStr("\n\rStart Bind Mode");

    CYFISNP_spiWake();
    bindChIdx = 0;
    CYFISNP_bCurrentChannel = CYFISNP_BIND_CH_SEQ[bindChIdx];
    CYFISNP_SetChannel  (CYFISNP_bCurrentChannel);
    CYFISNP_SetSopPnCode(CYFISNP_BIND_MODE_SOP);

    SNP_txBuf[0] = PKT_BINDREQ_TYPE | CYFISNP_PWR_TYPE;
    SNP_txBuf[1] = DevID;
    copyMidToTxPkt();
    SNP_txBuf[6] = SNP_RSP_DELAY;

    CYFISNP_eProtState = CYFISNP_BIND_MODE;
    wBindModeCounter = BIND_MODE_COUNT_MAX;

    CYFISNP_TimeSet(&bindReqTimer, BIND_REQ_TIME);
}


// ---------------------------------------------------------------------------
//
//  bindRun() -
//
// ---------------------------------------------------------------------------
static void bindRun(void)
{
    RADIO_STATE radioStateCopy;

    if (CYFISNP_TimeExpired(&bindReqTimer) != TRUE) {
        return;
    }
    CYFISNP_TimeSet(&bindReqTimer, BIND_REQ_TIME);

    // -----------------------------------------------------------------------
    // Send another Bind Request
    // -----------------------------------------------------------------------
    if (++bindChIdx >= sizeof(CYFISNP_BIND_CH_SEQ)) {
        bindChIdx = 0;
    }
    CYFISNP_bCurrentChannel = CYFISNP_BIND_CH_SEQ[bindChIdx];
    CYFISNP_SetChannel(CYFISNP_bCurrentChannel);
    setBindPaLevel();
    crc0AutoAck(TRUE);
    CYFISNP_SetCrcSeed(CYFISNP_BIND_MODE_CRC_SEED);
    CYFISNP_SetXactConfig(0
                      | CYFISNP_ACK_EN          // Expect AutoAck
                      | CYFISNP_ACK_TO_8X
                      | CYFISNP_END_STATE_RX);  // Expect Response
    CYFISNP_SetPtr(&SNP_txBuf[0]);
    CYFISNP_StartTransmit(0, PKT_BINDREQ_LEN);
    while ((CYFISNP_State & CYFISNP_COMPLETE) == 0) {
        CYFISNP_GetTransmitState();
    }
    radioStateCopy = CYFISNP_State;
    CYFISNP_EndTransmit();

    crc0AutoAck(FALSE);
    CYFISNP_SetCrcSeed( (WORD)(SNP_txBuf[2]<<8) | SNP_txBuf[3]);

    // -----------------------------------------------------------------------
    // If AutoAck failed, power-down radio
    // -----------------------------------------------------------------------
    if ((radioStateCopy & CYFISNP_ERROR) != 0) {
        CYFISNP_ForceState(CYFISNP_END_STATE_SLEEP);
    }
    // -----------------------------------------------------------------------
    // Else AutoAck PASSED, open 3 mS BindRsp Rx window
    // -----------------------------------------------------------------------
    else {
        WORD waitDelay;
        waitDelay = CYFISNP_RX_WINDOW;

        setMaxPaLevel();                    // node sends AutoAck at full power
        CYFISNP_SetPtr(&SNP_rxBuf.snp.pkt[0]);
        CYFISNP_SetLength(SNP_PROT_PKT_RX_MAX);
        CYFISNP_SetXactConfig(0
                                | CYFISNP_ACK_EN   // Expect AutoAck
                                | CYFISNP_ACK_TO_8X
                                | CYFISNP_END_STATE_IDLE);
        CYFISNP_StartReceive();

        // -------------------------------------------------------------------
        // Maintain 3 mS BindRsp Rx window
        // -------------------------------------------------------------------
        for (;;) {
            BYTE rxLen = 0;
            radioStateCopy = CYFISNP_GetReceiveState();

            CYFISNP_Delay100uS();           // Delay 100 uS
            if (--waitDelay == 0) {
                rxLen = CYFISNP_Abort();
                if (rxLen == CYFISNP_ABORT_SUCCESS) {
                    CYFISNP_ForceState(CYFISNP_END_STATE_SLEEP);
                    break;
                }
            }
            if (radioStateCopy & CYFISNP_COMPLETE) {
                rxLen = CYFISNP_EndReceive();
                CYFISNP_ForceState(CYFISNP_END_STATE_SLEEP);

                if (radioStateCopy & CYFISNP_ERROR) {
                    break;
                }
                // -----------------------------------------------------------
                // If BindRsp received
                // -----------------------------------------------------------
                if (SNP_rxBuf.snp.pkt[0] == PKT_BINDRSP_TYPE
                 &&                rxLen == PKT_BINDRSP_LEN) {
                    putNetParams(&SNP_rxBuf.snp.pkt[0]);    // Wr to FLASH
                    gotoConnectModeBase();
                    return;         // BIND SUCCESSFUL ----- EXIT HERE
                }
            }   // end Rx Complete
        }  // end for(;;)
    }   // end AutoAck received

    if (--wBindModeCounter == 0) {
        gotoDefaultMode();          // Exhausted Bind attempts
    }
}


// ---------------------------------------------------------------------------
//
// CYFISNP_GetNodeID -
//
// ---------------------------------------------------------------------------
BYTE CYFISNP_GetNodeID(void)  {
    return(CYFISNP_EEP_NET_REC_ADR->devId);
}


// ---------------------------------------------------------------------------
//
// gotoConnectMode() - Enter connect from Powerup or Bind Response
//
// ---------------------------------------------------------------------------
static void gotoConnectModeBase(void) {
    CYFISNP_bCurrentChannel = (CYFISNP_EEP_NET_REC_ADR->chBase);
    setIdleReceive(CYFISNP_PWR_TYPE == CYFISNP_PWR_WALL);
    gotoConnectMode();
}

static void gotoConnectMode(void)
{
    CYFISNP_OutStr("\n\rStart Connect Mode. ");

    setMaxPaLevel();

    CYFISNP_SetChannel(CYFISNP_bCurrentChannel);
    CYFISNP_SetSopPnCode(CYFISNP_EEP_NET_REC_ADR->sopIdx);

    CYFISNP_eProtState = CYFISNP_CON_MODE;
    onChanTxLeft = ON_NEW_CHAN_TX_MAX;
    wModeCounter = CON_MODE_COUNT_MAX;
    CYFISNP_TimeSet(&wModeDelay, CON_MODE_FAST_TIME);

    // -----------------------------------------------------------------------
    // Since Connect Request packet doesn't change, create it ONCE
    // -----------------------------------------------------------------------
    SNP_txBuf[0] = PKT_CONREQ_TYPE;
    SNP_txBuf[1] = CYFISNP_EEP_NET_REC_ADR->devId;
    copyMidToTxPkt();
}


// ---------------------------------------------------------------------------
//
//  runConnectMode() -
//
//  The Hub may need to write Node parameters to Flash before returning the
//  ConRsp, so it may a while (4 seconds if using Ice Cube).  If the Node is
//  being a "good neighbor", it shouldn't spew ConReq ASAP if the Hub is
//  busy writing its Flash, thus:
//      1) If Node gets an ACK, it waits a while because it found the HUB
//      2) If Node gets NAK, it retransmits quickly to slew across channels
//
// ---------------------------------------------------------------------------
static void runConnectMode(void)
{
    if (CYFISNP_TimeExpired(&wModeDelay) == FALSE) {
        return;
    }
    if (wModeCounter > CON_MODE_COUNT_MAX/2 ) {
        CYFISNP_TimeSet(&wModeDelay, CON_MODE_FAST_TIME);
    } else {
        CYFISNP_TimeSet(&wModeDelay, CON_MODE_SLOW_TIME);
    }

    if (wModeCounter-- == 0) {
        CYFISNP_eProtState = CYFISNP_CON_MODE_TIMEOUT;
        CYFISNP_OutStr("\n\rConnect Mode Timeout. ");
        CYFISNP_spiSleep();
    }

    // -------------------------------------------------------------------
    // Send (another) Connect Request
    // -------------------------------------------------------------------
    if (onChanTxLeft-- <= 0) {
        onChanTxLeft = ON_NEW_CHAN_TX_MAX;
        fGotChanAck = 0;
        nextNetCh();
        CYFISNP_SetChannel(CYFISNP_bCurrentChannel);
    }

    setHubSeed();
    CYFISNP_ForceState(CYFISNP_END_STATE_RXSYNTH);  // Expect Rx Response
    CYFISNP_SetPtr(&SNP_txBuf[0]);
    CYFISNP_StartTransmit(0, PKT_CONREQ_LEN);
    while ((CYFISNP_State & CYFISNP_COMPLETE) == 0) {
        CYFISNP_GetTransmitState();
    }
    radioStateCopy = CYFISNP_State;
    CYFISNP_EndTransmit();


    // -------------------------------------------------------------------
    // If AutoAck failed, power-down radio
    // -------------------------------------------------------------------
    if ((radioStateCopy & CYFISNP_ERROR) != 0) {
        CYFISNP_ForceState(CYFISNP_END_STATE_SLEEP);
        dynPaUpdate(0);
    }
    // -------------------------------------------------------------------
    // Else if AutoAck PASSED, then open ConRsp receive window
    //  and spend a little more time on this channel
    // -------------------------------------------------------------------
    else {
        dynPaUpdate(1<<QUAL_KSHIFT);

        fTsb = 0;                       // Zero Transmit Seq Bit

        if (fGotChanAck == 0) {
            fGotChanAck = 1;
            onChanTxLeft = ON_ACK_CHAN_TX_MAX;
        }

        #if CYFISNP_PWR_TYPE == CYFISNP_PWR_COIN
        rspWindowTimer = RSP_WINDOW_TIMER;
        #else
        CYFISNP_TimeSet(&rspWindowTimer, RSP_WINDOW_TIMER);
        #endif

        CYFISNP_SetXactConfig(XACT_STATE_IDLE); // Ok because in SYNTH
        issueRxGo();

        for (;;) {
            BYTE rxLen = 0;
            radioStateCopy = CYFISNP_GetReceiveState();

            // If Receive Window Expired, then ABORT Receive and EXIT
            #if CYFISNP_PWR_TYPE == CYFISNP_PWR_COIN
            CYFISNP_Delay100uS();                 // Delay 100 uS
            if (--rspWindowTimer == 0) {
            #else
            if (CYFISNP_TimeExpired(&rspWindowTimer)) {
            #endif
                rxLen = CYFISNP_Abort();
                if (rxLen == NO_RX_PACKET) {
                    CYFISNP_ForceState(CYFISNP_END_STATE_SLEEP);
                    break;
                }   // Else got Rx packet instead, fallthru and process it.
            }
            if (radioStateCopy & CYFISNP_ERROR) {
                CYFISNP_EndReceive();
                CYFISNP_ForceState(CYFISNP_END_STATE_SLEEP);
                break;
            }
            if (radioStateCopy & CYFISNP_COMPLETE) {
                rxLen = CYFISNP_EndReceive();
                CYFISNP_ForceState(CYFISNP_END_STATE_SLEEP);
                // -----------------------------------------------------------
                // If ConRsp received, then process and goto DATA_MODE
                // -----------------------------------------------------------
                if (                 SNP_rxBuf.snp.pkt[0] == PKT_CONRSP_TYPE
                &&                                  rxLen == PKT_CONRSP_LEN
                && rxMidEquNodeMid(&SNP_rxBuf.snp.pkt[2]) == TRUE
                ) {
                    if (SNP_rxBuf.snp.pkt[1] != 0) { // ConRsp has devId != 0
                        gotoDataMode();
                        return;         // Connect SUCCESSFUL ----- EXIT HERE
                    }
                    else {              // ConRsp has devId == 0
                        CYFISNP_Unbind();  // UNBIND ################
                        gotoUnboundMode();
                    }
                }
            } // if (radioStateCopy ....
        }
    }       // Exit "got autoack"
}
// ###########################################################################



// ---------------------------------------------------------------------------
//
// CYFISNP_TxDataPend()
//
// ---------------------------------------------------------------------------
BOOL CYFISNP_TxDataPend(void)
{
    if (txPending == 0) {
        return(FALSE);
    }
    return(TRUE);
}

// ---------------------------------------------------------------------------
//
// CYFISNP_TxDataPut()
//
// ---------------------------------------------------------------------------
BOOL CYFISNP_TxDataPut(CYFISNP_API_PKT *pStruct)
{
    BYTE lvType = PKT_DATA_FCD_TYPE;

    switch (pStruct->type) {
        case CYFISNP_API_TYPE_CONF_BCDR:
            lvType |= PKT_BCDR_MASK;
            // fallthru
        case CYFISNP_API_TYPE_CONF:
            lvType |= fTsb;               // Add Tx Seq Bit in Hdr
            bDataRetryCt = CYFISNP_DATA_PACKET_RETRIES;
            break;
        // -------------------------------------------------------------------
        case CYFISNP_API_TYPE_SYNC_BCDR:
            lvType |= PKT_BCDR_MASK;  // Add BCDR bit
            // fallthru
        case CYFISNP_API_TYPE_SYNC:
            lvType |= PKT_SEQSYNC;          // Add Sync (no deliv conf needed)
            bDataRetryCt = CYFISNP_DATA_PACKET_RETRIES;
            break;
        // -------------------------------------------------------------------
        default:        // Ignore everything else
            return FALSE;
    }

    pStruct->type  = lvType;
    pStruct->devId = CYFISNP_EEP_NET_REC_ADR->devId;
    pTxStruct      = pStruct;           // Point to API structure
    txPending = TRUE;
    return TRUE;
}



// ---------------------------------------------------------------------------
//
//  gotoDataMode() - From Connect or Ping Mode to Data Mode
//
//   runDataMode() - Send a Tx Data packet
//
// ---------------------------------------------------------------------------
static void gotoDataMode(void)
{
    CYFISNP_OutStr("\n\rStart Data Mode. ");
    setMaxPaLevel();
    CYFISNP_eProtState = CYFISNP_DATA_MODE;
    if (CYFISNP_TxDataPend() == TRUE) {        // If Tx Data pending
        bDataRetryCt = CYFISNP_DATA_PACKET_RETRIES; // Then retry some more
        CYFISNP_Jog();
    }
    if (idleReceive) {
        CYFISNP_ForceState(CYFISNP_END_STATE_IDLE);     // Manually wake
        issueRxGo();                                    // Enter Receive
        CYFISNP_inRxGo = TRUE;
        CYFISNP_TimeSet(&beaconMaxTimer, BEACON_MAX_TIME);
    }
}


// ---------------------------------------------------------------------------
// issueRxGo() -
// ---------------------------------------------------------------------------
static void issueRxGo(void) {
    CYFISNP_SetPtr      (&SNP_rxBuf.snp.pkt[0]);
    CYFISNP_SetLength   (PHYSICAL_BCD_PACKET_MAX);
    setNodeSeed();
    CYFISNP_StartReceive();
}

// ---------------------------------------------------------------------------
// setIdleReceive() - Application may idle in Receive or Sleep
//
// Used in a hybrid node, where SLEEPs most of the time, but infrequently
//  wants to do Application delineated periods of low-latency back channel
//  data (for example Vista SideShow traffic).
// ---------------------------------------------------------------------------
static void setIdleReceive(BOOL enable) {

    if (idleReceive != enable) {
        idleReceive = enable;
        if (enable == FALSE) {
            rxLen = CYFISNP_Abort();                        // Stop Receive
            CYFISNP_ForceState(CYFISNP_END_STATE_SLEEP);    // Low power
            CYFISNP_inRxGo = FALSE;
        }
        if (enable == TRUE) {
            CYFISNP_ForceState(CYFISNP_END_STATE_IDLE);     // Manually wake
            issueRxGo();                                    // Enter Receive
            CYFISNP_inRxGo = TRUE;
            CYFISNP_TimeSet(&beaconMaxTimer, BEACON_MAX_TIME);
       }
    }
}



// ---------------------------------------------------------------------------
//
// runDataMode() - Handle Data Mode polled processes.
//
//  If radio idles in Receive, this includes servicing and rearming the
//   radio receiver.  Idling in Receive also means an Rx Abort process before
//   transmitting a packer.
//
//  If radio idles in Sleep, only monitor and service a pending Tx packet.
//
// ---------------------------------------------------------------------------
static void runDataMode(void)
{
    rxLen = NO_RX_PACKET;

    // -----------------------------------------------------------------------
    // If Tx Data is pending, service it
    // -----------------------------------------------------------------------
    if (bDataRetryCt != 0) {
        if (CYFISNP_inRxGo == TRUE) {       // If RX_GO invoked,
            rxLen = CYFISNP_Abort();    //  Then Abort (might get Rx pkt)
            CYFISNP_inRxGo = FALSE;
        }
        if (rxLen == NO_RX_PACKET) {    // Normal case, Rx aborted w/o RxPkt
            runDataModeTx();            // Service pending Tx Data
            return;
        } else {                        // Rx Aborted WITH Rx Packet received
            runDataModeRx();            // Service Rx packet
            return;                     // Exit w/o RX_GO
        }
    }

    // -----------------------------------------------------------------------
    // If IDLE in RECEIVE Mode, then
    // -----------------------------------------------------------------------
    if (idleReceive) {

        // -------------------------------------------------------------------
        // Watch for missing Hub Beacon
        // -------------------------------------------------------------------
        if (CYFISNP_TimeExpired(&beaconMaxTimer)) {
            rxLen = CYFISNP_Abort();
            CYFISNP_inRxGo = FALSE;
            if (rxLen == NO_RX_PACKET) {
                gotoPingMode();         // Beacon Timeout
            } else {
                CYFISNP_TimeSet(&beaconMaxTimer, BEACON_MAX_TIME);
                runDataModeRx();        // Service Rx Packet
            }
            return;
        }

        // -------------------------------------------------------------------
        // Ensure in RX_GO
        // -------------------------------------------------------------------
        if (CYFISNP_inRxGo == FALSE) {      // If not in Receive
            CYFISNP_ForceState(CYFISNP_END_STATE_RXSYNTH);
            issueRxGo();                //  Then get in Receive
            CYFISNP_inRxGo = TRUE;
        }

        // -------------------------------------------------------------------
        // Monitor and service received packet
        // -------------------------------------------------------------------
        radioStateCopy = CYFISNP_GetReceiveState();
        if (radioStateCopy & CYFISNP_COMPLETE) {
            rxLen = CYFISNP_EndReceive();
            if (radioStateCopy & CYFISNP_ERROR) {
                // -----------------------------------------------------------
                // Rx CRC0 Packets report as ERROR because DIS_CRC0 is SET
                //  during node Receive to suppress AutoAck, BUT CRC0 packets
                //  have RX_CRC0 status SET indicating they're OK
                // -----------------------------------------------------------
                char statReg;
                statReg  = CYFISNP_Read(CYFISNP_RX_STATUS_ADR);
                statReg &= CYFISNP_RX_PKTERR|CYFISNP_RX_EOPERR|CYFISNP_RX_CRC0;
                if (statReg == CYFISNP_RX_CRC0) {
                    runDataModeRxCrc0();    // Rx packet used CRC0 (no error)
                } else {
                    // silently discard Rx packet w/Error
                }
            }
            else {
                runDataModeRx();        // Service receiver
            }
            issueRxGo();                // Rearm Receiver
        }
    }
}


// ---------------------------------------------------------------------------
//
// runDataModeRx() - Received good packet (non-CRC0 Seed), process it
//
//          rxLen = length of received packet
// ---------------------------------------------------------------------------
static void runDataModeRx(void)
{
    BYTE lvRxType;
    lvRxType = SNP_rxBuf.snp.pkt[0];

    if (rxLen == PKT_UNBIND_LEN && lvRxType == PKT_UNBIND_TYPE) {
        CYFISNP_Unbind();
    }
    else if (rxLen != 0
     && (lvRxType & 0xFC) == PKT_DATA_BCD_TYPE) {

        SNP_rxBuf.api.length = rxLen - 1;     // Get Payload Length
        SNP_rxBuf.api.rssi   = CYFISNP_GetRssi()
                             & CYFISNP_RSSI_LVL_MSK;

        SNP_rxBuf.api.type = (lvRxType == (PKT_DATA_BCD_TYPE+2)) ?
                                CYFISNP_API_TYPE_SYNC :
                                CYFISNP_API_TYPE_CONF;

        SNP_rxBuf.api.devId  = CYFISNP_EEP_NET_REC_ADR->devId;
        rxBufPend = TRUE;                   // Pass packet to API
    }
}

// ---------------------------------------------------------------------------
//
// runDataModeRxCrc0() - Received good CRC0 packet, process it
//
//          rxLen = length of received packet
// ---------------------------------------------------------------------------
static void runDataModeRxCrc0(void) {
    CYFISNP_TimeSet(&beaconMaxTimer, BEACON_MAX_TIME);
}




// ---------------------------------------------------------------------------
//
// runDataModeTx() - Tx 1 Burst in a dedicated function
//
// ---------------------------------------------------------------------------
static void runDataModeTx(void)
{
    if (--bDataRetryCt == 0) {
        gotoPingMode();     // FAILED TO DELIVER PACKET, CHANGE TO PING MODE
    }

    // -------------------------------------------------------------------
    // Transmit Data Packet
    // -------------------------------------------------------------------
    setHubSeed();
    dynPaApply();            // Dynamic Power

    if ((pTxStruct->type & PKT_BCDR_MASK) == 0 && idleReceive == FALSE) {
        CYFISNP_ForceState(CYFISNP_END_STATE_IDLE); // Set Radio IDLE
    }
    else {
        CYFISNP_ForceState(CYFISNP_END_STATE_TXSYNTH); // Set Radio in SYNTH
    }

    CYFISNP_SetPtr          (&pTxStruct->type);
    CYFISNP_StartTransmit   (0, pTxStruct->length + 2);
    while ((CYFISNP_State & CYFISNP_COMPLETE) == 0) {
        CYFISNP_GetTransmitState();
    }
    radioStateCopy = CYFISNP_State;
    CYFISNP_EndTransmit();

    // -------------------------------------------------------------------
    // If AutoAck failed, Idle radio and EXIT
    // -------------------------------------------------------------------
    if ((radioStateCopy & CYFISNP_ERROR) != 0) {
        dynPaUpdate(0);
        if (idleReceive == FALSE) {
            CYFISNP_ForceState(XACT_STATE_SLEEP);   // Manually put to SLEEP
        }
        return;
    }
    dynPaUpdate(1<<QUAL_KSHIFT);

    // -------------------------------------------------------------------
    // Delivered packet
    // -------------------------------------------------------------------
    bDataRetryCt = 0;           // No more retries
    txPending = FALSE;          // Empty API's Tx buffer

    // -------------------------------------------------------------------
    // Inc Transmit Seq Bit if Tx Pkt used the Tx Seq Bit
    // -------------------------------------------------------------------
    if ((pTxStruct->type & PKT_SEQBIT_MASK) < PKT_SEQSYNC) {
        fTsb ^= 1;              // Inc mod-2
    }

    // -------------------------------------------------------------------
    // If Back Channel Data Request flag was zero, exit
    // -------------------------------------------------------------------
    if ((pTxStruct->type & PKT_BCDR_MASK) == 0) {
        if (idleReceive == FALSE)  {
            CYFISNP_ForceState(CYFISNP_END_STATE_SLEEP);
        }
    }
    // -----------------------------------------------------------------------
    // Else Open Back Channel Receive Window
    // -----------------------------------------------------------------------
    else {
        #if CYFISNP_PWR_TYPE == CYFISNP_PWR_COIN
        rspWindowTimer = (3000/200);     // 3,000 uS / 200 uS
        #else
        CYFISNP_TimeSet(&rspWindowTimer, RSP_WINDOW_TIMER);
        #endif

        issueRxGo();

        // -------------------------------------------------------------------
        // Wait for Back Channel packet or Window Timeout
        // -------------------------------------------------------------------
        for (;;) {

            radioStateCopy = CYFISNP_GetReceiveState();

            // ---------------------------------------------------------------
            // Monitor Rx Window Timeout
            // ---------------------------------------------------------------
            #if CYFISNP_PWR_TYPE == CYFISNP_PWR_COIN        // Use short accurate delay
            CYFISNP_Delay100uS();                       // Delay 100 uS
            if (--rspWindowTimer == 0)              // to minimize power
            #else                                   // ELSE Alkaline battery
            if (CYFISNP_TimeExpired(&rspWindowTimer))   // use timer
            #endif
                {
                rxLen = CYFISNP_Abort();
                if (rxLen == NO_RX_PACKET) {
                    if (idleReceive == FALSE)  {
                        CYFISNP_ForceState(CYFISNP_END_STATE_SLEEP);
                    }
                    break;
                }
            }
            // ---------------------------------------------------------------
            // Monitor for Rx Packet Error
            // ---------------------------------------------------------------
            if (radioStateCopy & CYFISNP_ERROR) {
                CYFISNP_EndReceive();
                if (idleReceive == FALSE)  {
                    CYFISNP_ForceState(CYFISNP_END_STATE_SLEEP);
                }
                break;
            }
            // ---------------------------------------------------------------
            // Monitor for Rx Packet Success
            // ---------------------------------------------------------------
            if (radioStateCopy & CYFISNP_COMPLETE) {
                rxLen = CYFISNP_EndReceive();
                if (idleReceive == FALSE)  {
                    CYFISNP_ForceState(CYFISNP_END_STATE_SLEEP);
                }
                runDataModeRx();            // Process Rx Packet
                break;
            }
        }
        setHubSeed();
    } // Exit "Else Open Back Channel Receive Window"
}



// ---------------------------------------------------------------------------
// CYFISNP_RxDataPend()
// ---------------------------------------------------------------------------
BOOL CYFISNP_RxDataPend(void)
{
    return (rxBufPend);
}

// ---------------------------------------------------------------------------
// CYFISNP_RxDataGet()
// ---------------------------------------------------------------------------
    CYFISNP_API_PKT *               // Return pointer to Rx API structure
CYFISNP_RxDataGet(void)
{
    return((CYFISNP_API_PKT *) &SNP_rxBuf.api);
}

// ---------------------------------------------------------------------------
// CYFISNP_RxDataRelease()
// ---------------------------------------------------------------------------
void CYFISNP_RxDataRelease(void)
{
    rxBufPend = FALSE;
}


// ---------------------------------------------------------------------------
//
// gotoPingMode()
//
// runPingMode() -
//
// ---------------------------------------------------------------------------
static void gotoPingMode(void)
{
    CYFISNP_OutStr("\n\rStart Ping Mode. ");
    setMaxPaLevel();
    CYFISNP_eProtState = CYFISNP_PING_MODE;
    wModeCounter   = PING_MODE_COUNT_MAX;
    CYFISNP_TimeSet(&wModeDelay, PING_MODE_FAST_TIME);

    // ------------------
    // Create PING packet
    // ------------------
    SNP_txBuf[0] = PKT_PING_TYPE;
    SNP_txBuf[1] = CYFISNP_EEP_NET_REC_ADR->devId;
}

static void runPingMode(void)
{

    if (CYFISNP_TimeExpired(&wModeDelay) == FALSE) {
        return;
    }
    if (wModeCounter > PING_MODE_COUNT_MAX/2 ) {
        CYFISNP_TimeSet(&wModeDelay, PING_MODE_FAST_TIME);
    } else {
        CYFISNP_TimeSet(&wModeDelay, PING_MODE_SLOW_TIME);
    }

    if (wModeCounter-- == 0) {
        // -------------------------------------------------------------------
        // Since can't find Hub, it's possible that it's been replaced and the
        //  Node should send a packet with BCDR to revalidate the Node's ID,
        //  so timeout in Connect Mode to revalidate at eventual Jog()
        // -------------------------------------------------------------------
        CYFISNP_eProtState = CYFISNP_CON_MODE_TIMEOUT;
        CYFISNP_OutStr("\n\rPing Timeout, goto Connect Timeout. ");
        CYFISNP_spiSleep();
        return;
    }

    // -------------------------------------------------------------------
    // Send another Ping Request on next channel
    // -------------------------------------------------------------------
    nextNetCh();
    CYFISNP_SetChannel   (CYFISNP_bCurrentChannel);
    setHubSeed();
    CYFISNP_SetXactConfig(XACT_STATE_IDLE);     // Expect NO BCD
    CYFISNP_SetPtr       (&SNP_txBuf[0]);
    CYFISNP_StartTransmit(0, PKT_PING_LEN);
    while ((CYFISNP_State & CYFISNP_COMPLETE) == 0) {
        CYFISNP_GetTransmitState();
    }
    radioStateCopy = CYFISNP_State;
    CYFISNP_EndTransmit();

    // -------------------------------------------------------------------
    // If AutoAck PASSED, then resume Data Mode
    // -------------------------------------------------------------------
    if ((radioStateCopy & CYFISNP_ERROR) == 0) {
        setHubSeed();
        gotoDataMode();
    }
}


// ---------------------------------------------------------------------------
// nextNetCh() - Advance to next Data Channel (everything but Bind Mode)
// ---------------------------------------------------------------------------
static void nextNetCh(void)
{
    BYTE hop;
    hop = CYFISNP_EEP_NET_REC_ADR->chHop + 1;
    hop = (hop * 2) + (hop * 4);        // hop * 6 (help "lite" compiler)

    CYFISNP_bCurrentChannel += hop;

    if (CYFISNP_bCurrentChannel  > CYFISNP_CHAN_MAX) {
        CYFISNP_bCurrentChannel -= CYFISNP_MAX_CHANNELS;
    }
    while ((signed char)CYFISNP_bCurrentChannel < CYFISNP_CHAN_MIN) {
        CYFISNP_bCurrentChannel += hop;
    }
}


// ---------------------------------------------------------------------------
// rxMidEquNodeMid() - Compare the Rx MID with this Node's MID (from the radio)
// ---------------------------------------------------------------------------
static BOOL rxMidEquNodeMid(BYTE *pRxMid)
{
    BYTE *pNodeMid;
    char ivar;
    BYTE nodeMid[6];        // CYFISNP_GetFuses( void ) needs 6 Byte MID buffer

    CYFISNP_SetPtr(&nodeMid[0]);
    CYFISNP_SetLength(CYFISNP_SIZEOF_MID);
    CYFISNP_GetFuses();

    pNodeMid = &nodeMid[0];
    for (ivar = CYFISNP_SIZEOF_MID; *pNodeMid == *pRxMid && ivar != 0; --ivar) {
        ++pNodeMid;
        ++pRxMid;
    }
    return(ivar == 0);
}

// ---------------------------------------------------------------------------
// copyMidToTxPkt() - Copy Node MID to Bind or Connect Req Tx pkt area
// ---------------------------------------------------------------------------
static void copyMidToTxPkt(void)
{
    CYFISNP_SetPtr   (&SNP_txBuf[2]);
    CYFISNP_SetLength(CYFISNP_SIZEOF_MID);
    CYFISNP_GetFuses ();
}

// ---------------------------------------------------------------------------
//
// putNetParams() - Extract Network Params from BindRsp and put in FLASH
//
// ---------------------------------------------------------------------------
static void putNetParams(BYTE * pRxPkt)
{
    CYFISNP_EEP_NET_REC net;

    // -------------------------------------------------------------------
    // Compose RAM image to write to FLASH
    // -------------------------------------------------------------------
    net.devId       = pRxPkt[1];
    net.hubSeedMsb  = pRxPkt[6];
    net.hubSeedLsb  = pRxPkt[7];
    net.sopIdx      = pRxPkt[9] >> 3;
    net.chHop       = pRxPkt[9] & 7;            // Flash is {0-7}
    net.chBase      = pRxPkt[8];
    net.nodeSeedMsb = pRxPkt[6];
    net.nodeSeedLsb = pRxPkt[7] ^ pRxPkt[1];    // LSB Hub Seed ^ devId

    CYFISNP_OutStr("--Got netParams ");
    flashWrite((char *)&net);
}


// ---------------------------------------------------------------------------
//
// CYFISNP_Unbind()
//
// ---------------------------------------------------------------------------
void CYFISNP_Unbind(void)
{
    CYFISNP_EEP_NET_REC net;

    net.devId       = 0;            // ------------------------------------
    net.hubSeedMsb  = 0;            // Compose RAM image to write to FLASH
    net.hubSeedLsb  = 0;            // ------------------------------------
    net.sopIdx      = 0;
    net.chHop       = 0;
    net.chBase      = 0;
    net.nodeSeedMsb = 0;
    net.nodeSeedLsb = 0;

    CYFISNP_OutStr("--Unbinding...");
    flashWrite((char *)&net);
    CYFISNP_OutStr("Done. ");
    gotoUnboundMode();
}


// ---------------------------------------------------------------------------
//
// flashWrite() - Write RAM image to FLASH by possibly device-specific method
//
// ---------------------------------------------------------------------------

// Dummy function (for now)
BYTE CYFISNP_GetDieTemp(void)
{
// @PSoC_UserCode_DieTemp@ (Do not change this line.)
    return 20;
// @PSoC_UserCode_END@ (Do not change this line.)
}


#if HI_TECH_C
#pragma warning push
#pragma warning disable 350
#endif
static void flashWrite (BYTE *pSrc)
{
    // -----------------------------------------------------------------------
    // If this RAM image already exists in FLASH, then no need to write it
    // -----------------------------------------------------------------------
    {
        char ivar;
        const BYTE *pFlash;
        BYTE       *pRam;
        pRam   = pSrc;
        pFlash = (const BYTE *)CYFISNP_EEP_PHY_ADR;
        ivar = sizeof(CYFISNP_EEP_NET_REC);
        for (; ivar != 0 && *pRam++ == *pFlash++; --ivar);
        if (ivar == 0) {
            return;
        }
    }

    // -----------------------------------------------------------------------
    // Write the RAM image to FLASH
    // -----------------------------------------------------------------------
    CYFISNP_OutStr("--Writing to Flash...");
    {
//      struct {
//          BYTE   bARG_BlockId;           // block ID
//          BYTE  *pARG_FlashBuffer;       // flash buffer pointer - 2 bytes
//          CHAR   cARG_Temperature;       // die Temperature, -40 to 100
//          BYTE   bDATA_PWErase;          // Temporary storage (reserved)
//          BYTE   bDATA_PWProgram;        // Temporary storage (reserved)
//          BYTE   bDATA_PWMultiplier;     // Temporary storage (reserved)
//      } fwStruct;
        FLASH_WRITE_STRUCT fwStruct;

    #define CYFISNP_EEP_BLK_NUM ( CYFISNP_EEP_PHY_ADR / 0x40 )  // 64-Bytes/Flash Page

    #if (CYFISNP_FLASH_BLOCK_NUMBER_IS_WORD)
        fwStruct.wARG_BlockId     = CYFISNP_EEP_BLK_NUM;
    #else
        fwStruct.bARG_BlockId     = CYFISNP_EEP_BLK_NUM;
    #endif

        fwStruct.pARG_FlashBuffer = pSrc;
        fwStruct.cARG_Temperature = CYFISNP_GetDieTemp();
        if (bFlashWriteBlock((FLASH_WRITE_STRUCT*)&fwStruct) == 0) {
            while (1);      // Flash write failed, halt here
        }
    }
    CYFISNP_OutStr("Done. ");
}
#if HI_TECH_C
#pragma warning pop
#endif




// ---------------------------------------------------------------------------
//
// dynPaUpdate() - Based on AutoAck result, update GSK or 8DR statistic.
//
// ---------------------------------------------------------------------------
static void dynPaUpdate(BOOL ackResult)
{
    if (GFSK_INUSE) {
        dpwrQualGfsk = dpwrQualGfsk + ackResult
                   - ((dpwrQualGfsk + QUAL_ROUNDOFF) >> QUAL_KSHIFT);
    }
    else {
        dpwrQual8dr = dpwrQual8dr  + ackResult
                  - ((dpwrQual8dr + QUAL_ROUNDOFF) >> QUAL_KSHIFT);
    }
}



// ---------------------------------------------------------------------------
//
// dynPaApply() - Select desired power level and modulation for Tx packet
//
// ---------------------------------------------------------------------------
#define incSaturate(val)   (val = (val<QUAL_CONSEC_MAX) ? val+1 : val)
static void dynPaApply(void)
{
    // -----------------------------------------------------------------------
    // Track how long each statistic has been at QUAL_MAX
    // -----------------------------------------------------------------------
    if (dpwrQualGfsk == QUAL_MAX) {
        incSaturate(dpwrMaxConsecGfsk);     // ++counter to QUAL_CONSEC_MAX
    } else {
        dpwrMaxConsecGfsk = 0;
    }
    if (dpwrQual8dr  == QUAL_MAX) {
        incSaturate(dpwrMaxConsec8dr);      // ++counter to QUAL_CONSEC_MAX
    } else {
        dpwrMaxConsec8dr = 0;
    }

    // -----------------------------------------------------------------------
    // If both statistics are QUAL_MAX for QUAL_CONSEC_MAX, then reduce PA
    // -----------------------------------------------------------------------
    if ((dpwrQualGfsk == QUAL_MAX && dpwrMaxConsecGfsk == QUAL_CONSEC_MAX)
     && (dpwrQual8dr  == QUAL_MAX && dpwrMaxConsec8dr  == QUAL_CONSEC_MAX)) {
        decPaLevel();
        dpwrMaxConsecGfsk = dpwrMaxConsec8dr = 0;
    }

    // -----------------------------------------------------------------------
    // Else if both statistics "stink", then PA = MAX
    // -----------------------------------------------------------------------
    else if (dpwrQualGfsk < QUAL_THRESHOLD && dpwrQual8dr < QUAL_THRESHOLD) {
        setMaxPaLevel();
    }

    // -----------------------------------------------------------------------
    // Pick the Data Rate with the best statistic, favor GFSK
    // -----------------------------------------------------------------------
    if (--dpwrStayCt == 0) {
        toggleDataRate();                       // CHANGE MODULATION
        if (dpwrQualGfsk >= QUAL_THRESHOLD) {       // GFSK=HI, 8DR=dont-care
            dpwrStayCt = GFSK_INUSE ? 4 : 1;        // 4 GFSK : 1 8DR
        }
        else if  (dpwrQual8dr >= QUAL_THRESHOLD) {  // GFSK=LO, 8DR=HI
            dpwrStayCt = GFSK_INUSE ? 1 : 4;        // 1 GFSK : 4 8DR
        }
        else {                                      // GFSK=LO, 8DR=LO
            dpwrStayCt = GFSK_INUSE ? 1 : 1;        // 1 GFSK : 1 8DR
        }
    }

//  // DEBUG stuff only compiles if CYFISNP_DEBUG is defined
//  CYFISNP_OutStr(" <dynPA:");
//  CYFISNP_OutHex(CYFISNP_GetQualGfsk());              // GFSK quality
//  CYFISNP_OutHex(CYFISNP_GetQual8dr());               // 8DR quality
//  CYFISNP_OutChar((CYFISNP_radioTxConfig & 8) ? '.' : 'G'); // (.)8DR or (G)GFSK
//  CYFISNP_OutNibble(CYFISNP_paLevel);                 // PA Level
//  CYFISNP_OutNibble(CYFISNP_Read(CYFISNP_TX_CFG_ADR) & 7);  // Radio PA Level
//  CYFISNP_OutStr(">");
}

// ---------------------------------------------------------------------------
//
// toggleDataRate() - Toggle between GFSK and 8DR
//
// ---------------------------------------------------------------------------
static void toggleDataRate(void)
{
    if (GFSK_INUSE) {
        CYFISNP_radioTxConfig &= ~CYFISNP_TX_DATMODE_MSK;
        CYFISNP_radioTxConfig |=  CYFISNP_DATMODE_8DR;
        CYFISNP_Write(CYFISNP_ANALOG_CTRL_ADR, 0);  // Disable all slow
    }
    else {  // 8DR Used
        CYFISNP_radioTxConfig &= ~CYFISNP_TX_DATMODE_MSK;
        CYFISNP_radioTxConfig |=  CYFISNP_DATMODE_1MBPS;
        CYFISNP_Write(CYFISNP_ANALOG_CTRL_ADR, CYFISNP_ALLSLOW);
    }
    writeHwPa();
}


// ---------------------------------------------------------------------------
// setMaxPaLevel() - Set Maximum Tx power
// ---------------------------------------------------------------------------
static void setMaxPaLevel(void)
{
    setPaLevel(PA_LEVEL_MAX);
}

// ---------------------------------------------------------------------------
// setBindPaLevel() - Possibly set lower Tx power for Bind Request
// ---------------------------------------------------------------------------
static void setBindPaLevel(void)
{
    setPaLevel(CYFISNP_PA_LEVEL_BIND);
}


// ---------------------------------------------------------------------------
// setPaLevel() - Set Tx power and assume everything's OK
// ---------------------------------------------------------------------------
static void setPaLevel(BYTE paLevel)
{
    CYFISNP_paLevel = paLevel;
    writeHwPa();

    dpwrQualGfsk = QUAL_MAX;    // Quality metric at MAX (assume we're OK)
    dpwrQual8dr  = QUAL_MAX;    // Quality metric at MAX (assume we're OK)

    dpwrMaxConsecGfsk = 0;      // Zero consecutive counters
    dpwrMaxConsec8dr  = 0;      // Zero consecutive counters
    dpwrStayCt = 1;             // Will start toggling
}

// ---------------------------------------------------------------------------
// decPaLevel() - Metrics are good, try decreasing Tx power
// ---------------------------------------------------------------------------
static void decPaLevel(void)
{
    if (CYFISNP_paLevel == PA_LEVEL_MIN) {
        return;
    }
#ifndef TEST_DISABLE_DYNAMIC_PA
    --CYFISNP_paLevel;
#endif
    writeHwPa();
}


// ---------------------------------------------------------------------------
// writeHwPa() - Write PA Level to hardware
// ---------------------------------------------------------------------------
static void writeHwPa(void)
{
    BYTE regVal = CYFISNP_PA_PHY_TBL[CYFISNP_paLevel]
                & CYFISNP_PA_VAL_MSK;

#if (CYFISNP_EXTERNAL_PA)
    BOOL paOn = ((CYFISNP_PA_PHY_TBL[CYFISNP_paLevel] & 0xF0) != 0);
    if (paOn )      externalPaEnable();
    else            externalPaDisable();
#endif

    CYFISNP_SetTxConfig(CYFISNP_radioTxConfig + regVal);
}


// If external PA hardware is installed (either Disabled or Enabled)
#if (CYFISNP_EXTERNAL_PA)
// ---------------------------------------------------------------------------
//
// externalPaEnable()  - Enable  external PA
// externalPaDisable() - Disable external PA
//
// ---------------------------------------------------------------------------
static void externalPaEnable(void)
{
    char regVal;
    // -----------------------------------------------------------------------
    // PACTL_pin = PACTL Function
    // -----------------------------------------------------------------------
    regVal  =  CYFISNP_Read(CYFISNP_IO_CFG_ADR);
    regVal &= ~CYFISNP_PACTL_GPIO;
    CYFISNP_Write(CYFISNP_IO_CFG_ADR, regVal);

    // -----------------------------------------------------------------------
    //  XOUT_pin = ~PACTL Function (inverse of PACTL)
    // -----------------------------------------------------------------------
    regVal  =  CYFISNP_Read(CYFISNP_XTAL_CTRL_ADR);
    regVal &= ~CYFISNP_XOUT_FNC_MSK;
    regVal |=  CYFISNP_XOUT_FNC_PA_N;
    CYFISNP_Write(CYFISNP_XTAL_CTRL_ADR, regVal);
}

static void externalPaDisable(void)
{
    char regVal;

//  // -----------------------------------------------------------------------
//  // Values for PACTL and XOUT when configured for Vendor_A GPIO
//  // PACTL = GPIO = 0 (no power for External PA)
//  //  XOUT = GPIO = 1 (connect Radio directly to antenna)
//  // -----------------------------------------------------------------------
//  regVal  =  CYFISNP_Read(CYFISNP_GPIO_CTRL_ADR);
//  regVal |=  CYFISNP_XOUT_OP;                 //  XOUT = 1
//  regVal &= ~CYFISNP_PACTL_OP;                // PACTL = 0
//  CYFISNP_Write(CYFISNP_GPIO_CTRL_ADR, regVal);

    // -----------------------------------------------------------------------
    //  PACTL_pin = GPIO Function  (= LOW)
    // -----------------------------------------------------------------------
    regVal  = CYFISNP_Read(CYFISNP_IO_CFG_ADR);
    regVal |= CYFISNP_PACTL_GPIO;
    CYFISNP_Write(CYFISNP_IO_CFG_ADR, regVal);

    // -----------------------------------------------------------------------
    //  XOUT_pin = GPIO Function (= HIGH)
    // -----------------------------------------------------------------------
    regVal  =  CYFISNP_Read(CYFISNP_XTAL_CTRL_ADR);
    regVal &= ~CYFISNP_XOUT_FNC_MSK;
    regVal |=  CYFISNP_XOUT_FNC_GPIO;
    CYFISNP_Write(CYFISNP_XTAL_CTRL_ADR, regVal);
}
#endif //  #if (CYFISNP_EXTERNAL_PA)


#if (CYFISNP_PWR_TYPE != CYFISNP_PWR_WALL)
// ---------------------------------------------------------------------------
//
// CYFISNP_spiSleep() - Minimize LRADIO power
//
//  This disconnects SPI, so you can't communicate with the Radio until
//   subsequently calling CYFISNP_spiWake().
//
// ---------------------------------------------------------------------------
static BYTE old_XtalCtrlAdr;
static BYTE old_IoCfgAdr;
static BYTE old_GpioCtrlAdr;
static BYTE old_XactCfgAdr;
static BOOL spiSleeping;

void CYFISNP_spiSleep(void)
{
    if (spiSleeping == TRUE) {
        return;
    }
    spiSleeping = TRUE;

    // -----------------------------------------------------------------------
    // Save CYFISPI settings so they can be restored via CYFISNP_spiWake()
    // -----------------------------------------------------------------------
    old_XtalCtrlAdr = CYFISNP_Read(CYFISNP_XTAL_CTRL_ADR);
    old_IoCfgAdr    = CYFISNP_Read(CYFISNP_IO_CFG_ADR);
    old_XactCfgAdr  = CYFISNP_GetXactConfig();
    old_GpioCtrlAdr = CYFISNP_Read(CYFISNP_GPIO_CTRL_ADR);
#if (CYFISNP_EXTERNAL_PA)
    old_GpioCtrlAdr |=  CYFISNP_XOUT_OP;       //  XOUT = 1
    old_GpioCtrlAdr &= ~CYFISNP_PACTL_OP;      // PACTL = 0
#endif

    // -----------------------------------------------------------------------
    // If RADIO is not sleeping, then manually FORCE to sleep
    //  (if it's already asleep, then don't wakeup just to put it to sleep).
    // -----------------------------------------------------------------------
    if ((old_XactCfgAdr&CYFISNP_END_STATE_MSK) != CYFISNP_END_STATE_SLEEP) {
        CYFISNP_ForceState(0);
    }

    // -----------------------------------------------------------------------
    // Since Radio could be operating on lower voltage than CPU, drive
    //  {MOSI,SCK,nSS} CPU outputs LOW to stop leakage from CPU to RADIO power
    //
    // Set XOUT LOW by setting to GPIO to minimize SPI/Radio current.
    // Set MISO LOW by changing to GPIO to keep from floating.
    // Set MOSI LOW by ensuring MISO is LOW during final SPI operation
    // -----------------------------------------------------------------------
    CYFISNP_Write(CYFISNP_XTAL_CTRL_ADR,
                  CYFISNP_XOUT_FNC_GPIO);           // XOUT=GPIO
    CYFISNP_Write(CYFISNP_IO_CFG_ADR, 0x42);        // SPI3PIN & MISO GPIO
                    // MISO goes LOW because that's MISO_GPIO's default
    CYFISNP_Write(CYFISNP_GPIO_CTRL_ADR ,0x00);     // XOUT=0 and leave MISO=0
                    // MOSI ends LOW because MISO[7] was 0 during last Write
    CYFISNP_RADIO_SELECT;
    // SPI NOT FUNCTIONAL UNTIL CYFISNP_spiWake() IS CALLED
}

// ---------------------------------------------------------------------------
//
// CYFISNP_spiWake() - Restore normal Radio operation,
//                              Called to exit CYFISNP_spiSleep().
//
// ---------------------------------------------------------------------------
void CYFISNP_spiWake(void)
{
    if (spiSleeping == FALSE) {
        return;
    }
    spiSleeping = FALSE;
	CYFISNP_RADIO_DESELECT;
    CYFISNP_Write(CYFISNP_IO_CFG_ADR,    old_IoCfgAdr);     // Restore SPI3PIN
    CYFISNP_Write(CYFISNP_GPIO_CTRL_ADR, old_GpioCtrlAdr);  // Restore GPIO
    CYFISNP_Write(CYFISNP_XTAL_CTRL_ADR, old_XtalCtrlAdr);  // Restore XOUT FN

    if ((old_XactCfgAdr&CYFISNP_END_STATE_MSK) != CYFISNP_END_STATE_SLEEP) {
        CYFISNP_ForceState(old_XactCfgAdr);          // Restore radio state
    }
}
#endif // (CYFISNP_PWR_TYPE != CYFISNP_PWR_WALL)


// ---------------------------------------------------------------------------
//
// netParamsPresent() - Determine currently Bound
//                          A valid hubSeedMsb is never 0x00
//
// ---------------------------------------------------------------------------
static BOOL netParamsPresent (void) {
    if (CYFISNP_EEP_NET_REC_ADR->hubSeedMsb != 0) {
        return(TRUE);
    }
    return(FALSE);
}

// ---------------------------------------------------------------------------
// crc0AutoAck() - Disable and enable autoacks for CRC0 packets.
//
//  When transmitting w/CRC0, we expect an AutoAck (e.g. Bind/ParamReq).
//  When receiving w/CRC0, we don't want to return an AutoAck (e.g. Beacon)
// ---------------------------------------------------------------------------
static void crc0AutoAck(BOOL enable) {
    if (enable == TRUE) {
        CYFISNP_Write(CYFISNP_RX_OVERRIDE_ADR, 0);
    } else {
        CYFISNP_Write(CYFISNP_RX_OVERRIDE_ADR, CYFISNP_DIS_CRC0);
    }
}


BYTE CYFISNP_GetQualGfsk(void) {        // Debug access for API
    return (dpwrQualGfsk);
}
BYTE CYFISNP_GetQual8dr(void) {         // Debug access for API
    return(dpwrQual8dr);
}
// ###########################################################################
