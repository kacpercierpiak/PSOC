                        .module cyfisnp_protocol.c
                        .area text(rom, con, rel)
 0000                   .dbfile lib/cyfisnp_protocol.c
                        .area lit(rom, con, rel, lit)
 0000           _CYFISNP_PA_PHY_TBL::
 0000 0001              .byte 0,1
 0002 0203              .byte 2,3
 0004 0405              .byte 4,5
 0006 0606              .byte 6,6
 0008                   .dbfile D:\Studia\PSOC\RF_I2C_BRIDGE\RF_I2C_BRIDGE\lib\CYFISNP_Config.h
 0008                   .dbsym e CYFISNP_PA_PHY_TBL _CYFISNP_PA_PHY_TBL A[8:8]kc
 0008           _CYFISNP_BIND_CH_SEQ::
 0008 0A0E              .byte 10,14
 000A 1F2E              .byte 31,46
 000C 383A              .byte 56,58
 000E                   .dbsym e CYFISNP_BIND_CH_SEQ _CYFISNP_BIND_CH_SEQ A[6:6]kc
                        .area text(rom, con, rel)
 0000                   .dbfile D:\Studia\PSOC\RF_I2C_BRIDGE\RF_I2C_BRIDGE\lib\CYFISNP_Config.h
 0000                   .dbfile D:\Studia\PSOC\RF_I2C_BRIDGE\RF_I2C_BRIDGE\lib\cyfisnp_protocol.c
 0000                   .dbfunc s setNodeSeed _setNodeSeed fV
 0000           _setNodeSeed:
 0000                   .dbline -1
 0000                   .dbline 328
 0000           ; //*****************************************************************************
 0000           ; //*****************************************************************************
 0000           ; //  FILENAME: CYFISNP_Protocol.c
 0000           ; //  Version: 2.00, Updated on 2015/3/4 at 22:21:19
 0000           ; //  Generated by PSoC Designer 5.4.3191
 0000           ; //
 0000           ; //  DESCRIPTION: <NODE> Star Network Protocol Protocol implementation
 0000           ; //-----------------------------------------------------------------------------
 0000           ; //  Copyright (c) Cypress Semiconductor 2015. All Rights Reserved.
 0000           ; //*****************************************************************************
 0000           ; //*****************************************************************************
 0000           ; 
 0000           ; #define CYFISNP_PROTOCOL_C
 0000           ; 
 0000           ; #include <m8c.h>        // part specific constants and macros
 0000           ; #include <FlashBlock.h>
 0000           ; #include "PSoCAPI.h"    // PSoC API definitions for all User Modules
 0000           ; #include "psocGpioInt.h"
 0000           ; #include "CYFISNP.h"
 0000           ; 
 0000           ; #define NO_RX_PACKET    CYFISNP_ABORT_SUCCESS     // Better name
 0000           ; 
 0000           ; #define CYFISNP_nSS_IS_PPSOC_FN (0x18 > 100)
 0000           ; 
 0000           ; // ---------------------------------------------------------------------------
 0000           ; // Calculate the battery powered node's "Response Delay" (dominated by CPU_CLK)
 0000           ; //  This is passed in the BindRequest so the can delay Responses as needed.
 0000           ; //  RULE: HUB IS NEVER SLOWER THAN THE NODE (the node is presumed battery
 0000           ; //        powered and establishes the response time that the hub must meet,
 0000           ; //        it's not negotiated).
 0000           ; // ---------------------------------------------------------------------------
 0000           ; #if   (CYFISNP_CPU_CLK == 24)
 0000           ;     #define SNP_RSP_DELAY   (160/10)    // 160 uS
 0000           ; #elif (CYFISNP_CPU_CLK == 12)
 0000           ;     #define SNP_RSP_DELAY   (280/10)    // 280 uS
 0000           ; #elif (CYFISNP_CPU_CLK == 6)
 0000           ;     #define SNP_RSP_DELAY   (450/10)    // 450 uS
 0000           ; #elif (CYFISNP_CPU_CLK == 3)
 0000           ;     #define SNP_RSP_DELAY   (830/10)    // 830 uS
 0000           ; #else
 0000           ;     // ERROR - CPU CLOCK TOO SLOW FOR CYFISNP
 0000           ;     // DRC should generate this warning
 0000           ;     #define SNP_RSP_DELAY (830/10)    // Dirty workaround to allow compilation with default parameters
 0000           ; #endif
 0000           ; 
 0000           ; //#define TEST_DISABLE_DYNAMIC_PA       // (testing only)
 0000           ; 
 0000           ; 
 0000           ; // ---------------------------------------------------------------------------
 0000           ; // SNP PACKET HEADERS
 0000           ; // ---------------------------------------------------------------------------
 0000           ; #define PKT_PING_TYPE       0x00
 0000           ; #define PKT_PING_LEN        2       // Protocol + DevID
 0000           ; 
 0000           ; #define PKT_BINDREQ_TYPE    0x00
 0000           ; #define PKT_BINDREQ_LEN     7
 0000           ; 
 0000           ; #define PKT_BINDRSP_TYPE    0x10
 0000           ; #define PKT_BINDRSP_LEN     10
 0000           ; 
 0000           ; #define PKT_CONREQ_TYPE    0x00
 0000           ; #define PKT_CONREQ_LEN     6
 0000           ; 
 0000           ; #define PKT_CONRSP_TYPE    0x10
 0000           ; #define PKT_CONRSP_LEN     6
 0000           ; 
 0000           ; #define PKT_UNBIND_TYPE     0x10
 0000           ; #define PKT_UNBIND_LEN      2
 0000           ; 
 0000           ; #define PKT_SEQBIT_MASK     0x03
 0000           ; #define PKT_SEQSYNC         0x02
 0000           ; #define PKT_DATA_FCD_TYPE   0x20
 0000           ; #define PKT_DATA_BCD_TYPE   0x30
 0000           ; #define PKT_BCDR_MASK       0x04
 0000           ; 
 0000           ; 
 0000           ; // ---------------------------------------------------------------------------
 0000           ; //
 0000           ; // PUBLIC VARIABLES
 0000           ; //
 0000           ; // ---------------------------------------------------------------------------
 0000           ; CYFISNP_PROT_STATE  CYFISNP_eProtState;
 0000           ; 
 0000           ; BYTE CYFISNP_bCurrentChannel;
 0000           ; 
 0000           ; 
 0000           ; // ---------------------------------------------------------------------------
 0000           ; // CYFISNP_txBuf - Holds Tx Packets, ONLY for Private Protocol use
 0000           ; // ---------------------------------------------------------------------------
 0000           ; #define SNP_PROT_PKT_TX_MAX 7                   // Largest Tx Protocol Packet
 0000           ; #define SNP_PROT_PKT_RX_MAX 10                  // Largest Rx Protocol Packet
 0000           ; static BYTE SNP_txBuf[SNP_PROT_PKT_TX_MAX];
 0000           ; 
 0000           ; // ---------------------------------------------------------------------------
 0000           ; // PHYSICAL_BCD_PACKET_MAX = biggest physical BCD buffer required.
 0000           ; // ---------------------------------------------------------------------------
 0000           ; #if CYFISNP_BCD_PAYLOAD_MAX >= SNP_PROT_PKT_RX_MAX
 0000           ; #define PHYSICAL_BCD_PACKET_MAX     (CYFISNP_BCD_PAYLOAD_MAX + 1)
 0000           ; #else
 0000           ; #define PHYSICAL_BCD_PACKET_MAX     SNP_PROT_PKT_RX_MAX
 0000           ; #endif
 0000           ; 
 0000           ; // ---------------------------------------------------------------------------
 0000           ; // RX_PKT - Holds Rx Packets, shared between API and Private Protocol use
 0000           ; // ---------------------------------------------------------------------------
 0000           ; typedef union {
 0000           ;     struct {            // Structure passed to API
 0000           ;         BYTE length;
 0000           ;         BYTE rssi;
 0000           ;         BYTE type;
 0000           ;         BYTE devId;
 0000           ;         BYTE payload[CYFISNP_BCD_PAYLOAD_MAX]; // Holds Rx API pkt
 0000           ;     } api;
 0000           ;     struct {            // Structure passed from Radio
 0000           ;         BYTE length;
 0000           ;         BYTE rssi;
 0000           ;         BYTE devId;
 0000           ;         BYTE pkt[SNP_PROT_PKT_RX_MAX];      // Holds Rx protocol packet
 0000           ;     } snp;
 0000           ; } SNP_RX_PKT;
 0000           ; static SNP_RX_PKT  SNP_rxBuf;
 0000           ; 
 0000           ; 
 0000           ; // ---------------------------------------------------------------------------
 0000           ; //
 0000           ; // Dynamic DataRate and Dynamic PA
 0000           ; //
 0000           ; // ---------------------------------------------------------------------------
 0000           ; 
 0000           ; 
 0000           ; BYTE CYFISNP_radioTxConfig;        // [4:3] = GFSK or 8DR
 0000           ; // GFSK_INUSE - macro to check whether GFSK is currently specified
 0000           ; #define GFSK_INUSE ((CYFISNP_radioTxConfig   \
 0000           ;                    & CYFISNP_TX_DATMODE_MSK) \
 0000           ;                   == CYFISNP_DATMODE_1MBPS)
 0000           ; // --------------------------
 0000           ; BYTE CYFISNP_paLevel;              // logical PA level
 0000           ; #define PA_LEVEL_MAX 7
 0000           ; #define PA_LEVEL_MIN 0
 0000           ; 
 0000           ; 
 0000           ; // -----------------------------------------------------------------------
 0000           ; // GFSK (dpwrQualGfsk) and 8DR (dpwrQual8dr) channel quality metrics.
 0000           ; //   these are driven by each transmission AutoAck success or failure.
 0000           ; // -----------------------------------------------------------------------
 0000           ; #define QUAL_KSHIFT       3
 0000           ; #define QUAL_KVAL       (1<<QUAL_KSHIFT)
 0000           ; #define QUAL_ROUNDOFF   (QUAL_KVAL-1)           // round-off so 0 is possible
 0000           ; #define QUAL_MAX       ((QUAL_KVAL * QUAL_KVAL) - QUAL_ROUNDOFF)
 0000           ; #define QUAL_AVE        (QUAL_MAX /2)
 0000           ; #define QUAL_THRESHOLD  (QUAL_MAX * 0.70)
 0000           ; static BYTE         dpwrQualGfsk;
 0000           ; static BYTE         dpwrQual8dr;
 0000           ; 
 0000           ; // -----------------------------------------------------------------------
 0000           ; // QUAL_CONSEC_MAX - Number of consecutive transmissions at MAX metric before
 0000           ; //                   Tx power is reduced by 1 step.
 0000           ; // -----------------------------------------------------------------------
 0000           ; #define QUAL_CONSEC_MAX 8
 0000           ; static BYTE         dpwrMaxConsecGfsk;
 0000           ; static BYTE         dpwrMaxConsec8dr;
 0000           ; static char         dpwrStayCt;
 0000           ; 
 0000           ; 
 0000           ; 
 0000           ; // ---------------------------------------------------------------------------
 0000           ; //
 0000           ; // PRIVATE VARIABLES
 0000           ; //
 0000           ; // ---------------------------------------------------------------------------
 0000           ; static BOOL         fTsb;       // Transmit Sequence Bit
 0000           ; static BOOL         fEsb;       // Expected Sequence Bit
 0000           ; 
 0000           ; static BOOL         rxBufPend;
 0000           ; 
 0000           ; static RADIO_STATE  radioStateCopy;
 0000           ; static BYTE         rxLen;
 0000           ; 
 0000           ; 
 0000           ; // ---------------------------------------------------------------------------
 0000           ; // CYFISNP_IdleReceive
 0000           ; //      XACT_STATE_SYNTH - CYFISNP_XACT_CFG_ADR settings when in SYNTH
 0000           ; //      XACT_STATE_IDLE1 - CYFISNP_XACT_CFG_ADR settings when in IDLE
 0000           ; //      XACT_STATE_IDLE2 - CYFISNP_XACT_CFG_ADR settings when in IDLE
 0000           ; //
 0000           ; //
 0000           ; //  wall-powered            battery-powered
 0000           ; //   IDLE = SYNTH           tx->idle1->idle2
 0000           ; // ---------------------------------------------------------------------------
 0000           ; 
 0000           ; static BOOL idleReceive;            // TRUE = Idle Radio in Rx, not Sleep
 0000           ; #define XACT_COMMON         (CYFISNP_ACK_EN | CYFISNP_ACK_TO_8X)
 0000           ; #define XACT_STATE_SYNTH    (XACT_COMMON    | CYFISNP_END_STATE_RXSYNTH)
 0000           ; #define XACT_STATE_IDLE     (XACT_COMMON    | CYFISNP_END_STATE_IDLE)
 0000           ; #define XACT_STATE_SLEEP    (XACT_COMMON    | CYFISNP_END_STATE_SLEEP)
 0000           ; 
 0000           ; 
 0000           ; 
 0000           ; // ---------------------------------------------------------------------------
 0000           ; // CYFISNP_DATA_PACKET_RETRIES - Max Tx data attempts before Timeout
 0000           ; // ---------------------------------------------------------------------------
 0000           ; #define CYFISNP_DATA_PACKET_RETRIES 10
 0000           ; static BYTE         bDataRetryCt;
 0000           ; static CYFISNP_API_PKT *pTxStruct;
 0000           ; static BOOL         txPending;
 0000           ; 
 0000           ; 
 0000           ; 
 0000           ; // ---------------------------------------------------------------------------
 0000           ; // Response Window - How long to wait for a Response to a Request
 0000           ; // ---------------------------------------------------------------------------
 0000           ; #if CYFISNP_PWR_TYPE == CYFISNP_PWR_COIN
 0000           ; #define RSP_WINDOW_TIMER   (3000/200)               //  3 mS
 0000           ; #else                                               //
 0000           ; #define RSP_WINDOW_TIMER   (50/CYFISNP_TIMER_UNITS)     // 50 mS
 0000           ; #endif
 0000           ; static WORD     rspWindowTimer;                     // Response Window Timer
 0000           ; 
 0000           ; 
 0000           ; // ---------------------------------------------------------------------------
 0000           ; // onChanTxLeft - How many Connect Requests to send before changing channels.
 0000           ; // ---------------------------------------------------------------------------
 0000           ; #define ON_NEW_CHAN_TX_MAX  1       // Retry count if no AutoAck
 0000           ; #define ON_ACK_CHAN_TX_MAX  (10-1)  // Retry count if AutoAck
 0000           ; static BYTE     onChanTxLeft;
 0000           ; static BOOL     fGotChanAck;
 0000           ; 
 0000           ; #define CON_MODE_COUNT_MAX  200     // Max # Con Req to send before timeout
 0000           ; #define PING_MODE_COUNT_MAX 200     // Max # PingReq to send before timeout
 0000           ; static WORD     wModeCounter;
 0000           ; 
 0000           ; static WORD wModeDelay;
 0000           ; #define CON_MODE_FAST_TIME  (1/CYFISNP_TIMER_UNITS)
 0000           ; #define CON_MODE_SLOW_TIME  (200/CYFISNP_TIMER_UNITS)
 0000           ; #define PING_MODE_FAST_TIME (1/CYFISNP_TIMER_UNITS)
 0000           ; #define PING_MODE_SLOW_TIME (200/CYFISNP_TIMER_UNITS)
 0000           ; 
 0000           ; 
 0000           ; 
 0000           ; // ---------------------------------------------------------------------------
 0000           ; //
 0000           ; // Binding variables
 0000           ; //
 0000           ; // ---------------------------------------------------------------------------
 0000           ; 
 0000           ; static char bindChIdx;
 0000           ; 
 0000           ; // ---------------------------------------------------------------------------
 0000           ; // RX_WINDOW - Max time to wait for a Hub Bind Respone.
 0000           ; // ---------------------------------------------------------------------------
 0000           ; #define CYFISNP_RX_WINDOW   (3000 / 100)    // 3 mS (via 100 uS delay loop)
 0000           ; 
 0000           ; // ---------------------------------------------------------------------------
 0000           ; // BIND_MODE_COUNT_MAX - Number of Bind Requests sent before TIMEOUT
 0000           ; // ---------------------------------------------------------------------------
 0000           ; #define BIND_MODE_COUNT_MAX  500        // Give Hub time to write its Flash
 0000           ; static WORD wBindModeCounter;
 0000           ;     // ------------------------------------------------------------------------
 0000           ;     // bindReqTimer - Throttle BindReq to something reasonable (20 mS)
 0000           ;     //   If send as fast as possible, application may be sending every 2 mS and
 0000           ;     //   we'll burn-through BIND_MODE_COUNT_MAX so fast the person may not
 0000           ;     //   have time to move and push bind button on hub.
 0000           ;     // ------------------------------------------------------------------------
 0000           ; static WORD bindReqTimer;
 0000           ; #define BIND_REQ_TIME   (1 + 10/CYFISNP_TIMER_UNITS) // 10mS or 1 tick
 0000           ; 
 0000           ; 
 0000           ; 
 0000           ; // ---------------------------------------------------------------------------
 0000           ; //
 0000           ; // Wall Powered Node: Beacon Timeout Timer
 0000           ; //
 0000           ; // ---------------------------------------------------------------------------
 0000           ; #define BEACON_MAX_TIME     (3000 / CYFISNP_TIMER_UNITS)
 0000           ; static WORD beaconMaxTimer;
 0000           ; 
 0000           ; static BOOL CYFISNP_inRxGo;
 0000           ; 
 0000           ; 
 0000           ; // ---------------------------------------------------------------------------
 0000           ; //
 0000           ; // LOCAL FUNCTIONS
 0000           ; //
 0000           ; // ---------------------------------------------------------------------------
 0000           ; static void runConnectMode      (void);
 0000           ; static void gotoDataMode        (void);
 0000           ; static void runDataMode         (void);
 0000           ; static void runDataModeTx       (void);
 0000           ; static void runDataModeRx       (void);
 0000           ; static void runDataModeRxCrc0   (void);
 0000           ; static void gotoPingMode        (void);
 0000           ; static void runPingMode         (void);
 0000           ; static void gotoUnboundMode     (void);
 0000           ; static void gotoDefaultMode     (void);
 0000           ; // -----------------------------------
 0000           ; static void nextNetCh           (void);
 0000           ; static void putNetParams        (BYTE * pConRspPkt);
 0000           ; static void copyMidToTxPkt      (void);
 0000           ; static BOOL rxMidEquNodeMid     (BYTE *pRxMid);
 0000           ; // -----------------------------------
 0000           ; static void setMaxPaLevel       (void);
 0000           ; static void setPaLevel          (BYTE paLevel);
 0000           ; static void writeHwPa           (void);
 0000           ; static void decPaLevel          (void);
 0000           ; static void dynPaApply          (void);
 0000           ; static void dynPaUpdate         (BOOL ackResult);
 0000           ; static void toggleDataRate      (void);
 0000           ; static void externalPaDisable   (void);
 0000           ; static void externalPaEnable    (void);
 0000           ; static void issueRxGo           (void);
 0000           ; // -----------------------------------
 0000           ; static void gotoConnectModeBase (void);
 0000           ; static void gotoConnectMode     (void);
 0000           ; static void setBindPaLevel      (void);
 0000           ; static void bindRun             (void);
 0000           ; static BOOL netParamsPresent    (void);
 0000           ; static void crc0AutoAck         (BOOL enable);
 0000           ; 
 0000           ; static void setIdleReceive      (BOOL enable);
 0000           ; 
 0000           ; 
 0000           ; 
 0000           ; // -----------------------------------
 0000           ; static void flashWrite          (BYTE *pSrc);
 0000           ; // ---------------------------------------------------------------------------
 0000           ; 
 0000           ; 
 0000           ; static void setNodeSeed(void) {
 0000                   .dbline 329
 0000           ;     CYFISNP_SetCrcSeed ((CYFISNP_EEP_NET_REC_ADR->nodeSeedMsb << 8)
 0000 503F              mov A,63
 0002 10                push X
 0003 57C7              mov X,-57
 0005 28                romx
 0006 20                pop X
 0007 5300              mov [__r0],A
 0009 503F              mov A,63
 000B 10                push X
 000C 57C6              mov X,-58
 000E 28                romx
 000F 08                push A
 0010 5100              mov A,[__r0]
 0012 20                pop X
 0013 7C0000            xcall _CYFISNP_SetCrcSeed
 0016 20                pop X
 0017                   .dbline -2
 0017           L9:
 0017                   .dbline 0 ; func end
 0017 7F                ret
 0018                   .dbend
 0018                   .dbfunc s setHubSeed _setHubSeed fV
 0018           _setHubSeed:
 0018                   .dbline -1
 0018                   .dbline 332
 0018           ;                                | (CYFISNP_EEP_NET_REC_ADR->nodeSeedLsb     ));
 0018           ; }
 0018           ; static void setHubSeed(void) {
 0018                   .dbline 333
 0018           ;     CYFISNP_SetCrcSeed ((CYFISNP_EEP_NET_REC_ADR->hubSeedMsb << 8)
 0018 503F              mov A,63
 001A 10                push X
 001B 57C4              mov X,-60
 001D 28                romx
 001E 20                pop X
 001F 5300              mov [__r0],A
 0021 503F              mov A,63
 0023 10                push X
 0024 57C3              mov X,-61
 0026 28                romx
 0027 08                push A
 0028 5100              mov A,[__r0]
 002A 20                pop X
 002B 7C0000            xcall _CYFISNP_SetCrcSeed
 002E 20                pop X
 002F                   .dbline -2
 002F           L10:
 002F                   .dbline 0 ; func end
 002F 7F                ret
 0030                   .dbend
 0030                   .dbfunc e CYFISNP_Start _CYFISNP_Start fc
 0030           _CYFISNP_Start::
 0030                   .dbline -1
 0030                   .dbline 345
 0030           ;                                | (CYFISNP_EEP_NET_REC_ADR->hubSeedLsb     ));
 0030           ; }
 0030           ; 
 0030           ; 
 0030           ; 
 0030           ; // ---------------------------------------------------------------------------
 0030           ; //
 0030           ; // CYFISNP_Start() - Powerup initialization (Radio powers-up in IDLE)
 0030           ; //
 0030           ; // ---------------------------------------------------------------------------
 0030           ; BYTE CYFISNP_Start(void)
 0030           ; {
 0030                   .dbline 346
 0030           ;     if (CYFISNP_eProtState != 0
 0030 3C3B00            cmp [_CYFISNP_eProtState],0
 0033 A00A              jz L12
 0035 3C3B50            cmp [_CYFISNP_eProtState],80
 0038 A005              jz L12
 003A                   .dbline 348
 003A           ;      && CYFISNP_eProtState != CYFISNP_STOP_MODE) {
 003A           ;         return 0;         // START only works at powerup and from STOP
 003A                   .dbline 348
 003A 5000              mov A,0
 003C 804A              xjmp L11
 003E           L12:
 003E                   .dbline 352
 003E           ;     }
 003E           ; 
 003E           ; #if(CYFISNP_PSOC_EXPRESS_PROJECT == 0)
 003E           ;     CYFISNP_SleepTimer_Set64Hz();
 003E 10                push X
 003F 7C0000            xcall _CYFISNP_SleepTimer_Set64Hz
 0042 20                pop X
 0043                   .dbline 353
 0043           ;     M8C_EnableIntMask(INT_MSK0, INT_MSK0_SLEEP);
 0043 43E040            or REG[0xe0],64
 0046                   .dbline 356
 0046           ; #endif
 0046           ; 
 0046           ;     if(!CYFISNP_PhyStart())
 0046 10                push X
 0047 7C0000            xcall _CYFISNP_PhyStart
 004A 20                pop X
 004B 3900              cmp A,0
 004D B005              jnz L14
 004F                   .dbline 358
 004F           ;     {
 004F           ;         CYFISNP_OutStr("\n\rRadio Init Failed!\n\r");
 004F                   .dbline 358
 004F                   .dbline 359
 004F           ;         return 0;
 004F 5000              mov A,0
 0051 8035              xjmp L11
 0053           L14:
 0053                   .dbline 363
 0053           ;     }
 0053           ; 
 0053           ; #if !CYFISNP_DEBUG  // Stop 750KHz default on XOUT (reduce noise)
 0053           ;     CYFISNP_Write(CYFISNP_XTAL_CTRL_ADR, CYFISNP_XOUT_FNC_GPIO);
 0053 10                push X
 0054 57C0              mov X,-64
 0056 500C              mov A,12
 0058 7C0000            xcall _CYFISNP_Write
 005B                   .dbline 366
 005B           ; #endif
 005B           ; 
 005B           ;       CYFISNP_SetPreambleCount(CYFISNP_DEF_PREAMBLE_CNT);
 005B 5002              mov A,2
 005D 7C0000            xcall _CYFISNP_SetPreambleCount
 0060                   .dbline 367
 0060           ;     CYFISNP_ForceState(CYFISNP_END_STATE_SLEEP);  // Min radio current
 0060 5000              mov A,0
 0062 7C0000            xcall _CYFISNP_ForceState
 0065                   .dbline 368
 0065           ;     CYFISNP_SetPtr(&SNP_txBuf[0]);
 0065 5033              mov A,>_SNP_txBuf
 0067 5733              mov X,<_SNP_txBuf
 0069 7C0000            xcall _CYFISNP_SetPtr
 006C                   .dbline 369
 006C           ;     CYFISNP_SetLength(SNP_PROT_PKT_TX_MAX);
 006C 5007              mov A,7
 006E 7C0000            xcall _CYFISNP_SetLength
 0071 20                pop X
 0072                   .dbline 370
 0072           ;     crc0AutoAck(FALSE);
 0072 5000              mov A,0
 0074 08                push A
 0075 7C0D40            xcall _crc0AutoAck
 0078 38FF              add SP,-1
 007A                   .dbline 372
 007A           ; 
 007A           ;     gotoDefaultMode();
 007A 907E              xcall _gotoDefaultMode
 007C                   .dbline 373
 007C           ;     CYFISNP_spiSleep();
 007C 7C0CAE            xcall _CYFISNP_spiSleep
 007F                   .dbline 375
 007F           ; 
 007F           ;     bDataRetryCt = 0;           // No more retries
 007F 551800            mov [_bDataRetryCt],0
 0082                   .dbline 376
 0082           ;     txPending = FALSE;          // Empty API's Tx buffer
 0082 551500            mov [_txPending],0
 0085                   .dbline 378
 0085           ; 
 0085           ;     return 1;
 0085 5001              mov A,1
 0087                   .dbline -2
 0087           L11:
 0087                   .dbline 0 ; func end
 0087 7F                ret
 0088                   .dbend
 0088                   .dbfunc e CYFISNP_Stop _CYFISNP_Stop fV
 0088           _CYFISNP_Stop::
 0088                   .dbline -1
 0088                   .dbline 388
 0088           ; }
 0088           ; 
 0088           ; 
 0088           ; // ---------------------------------------------------------------------------
 0088           ; //
 0088           ; // CYFISNP_Stop() - Can be used to "abort" a pending transmission.
 0088           ; //
 0088           ; // ---------------------------------------------------------------------------
 0088           ; void CYFISNP_Stop(void)
 0088           ; {
 0088                   .dbline 389
 0088           ;     CYFISNP_PhyStop();
 0088 10                push X
 0089 7C0000            xcall _CYFISNP_PhyStop
 008C 20                pop X
 008D                   .dbline 392
 008D           ; 
 008D           ; #if(CYFISNP_PSOC_EXPRESS_PROJECT == 0)
 008D           ;     M8C_DisableIntMask(INT_MSK0, INT_MSK0_SLEEP);
 008D 41E0BF            and REG[0xe0],-65
 0090                   .dbline 395
 0090           ; #endif
 0090           ; 
 0090           ;     CYFISNP_eProtState = CYFISNP_STOP_MODE;
 0090 553B50            mov [_CYFISNP_eProtState],80
 0093                   .dbline -2
 0093           L16:
 0093                   .dbline 0 ; func end
 0093 7F                ret
 0094                   .dbend
 0094                   .dbfunc e CYFISNP_Jog _CYFISNP_Jog fV
 0094           _CYFISNP_Jog::
 0094                   .dbline -1
 0094 10                push X
 0095 4F                mov X,SP
 0096 10                push X
 0097                   .dbline 407
 0097           ; 
 0097           ; }
 0097           ; 
 0097           ; 
 0097           ; 
 0097           ; // ---------------------------------------------------------------------------
 0097           ; //
 0097           ; // CYFISNP_Jog() - Wakeup from a Time-Out power-conservation state.
 0097           ; //
 0097           ; // ---------------------------------------------------------------------------
 0097           ; void CYFISNP_Jog(void)
 0097           ; {
 0097                   .dbline 408
 0097           ;     CYFISNP_spiWake();
 0097 7C0CFF            xcall _CYFISNP_spiWake
 009A                   .dbline 409
 009A           ;     switch (CYFISNP_eProtState) {
 009A 3C3B21            cmp [_CYFISNP_eProtState],33
 009D A00D              jz L21
 009F 3C3B21            cmp [_CYFISNP_eProtState],33
 00A2 C00E              jc L18
 00A4           X0:
 00A4           L23:
 00A4 3C3B31            cmp [_CYFISNP_eProtState],49
 00A7 A007              jz L22
 00A9 8007              xjmp L18
 00AB           L21:
 00AB                   .dbline 411
 00AB           ;         case CYFISNP_CON_MODE_TIMEOUT:
 00AB           ;              gotoConnectMode();
 00AB 9235              xcall _gotoConnectMode
 00AD                   .dbline 412
 00AD           ;              break;
 00AD 8003              xjmp L19
 00AF           L22:
 00AF                   .dbline 414
 00AF           ;         case CYFISNP_PING_MODE_TIMEOUT:
 00AF           ;             gotoPingMode();
 00AF 976A              xcall _gotoPingMode
 00B1                   .dbline 415
 00B1           ;             break;
 00B1           L18:
 00B1           L19:
 00B1                   .dbline -2
 00B1           L17:
 00B1 20                pop X
 00B2 20                pop X
 00B3                   .dbline 0 ; func end
 00B3 7F                ret
 00B4                   .dbend
 00B4                   .dbfunc e CYFISNP_Run _CYFISNP_Run fV
 00B4           _CYFISNP_Run::
 00B4                   .dbline -1
 00B4 10                push X
 00B5 4F                mov X,SP
 00B6 10                push X
 00B7                   .dbline 427
 00B7           ;     }
 00B7           ; }
 00B7           ; 
 00B7           ; 
 00B7           ; 
 00B7           ; // ---------------------------------------------------------------------------
 00B7           ; //
 00B7           ; // CYFISNP_Run() = Punctuated periodic polling
 00B7           ; //
 00B7           ; // ---------------------------------------------------------------------------
 00B7           ; void CYFISNP_Run(void)
 00B7           ; {
 00B7                   .dbline 428
 00B7           ;     switch (CYFISNP_eProtState) {
 00B7 3C3B20            cmp [_CYFISNP_eProtState],32
 00BA A026              jz L29
 00BC 5020              mov A,32
 00BE 3A3B              cmp A,[_CYFISNP_eProtState]
 00C0 C008              jc L33
 00C2           X1:
 00C2           L32:
 00C2 3C3B10            cmp [_CYFISNP_eProtState],16
 00C5 A014              jz L28
 00C7 802F              xjmp L26
 00C9           L33:
 00C9 3C3B30            cmp [_CYFISNP_eProtState],48
 00CC A025              jz L31
 00CE 3C3B30            cmp [_CYFISNP_eProtState],48
 00D1 C025              jc L26
 00D3           X2:
 00D3           L34:
 00D3 3C3B40            cmp [_CYFISNP_eProtState],64
 00D6 A011              jz L30
 00D8 801E              xjmp L26
 00DA           L28:
 00DA                   .dbline 431
 00DA           ;         // -------------------------------------------------------------------
 00DA           ;     case CYFISNP_BIND_MODE:
 00DA           ;             CYFISNP_spiWake();
 00DA 7C0CFF            xcall _CYFISNP_spiWake
 00DD                   .dbline 432
 00DD           ;             bindRun();
 00DD 907F              xcall _bindRun
 00DF                   .dbline 433
 00DF           ;             break;
 00DF 8017              xjmp L26
 00E1           L29:
 00E1                   .dbline 436
 00E1           ;         // -------------------------------------------------------------------
 00E1           ;         case CYFISNP_CON_MODE:
 00E1           ;             CYFISNP_spiWake();
 00E1 7C0CFF            xcall _CYFISNP_spiWake
 00E4                   .dbline 437
 00E4           ;             runConnectMode();
 00E4 923A              xcall _runConnectMode
 00E6                   .dbline 438
 00E6           ;             break;
 00E6 8010              xjmp L26
 00E8           L30:
 00E8                   .dbline 441
 00E8           ;         // -------------------------------------------------------------------
 00E8           ;         case CYFISNP_DATA_MODE:
 00E8           ;             CYFISNP_spiWake();
 00E8 7C0CFF            xcall _CYFISNP_spiWake
 00EB                   .dbline 442
 00EB           ;             runDataMode();
 00EB 94D9              xcall _runDataMode
 00ED                   .dbline 443
 00ED           ;             CYFISNP_spiSleep();
 00ED 7C0CAE            xcall _CYFISNP_spiSleep
 00F0                   .dbline 444
 00F0           ;             break;
 00F0 8006              xjmp L26
 00F2           L31:
 00F2                   .dbline 447
 00F2           ;         // -------------------------------------------------------------------
 00F2           ;         case CYFISNP_PING_MODE:
 00F2           ;             CYFISNP_spiWake();
 00F2 7C0CFF            xcall _CYFISNP_spiWake
 00F5                   .dbline 448
 00F5           ;             runPingMode();
 00F5 974B              xcall _runPingMode
 00F7                   .dbline 449
 00F7           ;             break;
 00F7                   .dbline 452
 00F7           ;         // -------------------------------------------------------------------
 00F7           ;         default:
 00F7           ;             break;
 00F7           L26:
 00F7                   .dbline -2
 00F7           L24:
 00F7 20                pop X
 00F8 20                pop X
 00F9                   .dbline 0 ; func end
 00F9 7F                ret
 00FA                   .dbend
 00FA                   .dbfunc s gotoDefaultMode _gotoDefaultMode fV
 00FA           _gotoDefaultMode:
 00FA                   .dbline -1
 00FA                   .dbline 462
 00FA           ;     }
 00FA           ; }
 00FA           ; 
 00FA           ; 
 00FA           ; // ---------------------------------------------------------------------------
 00FA           ; //
 00FA           ; // gotoDefaultMode() - Goto Connect mode if are bound, otherwise go Unbound
 00FA           ; //
 00FA           ; // ---------------------------------------------------------------------------
 00FA           ; static void gotoDefaultMode(void) {
 00FA                   .dbline 463
 00FA           ;     if (netParamsPresent()) {
 00FA 7C0D2E            xcall _netParamsPresent
 00FD 3900              cmp A,0
 00FF A005              jz L36
 0101                   .dbline 464
 0101           ;         gotoConnectModeBase();
 0101                   .dbline 464
 0101 91CC              xcall _gotoConnectModeBase
 0103                   .dbline 465
 0103           ;     }
 0103 8003              xjmp L37
 0105           L36:
 0105                   .dbline 466
 0105           ;     else {
 0105                   .dbline 467
 0105           ;         gotoUnboundMode();
 0105 9001              xcall _gotoUnboundMode
 0107                   .dbline 468
 0107           ;     }
 0107           L37:
 0107                   .dbline -2
 0107           L35:
 0107                   .dbline 0 ; func end
 0107 7F                ret
 0108                   .dbend
 0108                   .dbfunc s gotoUnboundMode _gotoUnboundMode fV
 0108           _gotoUnboundMode:
 0108                   .dbline -1
 0108                   .dbline 478
 0108           ; }
 0108           ; 
 0108           ; 
 0108           ; // ---------------------------------------------------------------------------
 0108           ; //
 0108           ; // gotoUnboundMode() - Do nothing until _BindStart() is called
 0108           ; //
 0108           ; // ---------------------------------------------------------------------------
 0108           ; static void gotoUnboundMode(void)
 0108           ; {
 0108                   .dbline 479
 0108           ;     CYFISNP_eProtState = CYFISNP_UNBOUND_MODE;
 0108 553B11            mov [_CYFISNP_eProtState],17
 010B                   .dbline 480
 010B           ;     CYFISNP_OutStr("<Unbound: STOP>");
 010B                   .dbline -2
 010B           L38:
 010B                   .dbline 0 ; func end
 010B 7F                ret
 010C                   .dbend
 010C                   .dbfunc e CYFISNP_BindStart _CYFISNP_BindStart fV
 010C           ;          DevID -> X-4
 010C           _CYFISNP_BindStart::
 010C                   .dbline -1
 010C 10                push X
 010D 4F                mov X,SP
 010E                   .dbline 489
 010E           ; }
 010E           ; 
 010E           ; // ---------------------------------------------------------------------------
 010E           ; //
 010E           ; //  CYFISNP_BindStart() - From Data Mode to Bind Mode
 010E           ; //
 010E           ; // ---------------------------------------------------------------------------
 010E           ; void CYFISNP_BindStart(BYTE DevID)
 010E           ; {
 010E                   .dbline 490
 010E           ;     CYFISNP_OutStr("\n\rStart Bind Mode");
 010E                   .dbline 492
 010E           ; 
 010E           ;     CYFISNP_spiWake();
 010E 7C0CFF            xcall _CYFISNP_spiWake
 0111                   .dbline 493
 0111           ;     bindChIdx = 0;
 0111 550C00            mov [_bindChIdx],0
 0114                   .dbline 494
 0114           ;     CYFISNP_bCurrentChannel = CYFISNP_BIND_CH_SEQ[bindChIdx];
 0114 5F000C            mov [__r1],[_bindChIdx]
 0117 550000            mov [__r0],0
 011A 060008            add [__r1],<_CYFISNP_BIND_CH_SEQ
 011D 0E0008            adc [__r0],>_CYFISNP_BIND_CH_SEQ
 0120 5100              mov A,[__r0]
 0122 10                push X
 0123 5800              mov X,[__r1]
 0125 28                romx
 0126 20                pop X
 0127 533A              mov [_CYFISNP_bCurrentChannel],A
 0129                   .dbline 495
 0129           ;     CYFISNP_SetChannel  (CYFISNP_bCurrentChannel);
 0129 10                push X
 012A 513A              mov A,[_CYFISNP_bCurrentChannel]
 012C 7C0000            xcall _CYFISNP_SetChannel
 012F                   .dbline 496
 012F           ;     CYFISNP_SetSopPnCode(CYFISNP_BIND_MODE_SOP);
 012F 5000              mov A,0
 0131 7C0000            xcall _CYFISNP_SetSopPnCode
 0134 20                pop X
 0135                   .dbline 498
 0135           ; 
 0135           ;     SNP_txBuf[0] = PKT_BINDREQ_TYPE | CYFISNP_PWR_TYPE;
 0135 553300            mov [_SNP_txBuf],0
 0138                   .dbline 499
 0138           ;     SNP_txBuf[1] = DevID;
 0138 52FC              mov A,[X-4]
 013A 5334              mov [_SNP_txBuf+1],A
 013C                   .dbline 500
 013C           ;     copyMidToTxPkt();
 013C 7C0987            xcall _copyMidToTxPkt
 013F                   .dbline 501
 013F           ;     SNP_txBuf[6] = SNP_RSP_DELAY;
 013F 55391C            mov [_SNP_txBuf+6],28
 0142                   .dbline 503
 0142           ; 
 0142           ;     CYFISNP_eProtState = CYFISNP_BIND_MODE;
 0142 553B10            mov [_CYFISNP_eProtState],16
 0145                   .dbline 504
 0145           ;     wBindModeCounter = BIND_MODE_COUNT_MAX;
 0145 550BF4            mov [_wBindModeCounter+1],-12
 0148 550A01            mov [_wBindModeCounter],1
 014B                   .dbline 506
 014B           ; 
 014B           ;     CYFISNP_TimeSet(&bindReqTimer, BIND_REQ_TIME);
 014B 5000              mov A,0
 014D 08                push A
 014E 5001              mov A,1
 0150 08                push A
 0151 5008              mov A,>_bindReqTimer
 0153 08                push A
 0154 5008              mov A,<_bindReqTimer
 0156 08                push A
 0157 7C0000            xcall _CYFISNP_TimeSet
 015A 38FC              add SP,-4
 015C                   .dbline -2
 015C           L39:
 015C 20                pop X
 015D                   .dbline 0 ; func end
 015D 7F                ret
 015E                   .dbsym l DevID -4 c
 015E                   .dbend
 015E                   .dbfunc s bindRun _bindRun fV
 015E           ;          rxLen -> X+3
 015E           ;      waitDelay -> X+1
 015E           ; radioStateCopy -> X+0
 015E           _bindRun:
 015E                   .dbline -1
 015E 10                push X
 015F 4F                mov X,SP
 0160 3804              add SP,4
 0162                   .dbline 516
 0162           ; }
 0162           ; 
 0162           ; 
 0162           ; // ---------------------------------------------------------------------------
 0162           ; //
 0162           ; //  bindRun() -
 0162           ; //
 0162           ; // ---------------------------------------------------------------------------
 0162           ; static void bindRun(void)
 0162           ; {
 0162                   .dbline 519
 0162           ;     RADIO_STATE radioStateCopy;
 0162           ; 
 0162           ;     if (CYFISNP_TimeExpired(&bindReqTimer) != TRUE) {
 0162 5008              mov A,>_bindReqTimer
 0164 08                push A
 0165 5008              mov A,<_bindReqTimer
 0167 08                push A
 0168 7C0000            xcall _CYFISNP_TimeExpired
 016B 38FE              add SP,-2
 016D 3901              cmp A,1
 016F                   .dbline 520
 016F           ;         return;
 016F                   .dbline 520
 016F B153              jnz L42
 0171           L43:
 0171                   .dbline 522
 0171           ;     }
 0171           ;     CYFISNP_TimeSet(&bindReqTimer, BIND_REQ_TIME);
 0171 5000              mov A,0
 0173 08                push A
 0174 5001              mov A,1
 0176 08                push A
 0177 5008              mov A,>_bindReqTimer
 0179 08                push A
 017A 5008              mov A,<_bindReqTimer
 017C 08                push A
 017D 7C0000            xcall _CYFISNP_TimeSet
 0180 38FC              add SP,-4
 0182                   .dbline 527
 0182           ; 
 0182           ;     // -----------------------------------------------------------------------
 0182           ;     // Send another Bind Request
 0182           ;     // -----------------------------------------------------------------------
 0182           ;     if (++bindChIdx >= sizeof(CYFISNP_BIND_CH_SEQ)) {
 0182 060C01            add [_bindChIdx],1
 0185 3C0C06            cmp [_bindChIdx],6
 0188 C004              jc L45
 018A           X3:
 018A                   .dbline 528
 018A           ;         bindChIdx = 0;
 018A                   .dbline 528
 018A 550C00            mov [_bindChIdx],0
 018D                   .dbline 529
 018D           ;     }
 018D           L45:
 018D                   .dbline 530
 018D           ;     CYFISNP_bCurrentChannel = CYFISNP_BIND_CH_SEQ[bindChIdx];
 018D 5F000C            mov [__r1],[_bindChIdx]
 0190 550000            mov [__r0],0
 0193 060008            add [__r1],<_CYFISNP_BIND_CH_SEQ
 0196 0E0008            adc [__r0],>_CYFISNP_BIND_CH_SEQ
 0199 5100              mov A,[__r0]
 019B 10                push X
 019C 5800              mov X,[__r1]
 019E 28                romx
 019F 20                pop X
 01A0 533A              mov [_CYFISNP_bCurrentChannel],A
 01A2                   .dbline 531
 01A2           ;     CYFISNP_SetChannel(CYFISNP_bCurrentChannel);
 01A2 10                push X
 01A3 513A              mov A,[_CYFISNP_bCurrentChannel]
 01A5 7C0000            xcall _CYFISNP_SetChannel
 01A8 20                pop X
 01A9                   .dbline 532
 01A9           ;     setBindPaLevel();
 01A9 7C0C5D            xcall _setBindPaLevel
 01AC                   .dbline 533
 01AC           ;     crc0AutoAck(TRUE);
 01AC 5001              mov A,1
 01AE 08                push A
 01AF 7C0D40            xcall _crc0AutoAck
 01B2 38FF              add SP,-1
 01B4                   .dbline 534
 01B4           ;     CYFISNP_SetCrcSeed(CYFISNP_BIND_MODE_CRC_SEED);
 01B4 10                push X
 01B5 5000              mov A,0
 01B7 5700              mov X,0
 01B9 7C0000            xcall _CYFISNP_SetCrcSeed
 01BC                   .dbline 535
 01BC           ;     CYFISNP_SetXactConfig(0
 01BC 5091              mov A,-111
 01BE 7C0000            xcall _CYFISNP_SetXactConfig
 01C1                   .dbline 539
 01C1           ;                       | CYFISNP_ACK_EN          // Expect AutoAck
 01C1           ;                       | CYFISNP_ACK_TO_8X
 01C1           ;                       | CYFISNP_END_STATE_RX);  // Expect Response
 01C1           ;     CYFISNP_SetPtr(&SNP_txBuf[0]);
 01C1 5033              mov A,>_SNP_txBuf
 01C3 5733              mov X,<_SNP_txBuf
 01C5 7C0000            xcall _CYFISNP_SetPtr
 01C8                   .dbline 540
 01C8           ;     CYFISNP_StartTransmit(0, PKT_BINDREQ_LEN);
 01C8 5707              mov X,7
 01CA 5000              mov A,0
 01CC 7C0000            xcall _CYFISNP_StartTransmit
 01CF 20                pop X
 01D0 8006              xjmp L48
 01D2           L47:
 01D2                   .dbline 541
 01D2           ;     while ((CYFISNP_State & CYFISNP_COMPLETE) == 0) {
 01D2                   .dbline 542
 01D2           ;         CYFISNP_GetTransmitState();
 01D2 10                push X
 01D3 7C0000            xcall _CYFISNP_GetTransmitState
 01D6 20                pop X
 01D7                   .dbline 543
 01D7           ;     }
 01D7           L48:
 01D7                   .dbline 541
 01D7 470002            tst [_CYFISNP_State],2
 01DA AFF7              jz L47
 01DC                   .dbline 544
 01DC           ;     radioStateCopy = CYFISNP_State;
 01DC 5100              mov A,[_CYFISNP_State]
 01DE 5400              mov [X+0],A
 01E0                   .dbline 545
 01E0           ;     CYFISNP_EndTransmit();
 01E0 10                push X
 01E1 7C0000            xcall _CYFISNP_EndTransmit
 01E4 20                pop X
 01E5                   .dbline 547
 01E5           ; 
 01E5           ;     crc0AutoAck(FALSE);
 01E5 5000              mov A,0
 01E7 08                push A
 01E8 7C0D40            xcall _crc0AutoAck
 01EB 38FF              add SP,-1
 01ED                   .dbline 548
 01ED           ;     CYFISNP_SetCrcSeed( (WORD)(SNP_txBuf[2]<<8) | SNP_txBuf[3]);
 01ED 5F0036            mov [__r1],[_SNP_txBuf+3]
 01F0 550000            mov [__r0],0
 01F3 5F0035            mov [__r2],[_SNP_txBuf+2]
 01F6 5000              mov A,0
 01F8 2A00              or A,[__r1]
 01FA 5300              mov [__r1],A
 01FC 5100              mov A,[__r2]
 01FE 2A00              or A,[__r0]
 0200 10                push X
 0201 08                push A
 0202 5100              mov A,[__r1]
 0204 20                pop X
 0205 7C0000            xcall _CYFISNP_SetCrcSeed
 0208 20                pop X
 0209                   .dbline 553
 0209           ; 
 0209           ;     // -----------------------------------------------------------------------
 0209           ;     // If AutoAck failed, power-down radio
 0209           ;     // -----------------------------------------------------------------------
 0209           ;     if ((radioStateCopy & CYFISNP_ERROR) != 0) {
 0209 480001            tst [X+0],1
 020C A00A              jz L52
 020E                   .dbline 554
 020E           ;         CYFISNP_ForceState(CYFISNP_END_STATE_SLEEP);
 020E                   .dbline 554
 020E 10                push X
 020F 5000              mov A,0
 0211 7C0000            xcall _CYFISNP_ForceState
 0214 20                pop X
 0215                   .dbline 555
 0215           ;     }
 0215 8092              xjmp L53
 0217           L52:
 0217                   .dbline 559
 0217           ;     // -----------------------------------------------------------------------
 0217           ;     // Else AutoAck PASSED, open 3 mS BindRsp Rx window
 0217           ;     // -----------------------------------------------------------------------
 0217           ;     else {
 0217                   .dbline 561
 0217           ;         WORD waitDelay;
 0217           ;         waitDelay = CYFISNP_RX_WINDOW;
 0217 56021E            mov [X+2],30
 021A 560100            mov [X+1],0
 021D                   .dbline 563
 021D           ; 
 021D           ;         setMaxPaLevel();                    // node sends AutoAck at full power
 021D 7C0C55            xcall _setMaxPaLevel
 0220                   .dbline 564
 0220           ;         CYFISNP_SetPtr(&SNP_rxBuf.snp.pkt[0]);
 0220 10                push X
 0221 5029              mov A,>_SNP_rxBuf+3
 0223 5729              mov X,<_SNP_rxBuf+3
 0225 7C0000            xcall _CYFISNP_SetPtr
 0228                   .dbline 565
 0228           ;         CYFISNP_SetLength(SNP_PROT_PKT_RX_MAX);
 0228 500A              mov A,10
 022A 7C0000            xcall _CYFISNP_SetLength
 022D                   .dbline 566
 022D           ;         CYFISNP_SetXactConfig(0
 022D 5085              mov A,-123
 022F 7C0000            xcall _CYFISNP_SetXactConfig
 0232                   .dbline 570
 0232           ;                                 | CYFISNP_ACK_EN   // Expect AutoAck
 0232           ;                                 | CYFISNP_ACK_TO_8X
 0232           ;                                 | CYFISNP_END_STATE_IDLE);
 0232           ;         CYFISNP_StartReceive();
 0232 7C0000            xcall _CYFISNP_StartReceive
 0235 20                pop X
 0236                   .dbline 575
 0236           ; 
 0236           ;         // -------------------------------------------------------------------
 0236           ;         // Maintain 3 mS BindRsp Rx window
 0236           ;         // -------------------------------------------------------------------
 0236           ;         for (;;) {
 0236           L55:
 0236                   .dbline 575
 0236                   .dbline 576
 0236           ;             BYTE rxLen = 0;
 0236 560300            mov [X+3],0
 0239                   .dbline 577
 0239           ;             radioStateCopy = CYFISNP_GetReceiveState();
 0239 10                push X
 023A 7C0000            xcall _CYFISNP_GetReceiveState
 023D 20                pop X
 023E 5400              mov [X+0],A
 0240                   .dbline 579
 0240           ; 
 0240           ;             CYFISNP_Delay100uS();           // Delay 100 uS
 0240 10                push X
 0241 7C0000            xcall _CYFISNP_Delay100uS
 0244 20                pop X
 0245                   .dbline 580
 0245           ;             if (--waitDelay == 0) {
 0245 5202              mov A,[X+2]
 0247 1101              sub A,1
 0249 5300              mov [__r1],A
 024B 5201              mov A,[X+1]
 024D 1900              sbb A,0
 024F 5300              mov [__r0],A
 0251 5100              mov A,[__r1]
 0253 5402              mov [X+2],A
 0255 5100              mov A,[__r0]
 0257 5401              mov [X+1],A
 0259 3C0000            cmp [__r0],0
 025C B01B              jnz L59
 025E 3C0000            cmp [__r1],0
 0261 B016              jnz L59
 0263           X4:
 0263                   .dbline 581
 0263           ;                 rxLen = CYFISNP_Abort();
 0263                   .dbline 581
 0263 10                push X
 0264 7C0000            xcall _CYFISNP_Abort
 0267 20                pop X
 0268 5403              mov [X+3],A
 026A                   .dbline 582
 026A           ;                 if (rxLen == CYFISNP_ABORT_SUCCESS) {
 026A 3D03FF            cmp [X+3],-1
 026D B00A              jnz L61
 026F                   .dbline 583
 026F           ;                     CYFISNP_ForceState(CYFISNP_END_STATE_SLEEP);
 026F                   .dbline 583
 026F 10                push X
 0270 5000              mov A,0
 0272 7C0000            xcall _CYFISNP_ForceState
 0275 20                pop X
 0276                   .dbline 584
 0276           ;                     break;
 0276 8031              xjmp L57
 0278           L61:
 0278                   .dbline 586
 0278           ;                 }
 0278           ;             }
 0278           L59:
 0278                   .dbline 587
 0278           ;             if (radioStateCopy & CYFISNP_COMPLETE) {
 0278 480002            tst [X+0],2
 027B AFBA              jz L55
 027D                   .dbline 588
 027D           ;                 rxLen = CYFISNP_EndReceive();
 027D                   .dbline 588
 027D 10                push X
 027E 7C0000            xcall _CYFISNP_EndReceive
 0281 20                pop X
 0282 5403              mov [X+3],A
 0284                   .dbline 589
 0284           ;                 CYFISNP_ForceState(CYFISNP_END_STATE_SLEEP);
 0284 10                push X
 0285 5000              mov A,0
 0287 7C0000            xcall _CYFISNP_ForceState
 028A 20                pop X
 028B                   .dbline 591
 028B           ; 
 028B           ;                 if (radioStateCopy & CYFISNP_ERROR) {
 028B 480001            tst [X+0],1
 028E                   .dbline 592
 028E           ;                     break;
 028E                   .dbline 592
 028E B019              jnz L57
 0290           L65:
 0290                   .dbline 597
 0290           ;                 }
 0290           ;                 // -----------------------------------------------------------
 0290           ;                 // If BindRsp received
 0290           ;                 // -----------------------------------------------------------
 0290           ;                 if (SNP_rxBuf.snp.pkt[0] == PKT_BINDRSP_TYPE
 0290 3C2910            cmp [_SNP_rxBuf+3],16
 0293 BFA2              jnz L55
 0295 3D030A            cmp [X+3],10
 0298 BF9D              jnz L55
 029A                   .dbline 599
 029A           ;                  &&                rxLen == PKT_BINDRSP_LEN) {
 029A           ;                     putNetParams(&SNP_rxBuf.snp.pkt[0]);    // Wr to FLASH
 029A                   .dbline 599
 029A 5029              mov A,>_SNP_rxBuf+3
 029C 08                push A
 029D 5029              mov A,<_SNP_rxBuf+3
 029F 08                push A
 02A0 96F7              xcall _putNetParams
 02A2 38FE              add SP,-2
 02A4                   .dbline 600
 02A4           ;                     gotoConnectModeBase();
 02A4 9029              xcall _gotoConnectModeBase
 02A6                   .dbline 601
 02A6           ;                     return;         // BIND SUCCESSFUL ----- EXIT HERE
 02A6 801C              xjmp L42
 02A8           L57:
 02A8                   .dbline 605
 02A8           ;                 }
 02A8           ;             }   // end Rx Complete
 02A8           ;         }  // end for(;;)
 02A8           ;     }   // end AutoAck received
 02A8           L53:
 02A8                   .dbline 607
 02A8           ; 
 02A8           ;     if (--wBindModeCounter == 0) {
 02A8 510B              mov A,[_wBindModeCounter+1]
 02AA 1101              sub A,1
 02AC 5300              mov [__r1],A
 02AE 510A              mov A,[_wBindModeCounter]
 02B0 1900              sbb A,0
 02B2 5F0B00            mov [_wBindModeCounter+1],[__r1]
 02B5 530A              mov [_wBindModeCounter],A
 02B7 3C0A00            cmp [_wBindModeCounter],0
 02BA B008              jnz L71
 02BC 3C0000            cmp [__r1],0
 02BF B003              jnz L71
 02C1           X5:
 02C1                   .dbline 608
 02C1           ;         gotoDefaultMode();          // Exhausted Bind attempts
 02C1                   .dbline 608
 02C1 9E37              xcall _gotoDefaultMode
 02C3                   .dbline 609
 02C3           ;     }
 02C3           L71:
 02C3                   .dbline -2
 02C3           L42:
 02C3 38FC              add SP,-4
 02C5 20                pop X
 02C6                   .dbline 0 ; func end
 02C6 7F                ret
 02C7                   .dbsym l rxLen 3 c
 02C7                   .dbsym l waitDelay 1 i
 02C7                   .dbsym l radioStateCopy 0 c
 02C7                   .dbend
 02C7                   .dbfunc e CYFISNP_GetNodeID _CYFISNP_GetNodeID fc
 02C7           _CYFISNP_GetNodeID::
 02C7                   .dbline -1
 02C7                   .dbline 618
 02C7           ; }
 02C7           ; 
 02C7           ; 
 02C7           ; // ---------------------------------------------------------------------------
 02C7           ; //
 02C7           ; // CYFISNP_GetNodeID -
 02C7           ; //
 02C7           ; // ---------------------------------------------------------------------------
 02C7           ; BYTE CYFISNP_GetNodeID(void)  {
 02C7                   .dbline 619
 02C7           ;     return(CYFISNP_EEP_NET_REC_ADR->devId);
 02C7 503F              mov A,63
 02C9 10                push X
 02CA 57C5              mov X,-59
 02CC 28                romx
 02CD 20                pop X
 02CE                   .dbline -2
 02CE           L73:
 02CE                   .dbline 0 ; func end
 02CE 7F                ret
 02CF                   .dbend
 02CF                   .dbfunc s gotoConnectModeBase _gotoConnectModeBase fV
 02CF           _gotoConnectModeBase:
 02CF                   .dbline -1
 02CF                   .dbline 628
 02CF           ; }
 02CF           ; 
 02CF           ; 
 02CF           ; // ---------------------------------------------------------------------------
 02CF           ; //
 02CF           ; // gotoConnectMode() - Enter connect from Powerup or Bind Response
 02CF           ; //
 02CF           ; // ---------------------------------------------------------------------------
 02CF           ; static void gotoConnectModeBase(void) {
 02CF                   .dbline 629
 02CF           ;     CYFISNP_bCurrentChannel = (CYFISNP_EEP_NET_REC_ADR->chBase);
 02CF 503F              mov A,63
 02D1 10                push X
 02D2 57C1              mov X,-63
 02D4 28                romx
 02D5 20                pop X
 02D6 533A              mov [_CYFISNP_bCurrentChannel],A
 02D8                   .dbline 630
 02D8           ;     setIdleReceive(CYFISNP_PWR_TYPE == CYFISNP_PWR_WALL);
 02D8 5000              mov A,0
 02DA 08                push A
 02DB 92A3              xcall _setIdleReceive
 02DD 38FF              add SP,-1
 02DF                   .dbline 631
 02DF           ;     gotoConnectMode();
 02DF 9001              xcall _gotoConnectMode
 02E1                   .dbline -2
 02E1           L74:
 02E1                   .dbline 0 ; func end
 02E1 7F                ret
 02E2                   .dbend
 02E2                   .dbfunc s gotoConnectMode _gotoConnectMode fV
 02E2           _gotoConnectMode:
 02E2                   .dbline -1
 02E2                   .dbline 635
 02E2           ; }
 02E2           ; 
 02E2           ; static void gotoConnectMode(void)
 02E2           ; {
 02E2                   .dbline 636
 02E2           ;     CYFISNP_OutStr("\n\rStart Connect Mode. ");
 02E2                   .dbline 638
 02E2           ; 
 02E2           ;     setMaxPaLevel();
 02E2 7C0C55            xcall _setMaxPaLevel
 02E5                   .dbline 640
 02E5           ; 
 02E5           ;     CYFISNP_SetChannel(CYFISNP_bCurrentChannel);
 02E5 10                push X
 02E6 513A              mov A,[_CYFISNP_bCurrentChannel]
 02E8 7C0000            xcall _CYFISNP_SetChannel
 02EB 20                pop X
 02EC                   .dbline 641
 02EC           ;     CYFISNP_SetSopPnCode(CYFISNP_EEP_NET_REC_ADR->sopIdx);
 02EC 503F              mov A,63
 02EE 10                push X
 02EF 57C0              mov X,-64
 02F1 28                romx
 02F2 7C0000            xcall _CYFISNP_SetSopPnCode
 02F5 20                pop X
 02F6                   .dbline 643
 02F6           ; 
 02F6           ;     CYFISNP_eProtState = CYFISNP_CON_MODE;
 02F6 553B20            mov [_CYFISNP_eProtState],32
 02F9                   .dbline 644
 02F9           ;     onChanTxLeft = ON_NEW_CHAN_TX_MAX;
 02F9 551201            mov [_onChanTxLeft],1
 02FC                   .dbline 645
 02FC           ;     wModeCounter = CON_MODE_COUNT_MAX;
 02FC 5510C8            mov [_wModeCounter+1],-56
 02FF 550F00            mov [_wModeCounter],0
 0302                   .dbline 646
 0302           ;     CYFISNP_TimeSet(&wModeDelay, CON_MODE_FAST_TIME);
 0302 5000              mov A,0
 0304 08                push A
 0305 08                push A
 0306 500D              mov A,>_wModeDelay
 0308 08                push A
 0309 500D              mov A,<_wModeDelay
 030B 08                push A
 030C 7C0000            xcall _CYFISNP_TimeSet
 030F 38FC              add SP,-4
 0311                   .dbline 651
 0311           ; 
 0311           ;     // -----------------------------------------------------------------------
 0311           ;     // Since Connect Request packet doesn't change, create it ONCE
 0311           ;     // -----------------------------------------------------------------------
 0311           ;     SNP_txBuf[0] = PKT_CONREQ_TYPE;
 0311 553300            mov [_SNP_txBuf],0
 0314                   .dbline 652
 0314           ;     SNP_txBuf[1] = CYFISNP_EEP_NET_REC_ADR->devId;
 0314 503F              mov A,63
 0316 10                push X
 0317 57C5              mov X,-59
 0319 28                romx
 031A 20                pop X
 031B 5334              mov [_SNP_txBuf+1],A
 031D                   .dbline 653
 031D           ;     copyMidToTxPkt();
 031D 9668              xcall _copyMidToTxPkt
 031F                   .dbline -2
 031F           L75:
 031F                   .dbline 0 ; func end
 031F 7F                ret
 0320                   .dbend
 0320                   .dbfunc s runConnectMode _runConnectMode fV
 0320           ;          rxLen -> X+0
 0320           _runConnectMode:
 0320                   .dbline -1
 0320 10                push X
 0321 4F                mov X,SP
 0322 10                push X
 0323                   .dbline 670
 0323           ; }
 0323           ; 
 0323           ; 
 0323           ; // ---------------------------------------------------------------------------
 0323           ; //
 0323           ; //  runConnectMode() -
 0323           ; //
 0323           ; //  The Hub may need to write Node parameters to Flash before returning the
 0323           ; //  ConRsp, so it may a while (4 seconds if using Ice Cube).  If the Node is
 0323           ; //  being a "good neighbor", it shouldn't spew ConReq ASAP if the Hub is
 0323           ; //  busy writing its Flash, thus:
 0323           ; //      1) If Node gets an ACK, it waits a while because it found the HUB
 0323           ; //      2) If Node gets NAK, it retransmits quickly to slew across channels
 0323           ; //
 0323           ; // ---------------------------------------------------------------------------
 0323           ; static void runConnectMode(void)
 0323           ; {
 0323                   .dbline 671
 0323           ;     if (CYFISNP_TimeExpired(&wModeDelay) == FALSE) {
 0323 500D              mov A,>_wModeDelay
 0325 08                push A
 0326 500D              mov A,<_wModeDelay
 0328 08                push A
 0329 7C0000            xcall _CYFISNP_TimeExpired
 032C 38FE              add SP,-2
 032E 3900              cmp A,0
 0330                   .dbline 672
 0330           ;         return;
 0330                   .dbline 672
 0330 A162              jz L77
 0332           L78:
 0332                   .dbline 674
 0332           ;     }
 0332           ;     if (wModeCounter > CON_MODE_COUNT_MAX/2 ) {
 0332 5064              mov A,100
 0334 1210              sub A,[_wModeCounter+1]
 0336 5000              mov A,0
 0338 1A0F              sbb A,[_wModeCounter]
 033A D012              jnc L80
 033C           X6:
 033C                   .dbline 675
 033C           ;         CYFISNP_TimeSet(&wModeDelay, CON_MODE_FAST_TIME);
 033C                   .dbline 675
 033C 5000              mov A,0
 033E 08                push A
 033F 08                push A
 0340 500D              mov A,>_wModeDelay
 0342 08                push A
 0343 500D              mov A,<_wModeDelay
 0345 08                push A
 0346 7C0000            xcall _CYFISNP_TimeSet
 0349 38FC              add SP,-4
 034B                   .dbline 676
 034B           ;     } else {
 034B 8012              xjmp L81
 034D           L80:
 034D                   .dbline 676
 034D                   .dbline 677
 034D           ;         CYFISNP_TimeSet(&wModeDelay, CON_MODE_SLOW_TIME);
 034D 5000              mov A,0
 034F 08                push A
 0350 500C              mov A,12
 0352 08                push A
 0353 500D              mov A,>_wModeDelay
 0355 08                push A
 0356 500D              mov A,<_wModeDelay
 0358 08                push A
 0359 7C0000            xcall _CYFISNP_TimeSet
 035C 38FC              add SP,-4
 035E                   .dbline 678
 035E           ;     }
 035E           L81:
 035E                   .dbline 680
 035E           ; 
 035E           ;     if (wModeCounter-- == 0) {
 035E 5F0010            mov [__r1],[_wModeCounter+1]
 0361 5F000F            mov [__r0],[_wModeCounter]
 0364 5100              mov A,[__r1]
 0366 1101              sub A,1
 0368 5310              mov [_wModeCounter+1],A
 036A 5100              mov A,[__r0]
 036C 1900              sbb A,0
 036E 530F              mov [_wModeCounter],A
 0370 3C0000            cmp [__r0],0
 0373 B00C              jnz L82
 0375 3C0000            cmp [__r1],0
 0378 B007              jnz L82
 037A           X7:
 037A                   .dbline 681
 037A           ;         CYFISNP_eProtState = CYFISNP_CON_MODE_TIMEOUT;
 037A                   .dbline 681
 037A 553B21            mov [_CYFISNP_eProtState],33
 037D                   .dbline 682
 037D           ;         CYFISNP_OutStr("\n\rConnect Mode Timeout. ");
 037D                   .dbline 683
 037D           ;         CYFISNP_spiSleep();
 037D 7C0CAE            xcall _CYFISNP_spiSleep
 0380                   .dbline 684
 0380           ;     }
 0380           L82:
 0380                   .dbline 689
 0380           ; 
 0380           ;     // -------------------------------------------------------------------
 0380           ;     // Send (another) Connect Request
 0380           ;     // -------------------------------------------------------------------
 0380           ;     if (onChanTxLeft-- <= 0) {
 0380 5F0012            mov [__r1],[_onChanTxLeft]
 0383 5112              mov A,[_onChanTxLeft]
 0385 1101              sub A,1
 0387 5300              mov [__r3],A
 0389 5000              mov A,0
 038B 5F1200            mov [_onChanTxLeft],[__r3]
 038E 1200              sub A,[__r1]
 0390 5000              mov A,0
 0392 3180              xor A,-128
 0394 5300              mov [__rX],A
 0396 5080              mov A,(0 ^ 0x80)
 0398 1A00              sbb A,[__rX]
 039A C010              jc L84
 039C           X8:
 039C                   .dbline 690
 039C           ;         onChanTxLeft = ON_NEW_CHAN_TX_MAX;
 039C                   .dbline 690
 039C 551201            mov [_onChanTxLeft],1
 039F                   .dbline 691
 039F           ;         fGotChanAck = 0;
 039F 551100            mov [_fGotChanAck],0
 03A2                   .dbline 692
 03A2           ;         nextNetCh();
 03A2 953C              xcall _nextNetCh
 03A4                   .dbline 693
 03A4           ;         CYFISNP_SetChannel(CYFISNP_bCurrentChannel);
 03A4 10                push X
 03A5 513A              mov A,[_CYFISNP_bCurrentChannel]
 03A7 7C0000            xcall _CYFISNP_SetChannel
 03AA 20                pop X
 03AB                   .dbline 694
 03AB           ;     }
 03AB           L84:
 03AB                   .dbline 696
 03AB           ; 
 03AB           ;     setHubSeed();
 03AB 9C6B              xcall _setHubSeed
 03AD                   .dbline 697
 03AD           ;     CYFISNP_ForceState(CYFISNP_END_STATE_RXSYNTH);  // Expect Rx Response
 03AD 10                push X
 03AE 500C              mov A,12
 03B0 7C0000            xcall _CYFISNP_ForceState
 03B3                   .dbline 698
 03B3           ;     CYFISNP_SetPtr(&SNP_txBuf[0]);
 03B3 5033              mov A,>_SNP_txBuf
 03B5 5733              mov X,<_SNP_txBuf
 03B7 7C0000            xcall _CYFISNP_SetPtr
 03BA                   .dbline 699
 03BA           ;     CYFISNP_StartTransmit(0, PKT_CONREQ_LEN);
 03BA 5706              mov X,6
 03BC 5000              mov A,0
 03BE 7C0000            xcall _CYFISNP_StartTransmit
 03C1 20                pop X
 03C2 8006              xjmp L87
 03C4           L86:
 03C4                   .dbline 700
 03C4           ;     while ((CYFISNP_State & CYFISNP_COMPLETE) == 0) {
 03C4                   .dbline 701
 03C4           ;         CYFISNP_GetTransmitState();
 03C4 10                push X
 03C5 7C0000            xcall _CYFISNP_GetTransmitState
 03C8 20                pop X
 03C9                   .dbline 702
 03C9           ;     }
 03C9           L87:
 03C9                   .dbline 700
 03C9 470002            tst [_CYFISNP_State],2
 03CC AFF7              jz L86
 03CE                   .dbline 703
 03CE           ;     radioStateCopy = CYFISNP_State;
 03CE 5F1B00            mov [_radioStateCopy],[_CYFISNP_State]
 03D1                   .dbline 704
 03D1           ;     CYFISNP_EndTransmit();
 03D1 10                push X
 03D2 7C0000            xcall _CYFISNP_EndTransmit
 03D5 20                pop X
 03D6                   .dbline 710
 03D6           ; 
 03D6           ; 
 03D6           ;     // -------------------------------------------------------------------
 03D6           ;     // If AutoAck failed, power-down radio
 03D6           ;     // -------------------------------------------------------------------
 03D6           ;     if ((radioStateCopy & CYFISNP_ERROR) != 0) {
 03D6 471B01            tst [_radioStateCopy],1
 03D9 A011              jz L89
 03DB                   .dbline 711
 03DB           ;         CYFISNP_ForceState(CYFISNP_END_STATE_SLEEP);
 03DB                   .dbline 711
 03DB 10                push X
 03DC 5000              mov A,0
 03DE 7C0000            xcall _CYFISNP_ForceState
 03E1 20                pop X
 03E2                   .dbline 712
 03E2           ;         dynPaUpdate(0);
 03E2 5000              mov A,0
 03E4 08                push A
 03E5 96C5              xcall _dynPaUpdate
 03E7 38FF              add SP,-1
 03E9                   .dbline 713
 03E9           ;     }
 03E9 80A9              xjmp L90
 03EB           L89:
 03EB                   .dbline 718
 03EB           ;     // -------------------------------------------------------------------
 03EB           ;     // Else if AutoAck PASSED, then open ConRsp receive window
 03EB           ;     //  and spend a little more time on this channel
 03EB           ;     // -------------------------------------------------------------------
 03EB           ;     else {
 03EB                   .dbline 719
 03EB           ;         dynPaUpdate(1<<QUAL_KSHIFT);
 03EB 5008              mov A,8
 03ED 08                push A
 03EE 96BC              xcall _dynPaUpdate
 03F0 38FF              add SP,-1
 03F2                   .dbline 721
 03F2           ; 
 03F2           ;         fTsb = 0;                       // Zero Transmit Seq Bit
 03F2 551E00            mov [_fTsb],0
 03F5                   .dbline 723
 03F5           ; 
 03F5           ;         if (fGotChanAck == 0) {
 03F5 3C1100            cmp [_fGotChanAck],0
 03F8 B007              jnz L91
 03FA                   .dbline 724
 03FA           ;             fGotChanAck = 1;
 03FA                   .dbline 724
 03FA 551101            mov [_fGotChanAck],1
 03FD                   .dbline 725
 03FD           ;             onChanTxLeft = ON_ACK_CHAN_TX_MAX;
 03FD 551209            mov [_onChanTxLeft],9
 0400                   .dbline 726
 0400           ;         }
 0400           L91:
 0400                   .dbline 731
 0400           ; 
 0400           ;         #if CYFISNP_PWR_TYPE == CYFISNP_PWR_COIN
 0400           ;         rspWindowTimer = RSP_WINDOW_TIMER;
 0400           ;         #else
 0400           ;         CYFISNP_TimeSet(&rspWindowTimer, RSP_WINDOW_TIMER);
 0400 5000              mov A,0
 0402 08                push A
 0403 5003              mov A,3
 0405 08                push A
 0406 5013              mov A,>_rspWindowTimer
 0408 08                push A
 0409 5013              mov A,<_rspWindowTimer
 040B 08                push A
 040C 7C0000            xcall _CYFISNP_TimeSet
 040F 38FC              add SP,-4
 0411                   .dbline 734
 0411           ;         #endif
 0411           ; 
 0411           ;         CYFISNP_SetXactConfig(XACT_STATE_IDLE); // Ok because in SYNTH
 0411 10                push X
 0412 5085              mov A,-123
 0414 7C0000            xcall _CYFISNP_SetXactConfig
 0417 20                pop X
 0418                   .dbline 735
 0418           ;         issueRxGo();
 0418 9150              xcall _issueRxGo
 041A                   .dbline 737
 041A           ; 
 041A           ;         for (;;) {
 041A           L93:
 041A                   .dbline 737
 041A                   .dbline 738
 041A           ;             BYTE rxLen = 0;
 041A 560000            mov [X+0],0
 041D                   .dbline 739
 041D           ;             radioStateCopy = CYFISNP_GetReceiveState();
 041D 10                push X
 041E 7C0000            xcall _CYFISNP_GetReceiveState
 0421 20                pop X
 0422 531B              mov [_radioStateCopy],A
 0424                   .dbline 746
 0424           ; 
 0424           ;             // If Receive Window Expired, then ABORT Receive and EXIT
 0424           ;             #if CYFISNP_PWR_TYPE == CYFISNP_PWR_COIN
 0424           ;             CYFISNP_Delay100uS();                 // Delay 100 uS
 0424           ;             if (--rspWindowTimer == 0) {
 0424           ;             #else
 0424           ;             if (CYFISNP_TimeExpired(&rspWindowTimer)) {
 0424 5013              mov A,>_rspWindowTimer
 0426 08                push A
 0427 5013              mov A,<_rspWindowTimer
 0429 08                push A
 042A 7C0000            xcall _CYFISNP_TimeExpired
 042D 38FE              add SP,-2
 042F 3900              cmp A,0
 0431 A016              jz L97
 0433                   .dbline 748
 0433           ;             #endif
 0433           ;                 rxLen = CYFISNP_Abort();
 0433                   .dbline 748
 0433 10                push X
 0434 7C0000            xcall _CYFISNP_Abort
 0437 20                pop X
 0438 5400              mov [X+0],A
 043A                   .dbline 749
 043A           ;                 if (rxLen == NO_RX_PACKET) {
 043A 3D00FF            cmp [X+0],-1
 043D B00A              jnz L99
 043F                   .dbline 750
 043F           ;                     CYFISNP_ForceState(CYFISNP_END_STATE_SLEEP);
 043F                   .dbline 750
 043F 10                push X
 0440 5000              mov A,0
 0442 7C0000            xcall _CYFISNP_ForceState
 0445 20                pop X
 0446                   .dbline 751
 0446           ;                     break;
 0446 804C              xjmp L95
 0448           L99:
 0448                   .dbline 753
 0448           ;                 }   // Else got Rx packet instead, fallthru and process it.
 0448           ;             }
 0448           L97:
 0448                   .dbline 754
 0448           ;             if (radioStateCopy & CYFISNP_ERROR) {
 0448 471B01            tst [_radioStateCopy],1
 044B A00D              jz L101
 044D                   .dbline 755
 044D           ;                 CYFISNP_EndReceive();
 044D                   .dbline 755
 044D 10                push X
 044E 7C0000            xcall _CYFISNP_EndReceive
 0451                   .dbline 756
 0451           ;                 CYFISNP_ForceState(CYFISNP_END_STATE_SLEEP);
 0451 5000              mov A,0
 0453 7C0000            xcall _CYFISNP_ForceState
 0456 20                pop X
 0457                   .dbline 757
 0457           ;                 break;
 0457 803B              xjmp L95
 0459           L101:
 0459                   .dbline 759
 0459           ;             }
 0459           ;             if (radioStateCopy & CYFISNP_COMPLETE) {
 0459 471B02            tst [_radioStateCopy],2
 045C AFBD              jz L93
 045E                   .dbline 760
 045E           ;                 rxLen = CYFISNP_EndReceive();
 045E                   .dbline 760
 045E 10                push X
 045F 7C0000            xcall _CYFISNP_EndReceive
 0462 20                pop X
 0463 5400              mov [X+0],A
 0465                   .dbline 761
 0465           ;                 CYFISNP_ForceState(CYFISNP_END_STATE_SLEEP);
 0465 10                push X
 0466 5000              mov A,0
 0468 7C0000            xcall _CYFISNP_ForceState
 046B 20                pop X
 046C                   .dbline 765
 046C           ;                 // -----------------------------------------------------------
 046C           ;                 // If ConRsp received, then process and goto DATA_MODE
 046C           ;                 // -----------------------------------------------------------
 046C           ;                 if (                 SNP_rxBuf.snp.pkt[0] == PKT_CONRSP_TYPE
 046C 3C2910            cmp [_SNP_rxBuf+3],16
 046F BFAA              jnz L93
 0471 3D0006            cmp [X+0],6
 0474 BFA5              jnz L93
 0476 502B              mov A,>_SNP_rxBuf+3+2
 0478 08                push A
 0479 502B              mov A,<_SNP_rxBuf+3+2
 047B 08                push A
 047C 94A5              xcall _rxMidEquNodeMid
 047E 38FE              add SP,-2
 0480 3901              cmp A,1
 0482 BF97              jnz L93
 0484                   .dbline 769
 0484           ;                 &&                                  rxLen == PKT_CONRSP_LEN
 0484           ;                 && rxMidEquNodeMid(&SNP_rxBuf.snp.pkt[2]) == TRUE
 0484           ;                 ) {
 0484           ;                     if (SNP_rxBuf.snp.pkt[1] != 0) { // ConRsp has devId != 0
 0484                   .dbline 769
 0484 3C2A00            cmp [_SNP_rxBuf+3+1],0
 0487 A005              jz L110
 0489                   .dbline 770
 0489           ;                         gotoDataMode();
 0489                   .dbline 770
 0489 90AC              xcall _gotoDataMode
 048B                   .dbline 771
 048B           ;                         return;         // Connect SUCCESSFUL ----- EXIT HERE
 048B 8007              xjmp L77
 048D           L110:
 048D                   .dbline 773
 048D           ;                     }
 048D           ;                     else {              // ConRsp has devId == 0
 048D                   .dbline 774
 048D           ;                         CYFISNP_Unbind();  // UNBIND ################
 048D 957F              xcall _CYFISNP_Unbind
 048F                   .dbline 775
 048F           ;                         gotoUnboundMode();
 048F 9C77              xcall _gotoUnboundMode
 0491                   .dbline 776
 0491           ;                     }
 0491                   .dbline 777
 0491           ;                 }
 0491                   .dbline 778
 0491           ;             } // if (radioStateCopy ....
 0491                   .dbline 779
 0491           ;         }
 0491                   .dbline 737
 0491                   .dbline 737
 0491 8F88              xjmp L93
 0493           L95:
 0493                   .dbline 780
 0493           ;     }       // Exit "got autoack"
 0493           L90:
 0493                   .dbline -2
 0493           L77:
 0493 20                pop X
 0494 20                pop X
 0495                   .dbline 0 ; func end
 0495 7F                ret
 0496                   .dbsym l rxLen 0 c
 0496                   .dbend
 0496                   .dbfunc e CYFISNP_TxDataPend _CYFISNP_TxDataPend fc
 0496           _CYFISNP_TxDataPend::
 0496                   .dbline -1
 0496                   .dbline 792
 0496           ; }
 0496           ; // ###########################################################################
 0496           ; 
 0496           ; 
 0496           ; 
 0496           ; // ---------------------------------------------------------------------------
 0496           ; //
 0496           ; // CYFISNP_TxDataPend()
 0496           ; //
 0496           ; // ---------------------------------------------------------------------------
 0496           ; BOOL CYFISNP_TxDataPend(void)
 0496           ; {
 0496                   .dbline 793
 0496           ;     if (txPending == 0) {
 0496 3C1500            cmp [_txPending],0
 0499 B005              jnz L115
 049B                   .dbline 794
 049B           ;         return(FALSE);
 049B                   .dbline 794
 049B 5000              mov A,0
 049D 8003              xjmp L114
 049F           L115:
 049F                   .dbline 796
 049F           ;     }
 049F           ;     return(TRUE);
 049F 5001              mov A,1
 04A1                   .dbline -2
 04A1           L114:
 04A1                   .dbline 0 ; func end
 04A1 7F                ret
 04A2                   .dbend
 04A2                   .dbfunc e CYFISNP_TxDataPut _CYFISNP_TxDataPut fc
 04A2                   .dbstruct 0 18 .4
 04A2                   .dbfield 0 length c
 04A2                   .dbfield 1 rssi c
 04A2                   .dbfield 2 type c
 04A2                   .dbfield 3 devId c
 04A2                   .dbfield 4 payload A[14:14]c
 04A2                   .dbend
 04A2           ;         lvType -> X+0
 04A2           ;        pStruct -> X-5
 04A2           _CYFISNP_TxDataPut::
 04A2                   .dbline -1
 04A2 10                push X
 04A3 4F                mov X,SP
 04A4 3803              add SP,3
 04A6                   .dbline 805
 04A6           ; }
 04A6           ; 
 04A6           ; // ---------------------------------------------------------------------------
 04A6           ; //
 04A6           ; // CYFISNP_TxDataPut()
 04A6           ; //
 04A6           ; // ---------------------------------------------------------------------------
 04A6           ; BOOL CYFISNP_TxDataPut(CYFISNP_API_PKT *pStruct)
 04A6           ; {
 04A6                   .dbline 806
 04A6           ;     BYTE lvType = PKT_DATA_FCD_TYPE;
 04A6 560020            mov [X+0],32
 04A9                   .dbline 808
 04A9           ; 
 04A9           ;     switch (pStruct->type) {
 04A9 52FC              mov A,[X-4]
 04AB 0102              add A,2
 04AD 5300              mov [__r1],A
 04AF 3E00              mvi A,[__r1]
 04B1 5402              mov [X+2],A
 04B3 560100            mov [X+1],0
 04B6 5202              mov A,[X+2]
 04B8 1120              sub A,32
 04BA 5300              mov [__rY],A
 04BC 5201              mov A,[X+1]
 04BE 3180              xor A,-128
 04C0 1980              sbb A,(0 ^ 0x80)
 04C2 2A00              or A,[__rY]
 04C4 A02D              jz L121
 04C6 D00D              jnc L126
 04C8           X9:
 04C8           L125:
 04C8 3D0100            cmp [X+1],0
 04CB B006              jnz X10
 04CD 3D0210            cmp [X+2],16
 04D0 A024              jz L122
 04D2           X10:
 04D2 8036              xjmp L118
 04D4           L126:
 04D4 5202              mov A,[X+2]
 04D6 1130              sub A,48
 04D8 5300              mov [__rY],A
 04DA 5201              mov A,[X+1]
 04DC 3180              xor A,-128
 04DE 1980              sbb A,(0 ^ 0x80)
 04E0 C028              jc L118
 04E2 2A00              or A,[__rY]
 04E4 A01C              jz L124
 04E6           X11:
 04E6           L127:
 04E6 3D0100            cmp [X+1],0
 04E9 B006              jnz X12
 04EB 3D0240            cmp [X+2],64
 04EE A00F              jz L123
 04F0           X12:
 04F0 8018              xjmp L118
 04F2           L121:
 04F2                   .dbline 810
 04F2           ;         case CYFISNP_API_TYPE_CONF_BCDR:
 04F2           ;             lvType |= PKT_BCDR_MASK;
 04F2 2F0004            or [X+0],4
 04F5           L122:
 04F5                   .dbline 813
 04F5           ;             // fallthru
 04F5           ;         case CYFISNP_API_TYPE_CONF:
 04F5           ;             lvType |= fTsb;               // Add Tx Seq Bit in Hdr
 04F5 511E              mov A,[_fTsb]
 04F7 2D00              or [X+0],A
 04F9                   .dbline 814
 04F9           ;             bDataRetryCt = CYFISNP_DATA_PACKET_RETRIES;
 04F9 55180A            mov [_bDataRetryCt],10
 04FC                   .dbline 815
 04FC           ;             break;
 04FC 8010              xjmp L119
 04FE           L123:
 04FE                   .dbline 818
 04FE           ;         // -------------------------------------------------------------------
 04FE           ;         case CYFISNP_API_TYPE_SYNC_BCDR:
 04FE           ;             lvType |= PKT_BCDR_MASK;  // Add BCDR bit
 04FE 2F0004            or [X+0],4
 0501           L124:
 0501                   .dbline 821
 0501           ;             // fallthru
 0501           ;         case CYFISNP_API_TYPE_SYNC:
 0501           ;             lvType |= PKT_SEQSYNC;          // Add Sync (no deliv conf needed)
 0501 2F0002            or [X+0],2
 0504                   .dbline 822
 0504           ;             bDataRetryCt = CYFISNP_DATA_PACKET_RETRIES;
 0504 55180A            mov [_bDataRetryCt],10
 0507                   .dbline 823
 0507           ;             break;
 0507 8005              xjmp L119
 0509           L118:
 0509                   .dbline 826
 0509           ;         // -------------------------------------------------------------------
 0509           ;         default:        // Ignore everything else
 0509           ;             return FALSE;
 0509 5000              mov A,0
 050B 8027              xjmp L117
 050D           L119:
 050D                   .dbline 829
 050D           ;     }
 050D           ; 
 050D           ;     pStruct->type  = lvType;
 050D 52FC              mov A,[X-4]
 050F 0102              add A,2
 0511 5300              mov [__r1],A
 0513 5200              mov A,[X+0]
 0515 3F00              mvi [__r1],A
 0517                   .dbline 830
 0517           ;     pStruct->devId = CYFISNP_EEP_NET_REC_ADR->devId;
 0517 503F              mov A,63
 0519 10                push X
 051A 57C5              mov X,-59
 051C 28                romx
 051D 20                pop X
 051E 5300              mov [__r0],A
 0520 52FC              mov A,[X-4]
 0522 0103              add A,3
 0524 5300              mov [__r3],A
 0526 5100              mov A,[__r0]
 0528 3F00              mvi [__r3],A
 052A                   .dbline 831
 052A           ;     pTxStruct      = pStruct;           // Point to API structure
 052A 52FC              mov A,[X-4]
 052C 5317              mov [_pTxStruct+1],A
 052E                   .dbline 832
 052E           ;     txPending = TRUE;
 052E 551501            mov [_txPending],1
 0531                   .dbline 833
 0531           ;     return TRUE;
 0531 5001              mov A,1
 0533                   .dbline -2
 0533           L117:
 0533 38FD              add SP,-3
 0535 20                pop X
 0536                   .dbline 0 ; func end
 0536 7F                ret
 0537                   .dbsym l lvType 0 c
 0537                   .dbsym l pStruct -5 pS[.4]
 0537                   .dbend
 0537                   .dbfunc s gotoDataMode _gotoDataMode fV
 0537           _gotoDataMode:
 0537                   .dbline -1
 0537                   .dbline 846
 0537           ; }
 0537           ; 
 0537           ; 
 0537           ; 
 0537           ; // ---------------------------------------------------------------------------
 0537           ; //
 0537           ; //  gotoDataMode() - From Connect or Ping Mode to Data Mode
 0537           ; //
 0537           ; //   runDataMode() - Send a Tx Data packet
 0537           ; //
 0537           ; // ---------------------------------------------------------------------------
 0537           ; static void gotoDataMode(void)
 0537           ; {
 0537                   .dbline 847
 0537           ;     CYFISNP_OutStr("\n\rStart Data Mode. ");
 0537                   .dbline 848
 0537           ;     setMaxPaLevel();
 0537 971C              xcall _setMaxPaLevel
 0539                   .dbline 849
 0539           ;     CYFISNP_eProtState = CYFISNP_DATA_MODE;
 0539 553B40            mov [_CYFISNP_eProtState],64
 053C                   .dbline 850
 053C           ;     if (CYFISNP_TxDataPend() == TRUE) {        // If Tx Data pending
 053C 9F58              xcall _CYFISNP_TxDataPend
 053E 3901              cmp A,1
 0540 B006              jnz L129
 0542                   .dbline 851
 0542           ;         bDataRetryCt = CYFISNP_DATA_PACKET_RETRIES; // Then retry some more
 0542                   .dbline 851
 0542 55180A            mov [_bDataRetryCt],10
 0545                   .dbline 852
 0545           ;         CYFISNP_Jog();
 0545 9B4D              xcall _CYFISNP_Jog
 0547                   .dbline 853
 0547           ;     }
 0547           L129:
 0547                   .dbline 854
 0547           ;     if (idleReceive) {
 0547 3C1900            cmp [_idleReceive],0
 054A A01E              jz L131
 054C                   .dbline 855
 054C           ;         CYFISNP_ForceState(CYFISNP_END_STATE_IDLE);     // Manually wake
 054C                   .dbline 855
 054C 10                push X
 054D 5004              mov A,4
 054F 7C0000            xcall _CYFISNP_ForceState
 0552 20                pop X
 0553                   .dbline 856
 0553           ;         issueRxGo();                                    // Enter Receive
 0553 9015              xcall _issueRxGo
 0555                   .dbline 857
 0555           ;         CYFISNP_inRxGo = TRUE;
 0555 550501            mov [_CYFISNP_inRxGo],1
 0558                   .dbline 858
 0558           ;         CYFISNP_TimeSet(&beaconMaxTimer, BEACON_MAX_TIME);
 0558 5000              mov A,0
 055A 08                push A
 055B 50BB              mov A,-69
 055D 08                push A
 055E 5006              mov A,>_beaconMaxTimer
 0560 08                push A
 0561 5006              mov A,<_beaconMaxTimer
 0563 08                push A
 0564 7C0000            xcall _CYFISNP_TimeSet
 0567 38FC              add SP,-4
 0569                   .dbline 859
 0569           ;     }
 0569           L131:
 0569                   .dbline -2
 0569           L128:
 0569                   .dbline 0 ; func end
 0569 7F                ret
 056A                   .dbend
 056A                   .dbfunc s issueRxGo _issueRxGo fV
 056A           _issueRxGo:
 056A                   .dbline -1
 056A                   .dbline 866
 056A           ; }
 056A           ; 
 056A           ; 
 056A           ; // ---------------------------------------------------------------------------
 056A           ; // issueRxGo() -
 056A           ; // ---------------------------------------------------------------------------
 056A           ; static void issueRxGo(void) {
 056A                   .dbline 867
 056A           ;     CYFISNP_SetPtr      (&SNP_rxBuf.snp.pkt[0]);
 056A 10                push X
 056B 5029              mov A,>_SNP_rxBuf+3
 056D 5729              mov X,<_SNP_rxBuf+3
 056F 7C0000            xcall _CYFISNP_SetPtr
 0572                   .dbline 868
 0572           ;     CYFISNP_SetLength   (PHYSICAL_BCD_PACKET_MAX);
 0572 500A              mov A,10
 0574 7C0000            xcall _CYFISNP_SetLength
 0577 20                pop X
 0578                   .dbline 869
 0578           ;     setNodeSeed();
 0578 9A86              xcall _setNodeSeed
 057A                   .dbline 870
 057A           ;     CYFISNP_StartReceive();
 057A 10                push X
 057B 7C0000            xcall _CYFISNP_StartReceive
 057E 20                pop X
 057F                   .dbline -2
 057F           L133:
 057F                   .dbline 0 ; func end
 057F 7F                ret
 0580                   .dbend
 0580                   .dbfunc s setIdleReceive _setIdleReceive fV
 0580           ;         enable -> X-4
 0580           _setIdleReceive:
 0580                   .dbline -1
 0580 10                push X
 0581 4F                mov X,SP
 0582                   .dbline 880
 0582           ; }
 0582           ; 
 0582           ; // ---------------------------------------------------------------------------
 0582           ; // setIdleReceive() - Application may idle in Receive or Sleep
 0582           ; //
 0582           ; // Used in a hybrid node, where SLEEPs most of the time, but infrequently
 0582           ; //  wants to do Application delineated periods of low-latency back channel
 0582           ; //  data (for example Vista SideShow traffic).
 0582           ; // ---------------------------------------------------------------------------
 0582           ; static void setIdleReceive(BOOL enable) {
 0582                   .dbline 882
 0582           ; 
 0582           ;     if (idleReceive != enable) {
 0582 5119              mov A,[_idleReceive]
 0584 3BFC              cmp A,[X-4]
 0586 A03D              jz L136
 0588                   .dbline 883
 0588           ;         idleReceive = enable;
 0588                   .dbline 883
 0588 52FC              mov A,[X-4]
 058A 5319              mov [_idleReceive],A
 058C                   .dbline 884
 058C           ;         if (enable == FALSE) {
 058C 3DFC00            cmp [X-4],0
 058F B012              jnz L138
 0591                   .dbline 885
 0591           ;             rxLen = CYFISNP_Abort();                        // Stop Receive
 0591                   .dbline 885
 0591 10                push X
 0592 7C0000            xcall _CYFISNP_Abort
 0595 20                pop X
 0596 531A              mov [_rxLen],A
 0598                   .dbline 886
 0598           ;             CYFISNP_ForceState(CYFISNP_END_STATE_SLEEP);    // Low power
 0598 10                push X
 0599 5000              mov A,0
 059B 7C0000            xcall _CYFISNP_ForceState
 059E 20                pop X
 059F                   .dbline 887
 059F           ;             CYFISNP_inRxGo = FALSE;
 059F 550500            mov [_CYFISNP_inRxGo],0
 05A2                   .dbline 888
 05A2           ;         }
 05A2           L138:
 05A2                   .dbline 889
 05A2           ;         if (enable == TRUE) {
 05A2 3DFC01            cmp [X-4],1
 05A5 B01E              jnz L140
 05A7                   .dbline 890
 05A7           ;             CYFISNP_ForceState(CYFISNP_END_STATE_IDLE);     // Manually wake
 05A7                   .dbline 890
 05A7 10                push X
 05A8 5004              mov A,4
 05AA 7C0000            xcall _CYFISNP_ForceState
 05AD 20                pop X
 05AE                   .dbline 891
 05AE           ;             issueRxGo();                                    // Enter Receive
 05AE 9FBA              xcall _issueRxGo
 05B0                   .dbline 892
 05B0           ;             CYFISNP_inRxGo = TRUE;
 05B0 550501            mov [_CYFISNP_inRxGo],1
 05B3                   .dbline 893
 05B3           ;             CYFISNP_TimeSet(&beaconMaxTimer, BEACON_MAX_TIME);
 05B3 5000              mov A,0
 05B5 08                push A
 05B6 50BB              mov A,-69
 05B8 08                push A
 05B9 5006              mov A,>_beaconMaxTimer
 05BB 08                push A
 05BC 5006              mov A,<_beaconMaxTimer
 05BE 08                push A
 05BF 7C0000            xcall _CYFISNP_TimeSet
 05C2 38FC              add SP,-4
 05C4                   .dbline 894
 05C4           ;        }
 05C4           L140:
 05C4                   .dbline 895
 05C4           ;     }
 05C4           L136:
 05C4                   .dbline -2
 05C4           L135:
 05C4 20                pop X
 05C5                   .dbline 0 ; func end
 05C5 7F                ret
 05C6                   .dbsym l enable -4 c
 05C6                   .dbend
 05C6                   .dbfunc s runDataMode _runDataMode fV
 05C6           ;        statReg -> X+0
 05C6           _runDataMode:
 05C6                   .dbline -1
 05C6 10                push X
 05C7 4F                mov X,SP
 05C8 10                push X
 05C9                   .dbline 912
 05C9           ; }
 05C9           ; 
 05C9           ; 
 05C9           ; 
 05C9           ; // ---------------------------------------------------------------------------
 05C9           ; //
 05C9           ; // runDataMode() - Handle Data Mode polled processes.
 05C9           ; //
 05C9           ; //  If radio idles in Receive, this includes servicing and rearming the
 05C9           ; //   radio receiver.  Idling in Receive also means an Rx Abort process before
 05C9           ; //   transmitting a packer.
 05C9           ; //
 05C9           ; //  If radio idles in Sleep, only monitor and service a pending Tx packet.
 05C9           ; //
 05C9           ; // ---------------------------------------------------------------------------
 05C9           ; static void runDataMode(void)
 05C9           ; {
 05C9                   .dbline 913
 05C9           ;     rxLen = NO_RX_PACKET;
 05C9 551AFF            mov [_rxLen],-1
 05CC                   .dbline 918
 05CC           ; 
 05CC           ;     // -----------------------------------------------------------------------
 05CC           ;     // If Tx Data is pending, service it
 05CC           ;     // -----------------------------------------------------------------------
 05CC           ;     if (bDataRetryCt != 0) {
 05CC 3C1800            cmp [_bDataRetryCt],0
 05CF A01D              jz L143
 05D1                   .dbline 919
 05D1           ;         if (CYFISNP_inRxGo == TRUE) {       // If RX_GO invoked,
 05D1                   .dbline 919
 05D1 3C0501            cmp [_CYFISNP_inRxGo],1
 05D4 B00B              jnz L145
 05D6                   .dbline 920
 05D6           ;             rxLen = CYFISNP_Abort();    //  Then Abort (might get Rx pkt)
 05D6                   .dbline 920
 05D6 10                push X
 05D7 7C0000            xcall _CYFISNP_Abort
 05DA 20                pop X
 05DB 531A              mov [_rxLen],A
 05DD                   .dbline 921
 05DD           ;             CYFISNP_inRxGo = FALSE;
 05DD 550500            mov [_CYFISNP_inRxGo],0
 05E0                   .dbline 922
 05E0           ;         }
 05E0           L145:
 05E0                   .dbline 923
 05E0           ;         if (rxLen == NO_RX_PACKET) {    // Normal case, Rx aborted w/o RxPkt
 05E0 3C1AFF            cmp [_rxLen],-1
 05E3 B005              jnz L147
 05E5                   .dbline 924
 05E5           ;             runDataModeTx();            // Service pending Tx Data
 05E5                   .dbline 924
 05E5 90F2              xcall _runDataModeTx
 05E7                   .dbline 925
 05E7           ;             return;
 05E7 8083              xjmp L142
 05E9           L147:
 05E9                   .dbline 926
 05E9           ;         } else {                        // Rx Aborted WITH Rx Packet received
 05E9                   .dbline 927
 05E9           ;             runDataModeRx();            // Service Rx packet
 05E9 9083              xcall _runDataModeRx
 05EB                   .dbline 928
 05EB           ;             return;                     // Exit w/o RX_GO
 05EB 807F              xjmp L142
 05ED           L143:
 05ED                   .dbline 935
 05ED           ;         }
 05ED           ;     }
 05ED           ; 
 05ED           ;     // -----------------------------------------------------------------------
 05ED           ;     // If IDLE in RECEIVE Mode, then
 05ED           ;     // -----------------------------------------------------------------------
 05ED           ;     if (idleReceive) {
 05ED 3C1900            cmp [_idleReceive],0
 05F0 A07A              jz L149
 05F2                   .dbline 940
 05F2           ; 
 05F2           ;         // -------------------------------------------------------------------
 05F2           ;         // Watch for missing Hub Beacon
 05F2           ;         // -------------------------------------------------------------------
 05F2           ;         if (CYFISNP_TimeExpired(&beaconMaxTimer)) {
 05F2                   .dbline 940
 05F2 5006              mov A,>_beaconMaxTimer
 05F4 08                push A
 05F5 5006              mov A,<_beaconMaxTimer
 05F7 08                push A
 05F8 7C0000            xcall _CYFISNP_TimeExpired
 05FB 38FE              add SP,-2
 05FD 3900              cmp A,0
 05FF A029              jz L151
 0601                   .dbline 941
 0601           ;             rxLen = CYFISNP_Abort();
 0601                   .dbline 941
 0601 10                push X
 0602 7C0000            xcall _CYFISNP_Abort
 0605 20                pop X
 0606 531A              mov [_rxLen],A
 0608                   .dbline 942
 0608           ;             CYFISNP_inRxGo = FALSE;
 0608 550500            mov [_CYFISNP_inRxGo],0
 060B                   .dbline 943
 060B           ;             if (rxLen == NO_RX_PACKET) {
 060B 3C1AFF            cmp [_rxLen],-1
 060E B005              jnz L153
 0610                   .dbline 944
 0610           ;                 gotoPingMode();         // Beacon Timeout
 0610                   .dbline 944
 0610 9209              xcall _gotoPingMode
 0612                   .dbline 945
 0612           ;             } else {
 0612 8058              xjmp L142
 0614           L153:
 0614                   .dbline 945
 0614                   .dbline 946
 0614           ;                 CYFISNP_TimeSet(&beaconMaxTimer, BEACON_MAX_TIME);
 0614 5000              mov A,0
 0616 08                push A
 0617 50BB              mov A,-69
 0619 08                push A
 061A 5006              mov A,>_beaconMaxTimer
 061C 08                push A
 061D 5006              mov A,<_beaconMaxTimer
 061F 08                push A
 0620 7C0000            xcall _CYFISNP_TimeSet
 0623 38FC              add SP,-4
 0625                   .dbline 947
 0625           ;                 runDataModeRx();        // Service Rx Packet
 0625 9047              xcall _runDataModeRx
 0627                   .dbline 948
 0627           ;             }
 0627                   .dbline 949
 0627           ;             return;
 0627 8043              xjmp L142
 0629           L151:
 0629                   .dbline 955
 0629           ;         }
 0629           ; 
 0629           ;         // -------------------------------------------------------------------
 0629           ;         // Ensure in RX_GO
 0629           ;         // -------------------------------------------------------------------
 0629           ;         if (CYFISNP_inRxGo == FALSE) {      // If not in Receive
 0629 3C0500            cmp [_CYFISNP_inRxGo],0
 062C B00D              jnz L155
 062E                   .dbline 956
 062E           ;             CYFISNP_ForceState(CYFISNP_END_STATE_RXSYNTH);
 062E                   .dbline 956
 062E 10                push X
 062F 500C              mov A,12
 0631 7C0000            xcall _CYFISNP_ForceState
 0634 20                pop X
 0635                   .dbline 957
 0635           ;             issueRxGo();                //  Then get in Receive
 0635 9F33              xcall _issueRxGo
 0637                   .dbline 958
 0637           ;             CYFISNP_inRxGo = TRUE;
 0637 550501            mov [_CYFISNP_inRxGo],1
 063A                   .dbline 959
 063A           ;         }
 063A           L155:
 063A                   .dbline 964
 063A           ; 
 063A           ;         // -------------------------------------------------------------------
 063A           ;         // Monitor and service received packet
 063A           ;         // -------------------------------------------------------------------
 063A           ;         radioStateCopy = CYFISNP_GetReceiveState();
 063A 10                push X
 063B 7C0000            xcall _CYFISNP_GetReceiveState
 063E 20                pop X
 063F 531B              mov [_radioStateCopy],A
 0641                   .dbline 965
 0641           ;         if (radioStateCopy & CYFISNP_COMPLETE) {
 0641 471B02            tst [_radioStateCopy],2
 0644 A026              jz L157
 0646                   .dbline 966
 0646           ;             rxLen = CYFISNP_EndReceive();
 0646                   .dbline 966
 0646 10                push X
 0647 7C0000            xcall _CYFISNP_EndReceive
 064A 20                pop X
 064B 531A              mov [_rxLen],A
 064D                   .dbline 967
 064D           ;             if (radioStateCopy & CYFISNP_ERROR) {
 064D 471B01            tst [_radioStateCopy],1
 0650 A016              jz L159
 0652                   .dbline 973
 0652           ;                 // -----------------------------------------------------------
 0652           ;                 // Rx CRC0 Packets report as ERROR because DIS_CRC0 is SET
 0652           ;                 //  during node Receive to suppress AutoAck, BUT CRC0 packets
 0652           ;                 //  have RX_CRC0 status SET indicating they're OK
 0652           ;                 // -----------------------------------------------------------
 0652           ;                 char statReg;
 0652                   .dbline 974
 0652           ;                 statReg  = CYFISNP_Read(CYFISNP_RX_STATUS_ADR);
 0652 10                push X
 0653 5008              mov A,8
 0655 7C0000            xcall _CYFISNP_Read
 0658 20                pop X
 0659 5400              mov [X+0],A
 065B                   .dbline 975
 065B           ;                 statReg &= CYFISNP_RX_PKTERR|CYFISNP_RX_EOPERR|CYFISNP_RX_CRC0;
 065B 270070            and [X+0],112
 065E                   .dbline 976
 065E           ;                 if (statReg == CYFISNP_RX_CRC0) {
 065E 3D0010            cmp [X+0],16
 0661 B007              jnz L160
 0663                   .dbline 977
 0663           ;                     runDataModeRxCrc0();    // Rx packet used CRC0 (no error)
 0663                   .dbline 977
 0663 9062              xcall _runDataModeRxCrc0
 0665                   .dbline 978
 0665           ;                 } else {
 0665                   .dbline 978
 0665                   .dbline 980
 0665           ;                     // silently discard Rx packet w/Error
 0665           ;                 }
 0665                   .dbline 981
 0665           ;             }
 0665 8003              xjmp L160
 0667           L159:
 0667                   .dbline 982
 0667           ;             else {
 0667                   .dbline 983
 0667           ;                 runDataModeRx();        // Service receiver
 0667 9005              xcall _runDataModeRx
 0669                   .dbline 984
 0669           ;             }
 0669           L160:
 0669                   .dbline 985
 0669           ;             issueRxGo();                // Rearm Receiver
 0669 9EFF              xcall _issueRxGo
 066B                   .dbline 986
 066B           ;         }
 066B           L157:
 066B                   .dbline 987
 066B           ;     }
 066B           L149:
 066B                   .dbline -2
 066B           L142:
 066B 20                pop X
 066C 20                pop X
 066D                   .dbline 0 ; func end
 066D 7F                ret
 066E                   .dbsym l statReg 0 c
 066E                   .dbend
 066E                   .dbfunc s runDataModeRx _runDataModeRx fV
 066E           ;       lvRxType -> X+0
 066E           _runDataModeRx:
 066E                   .dbline -1
 066E 10                push X
 066F 4F                mov X,SP
 0670 3803              add SP,3
 0672                   .dbline 998
 0672           ; }
 0672           ; 
 0672           ; 
 0672           ; // ---------------------------------------------------------------------------
 0672           ; //
 0672           ; // runDataModeRx() - Received good packet (non-CRC0 Seed), process it
 0672           ; //
 0672           ; //          rxLen = length of received packet
 0672           ; // ---------------------------------------------------------------------------
 0672           ; static void runDataModeRx(void)
 0672           ; {
 0672                   .dbline 1000
 0672           ;     BYTE lvRxType;
 0672           ;     lvRxType = SNP_rxBuf.snp.pkt[0];
 0672 5129              mov A,[_SNP_rxBuf+3]
 0674 5400              mov [X+0],A
 0676                   .dbline 1002
 0676           ; 
 0676           ;     if (rxLen == PKT_UNBIND_LEN && lvRxType == PKT_UNBIND_TYPE) {
 0676 3C1A02            cmp [_rxLen],2
 0679 B00A              jnz L165
 067B 3D0010            cmp [X+0],16
 067E B005              jnz L165
 0680                   .dbline 1003
 0680           ;         CYFISNP_Unbind();
 0680                   .dbline 1003
 0680 938C              xcall _CYFISNP_Unbind
 0682                   .dbline 1004
 0682           ;     }
 0682 8040              xjmp L166
 0684           L165:
 0684                   .dbline 1005
 0684           ;     else if (rxLen != 0
 0684 3C1A00            cmp [_rxLen],0
 0687 A03B              jz L167
 0689 5200              mov A,[X+0]
 068B 21FC              and A,-4
 068D 3930              cmp A,48
 068F B033              jnz L167
 0691                   .dbline 1008
 0691           ;      && (lvRxType & 0xFC) == PKT_DATA_BCD_TYPE) {
 0691           ; 
 0691           ;         SNP_rxBuf.api.length = rxLen - 1;     // Get Payload Length
 0691                   .dbline 1008
 0691 511A              mov A,[_rxLen]
 0693 1101              sub A,1
 0695 5326              mov [_SNP_rxBuf],A
 0697                   .dbline 1009
 0697           ;         SNP_rxBuf.api.rssi   = CYFISNP_GetRssi()
 0697 10                push X
 0698 7C0000            xcall _CYFISNP_GetRssi
 069B 20                pop X
 069C 211F              and A,31
 069E 5327              mov [_SNP_rxBuf+1],A
 06A0                   .dbline 1012
 06A0           ;                              & CYFISNP_RSSI_LVL_MSK;
 06A0           ; 
 06A0           ;         SNP_rxBuf.api.type = (lvRxType == (PKT_DATA_BCD_TYPE+2)) ?
 06A0 3D0032            cmp [X+0],50
 06A3 B009              jnz L172
 06A5 560230            mov [X+2],48
 06A8 560100            mov [X+1],0
 06AB 8007              xjmp L173
 06AD           L172:
 06AD 560210            mov [X+2],16
 06B0 560100            mov [X+1],0
 06B3           L173:
 06B3 5202              mov A,[X+2]
 06B5 5328              mov [_SNP_rxBuf+2],A
 06B7                   .dbline 1016
 06B7           ;                                 CYFISNP_API_TYPE_SYNC :
 06B7           ;                                 CYFISNP_API_TYPE_CONF;
 06B7           ; 
 06B7           ;         SNP_rxBuf.api.devId  = CYFISNP_EEP_NET_REC_ADR->devId;
 06B7 503F              mov A,63
 06B9 10                push X
 06BA 57C5              mov X,-59
 06BC 28                romx
 06BD 20                pop X
 06BE 5329              mov [_SNP_rxBuf+3],A
 06C0                   .dbline 1017
 06C0           ;         rxBufPend = TRUE;                   // Pass packet to API
 06C0 551C01            mov [_rxBufPend],1
 06C3                   .dbline 1018
 06C3           ;     }
 06C3           L167:
 06C3           L166:
 06C3                   .dbline -2
 06C3           L163:
 06C3 38FD              add SP,-3
 06C5 20                pop X
 06C6                   .dbline 0 ; func end
 06C6 7F                ret
 06C7                   .dbsym l lvRxType 0 c
 06C7                   .dbend
 06C7                   .dbfunc s runDataModeRxCrc0 _runDataModeRxCrc0 fV
 06C7           _runDataModeRxCrc0:
 06C7                   .dbline -1
 06C7                   .dbline 1027
 06C7           ; }
 06C7           ; 
 06C7           ; // ---------------------------------------------------------------------------
 06C7           ; //
 06C7           ; // runDataModeRxCrc0() - Received good CRC0 packet, process it
 06C7           ; //
 06C7           ; //          rxLen = length of received packet
 06C7           ; // ---------------------------------------------------------------------------
 06C7           ; static void runDataModeRxCrc0(void) {
 06C7                   .dbline 1028
 06C7           ;     CYFISNP_TimeSet(&beaconMaxTimer, BEACON_MAX_TIME);
 06C7 5000              mov A,0
 06C9 08                push A
 06CA 50BB              mov A,-69
 06CC 08                push A
 06CD 5006              mov A,>_beaconMaxTimer
 06CF 08                push A
 06D0 5006              mov A,<_beaconMaxTimer
 06D2 08                push A
 06D3 7C0000            xcall _CYFISNP_TimeSet
 06D6 38FC              add SP,-4
 06D8                   .dbline -2
 06D8           L175:
 06D8                   .dbline 0 ; func end
 06D8 7F                ret
 06D9                   .dbend
 06D9                   .dbfunc s runDataModeTx _runDataModeTx fV
 06D9           _runDataModeTx:
 06D9                   .dbline -1
 06D9                   .dbline 1040
 06D9           ; }
 06D9           ; 
 06D9           ; 
 06D9           ; 
 06D9           ; 
 06D9           ; // ---------------------------------------------------------------------------
 06D9           ; //
 06D9           ; // runDataModeTx() - Tx 1 Burst in a dedicated function
 06D9           ; //
 06D9           ; // ---------------------------------------------------------------------------
 06D9           ; static void runDataModeTx(void)
 06D9           ; {
 06D9                   .dbline 1041
 06D9           ;     if (--bDataRetryCt == 0) {
 06D9 161801            sub [_bDataRetryCt],1
 06DC 3C1800            cmp [_bDataRetryCt],0
 06DF B003              jnz L177
 06E1                   .dbline 1042
 06E1           ;         gotoPingMode();     // FAILED TO DELIVER PACKET, CHANGE TO PING MODE
 06E1                   .dbline 1042
 06E1 9138              xcall _gotoPingMode
 06E3                   .dbline 1043
 06E3           ;     }
 06E3           L177:
 06E3                   .dbline 1048
 06E3           ; 
 06E3           ;     // -------------------------------------------------------------------
 06E3           ;     // Transmit Data Packet
 06E3           ;     // -------------------------------------------------------------------
 06E3           ;     setHubSeed();
 06E3 9933              xcall _setHubSeed
 06E5                   .dbline 1049
 06E5           ;     dynPaApply();            // Dynamic Power
 06E5 93F6              xcall _dynPaApply
 06E7                   .dbline 1051
 06E7           ; 
 06E7           ;     if ((pTxStruct->type & PKT_BCDR_MASK) == 0 && idleReceive == FALSE) {
 06E7 5117              mov A,[_pTxStruct+1]
 06E9 0102              add A,2
 06EB 5300              mov [__r1],A
 06ED 3E00              mvi A,[__r1]
 06EF 5300              mov [__r0],A
 06F1 470004            tst [__r0],4
 06F4 B00F              jnz L179
 06F6 3C1900            cmp [_idleReceive],0
 06F9 B00A              jnz L179
 06FB                   .dbline 1052
 06FB           ;         CYFISNP_ForceState(CYFISNP_END_STATE_IDLE); // Set Radio IDLE
 06FB                   .dbline 1052
 06FB 10                push X
 06FC 5004              mov A,4
 06FE 7C0000            xcall _CYFISNP_ForceState
 0701 20                pop X
 0702                   .dbline 1053
 0702           ;     }
 0702 8008              xjmp L180
 0704           L179:
 0704                   .dbline 1054
 0704           ;     else {
 0704                   .dbline 1055
 0704           ;         CYFISNP_ForceState(CYFISNP_END_STATE_TXSYNTH); // Set Radio in SYNTH
 0704 10                push X
 0705 5008              mov A,8
 0707 7C0000            xcall _CYFISNP_ForceState
 070A 20                pop X
 070B                   .dbline 1056
 070B           ;     }
 070B           L180:
 070B                   .dbline 1058
 070B           ; 
 070B           ;     CYFISNP_SetPtr          (&pTxStruct->type);
 070B 5117              mov A,[_pTxStruct+1]
 070D 0102              add A,2
 070F 5300              mov [__r1],A
 0711 5116              mov A,[_pTxStruct]
 0713 0900              adc A,0
 0715 10                push X
 0716 5800              mov X,[__r1]
 0718 7C0000            xcall _CYFISNP_SetPtr
 071B 20                pop X
 071C                   .dbline 1059
 071C           ;     CYFISNP_StartTransmit   (0, pTxStruct->length + 2);
 071C 5F0017            mov [__r1],[_pTxStruct+1]
 071F 3E00              mvi A,[__r1]
 0721 0102              add A,2
 0723 10                push X
 0724 08                push A
 0725 5000              mov A,0
 0727 20                pop X
 0728 7C0000            xcall _CYFISNP_StartTransmit
 072B 20                pop X
 072C 8006              xjmp L182
 072E           L181:
 072E                   .dbline 1060
 072E           ;     while ((CYFISNP_State & CYFISNP_COMPLETE) == 0) {
 072E                   .dbline 1061
 072E           ;         CYFISNP_GetTransmitState();
 072E 10                push X
 072F 7C0000            xcall _CYFISNP_GetTransmitState
 0732 20                pop X
 0733                   .dbline 1062
 0733           ;     }
 0733           L182:
 0733                   .dbline 1060
 0733 470002            tst [_CYFISNP_State],2
 0736 AFF7              jz L181
 0738                   .dbline 1063
 0738           ;     radioStateCopy = CYFISNP_State;
 0738 5F1B00            mov [_radioStateCopy],[_CYFISNP_State]
 073B                   .dbline 1064
 073B           ;     CYFISNP_EndTransmit();
 073B 10                push X
 073C 7C0000            xcall _CYFISNP_EndTransmit
 073F 20                pop X
 0740                   .dbline 1069
 0740           ; 
 0740           ;     // -------------------------------------------------------------------
 0740           ;     // If AutoAck failed, Idle radio and EXIT
 0740           ;     // -------------------------------------------------------------------
 0740           ;     if ((radioStateCopy & CYFISNP_ERROR) != 0) {
 0740 471B01            tst [_radioStateCopy],1
 0743 A016              jz L184
 0745                   .dbline 1070
 0745           ;         dynPaUpdate(0);
 0745                   .dbline 1070
 0745 5000              mov A,0
 0747 08                push A
 0748 9362              xcall _dynPaUpdate
 074A 38FF              add SP,-1
 074C                   .dbline 1071
 074C           ;         if (idleReceive == FALSE) {
 074C 3C1900            cmp [_idleReceive],0
 074F B0BC              jnz L176
 0751                   .dbline 1072
 0751           ;             CYFISNP_ForceState(XACT_STATE_SLEEP);   // Manually put to SLEEP
 0751                   .dbline 1072
 0751 10                push X
 0752 5081              mov A,-127
 0754 7C0000            xcall _CYFISNP_ForceState
 0757 20                pop X
 0758                   .dbline 1073
 0758           ;         }
 0758                   .dbline 1074
 0758           ;         return;
 0758 80B3              xjmp L176
 075A           L184:
 075A                   .dbline 1076
 075A           ;     }
 075A           ;     dynPaUpdate(1<<QUAL_KSHIFT);
 075A 5008              mov A,8
 075C 08                push A
 075D 934D              xcall _dynPaUpdate
 075F 38FF              add SP,-1
 0761                   .dbline 1081
 0761           ; 
 0761           ;     // -------------------------------------------------------------------
 0761           ;     // Delivered packet
 0761           ;     // -------------------------------------------------------------------
 0761           ;     bDataRetryCt = 0;           // No more retries
 0761 551800            mov [_bDataRetryCt],0
 0764                   .dbline 1082
 0764           ;     txPending = FALSE;          // Empty API's Tx buffer
 0764 551500            mov [_txPending],0
 0767                   .dbline 1087
 0767           ; 
 0767           ;     // -------------------------------------------------------------------
 0767           ;     // Inc Transmit Seq Bit if Tx Pkt used the Tx Seq Bit
 0767           ;     // -------------------------------------------------------------------
 0767           ;     if ((pTxStruct->type & PKT_SEQBIT_MASK) < PKT_SEQSYNC) {
 0767 5117              mov A,[_pTxStruct+1]
 0769 0102              add A,2
 076B 5300              mov [__r1],A
 076D 3E00              mvi A,[__r1]
 076F 2103              and A,3
 0771 3902              cmp A,2
 0773 D004              jnc L188
 0775           X13:
 0775                   .dbline 1088
 0775           ;         fTsb ^= 1;              // Inc mod-2
 0775                   .dbline 1088
 0775 361E01            xor [_fTsb],1
 0778                   .dbline 1089
 0778           ;     }
 0778           L188:
 0778                   .dbline 1094
 0778           ; 
 0778           ;     // -------------------------------------------------------------------
 0778           ;     // If Back Channel Data Request flag was zero, exit
 0778           ;     // -------------------------------------------------------------------
 0778           ;     if ((pTxStruct->type & PKT_BCDR_MASK) == 0) {
 0778 5117              mov A,[_pTxStruct+1]
 077A 0102              add A,2
 077C 5300              mov [__r1],A
 077E 3E00              mvi A,[__r1]
 0780 5300              mov [__r0],A
 0782 470004            tst [__r0],4
 0785 B00F              jnz L190
 0787                   .dbline 1095
 0787           ;         if (idleReceive == FALSE)  {
 0787                   .dbline 1095
 0787 3C1900            cmp [_idleReceive],0
 078A B081              jnz L191
 078C                   .dbline 1096
 078C           ;             CYFISNP_ForceState(CYFISNP_END_STATE_SLEEP);
 078C                   .dbline 1096
 078C 10                push X
 078D 5000              mov A,0
 078F 7C0000            xcall _CYFISNP_ForceState
 0792 20                pop X
 0793                   .dbline 1097
 0793           ;         }
 0793                   .dbline 1098
 0793           ;     }
 0793 8078              xjmp L191
 0795           L190:
 0795                   .dbline 1102
 0795           ;     // -----------------------------------------------------------------------
 0795           ;     // Else Open Back Channel Receive Window
 0795           ;     // -----------------------------------------------------------------------
 0795           ;     else {
 0795                   .dbline 1106
 0795           ;         #if CYFISNP_PWR_TYPE == CYFISNP_PWR_COIN
 0795           ;         rspWindowTimer = (3000/200);     // 3,000 uS / 200 uS
 0795           ;         #else
 0795           ;         CYFISNP_TimeSet(&rspWindowTimer, RSP_WINDOW_TIMER);
 0795 5000              mov A,0
 0797 08                push A
 0798 5003              mov A,3
 079A 08                push A
 079B 5013              mov A,>_rspWindowTimer
 079D 08                push A
 079E 5013              mov A,<_rspWindowTimer
 07A0 08                push A
 07A1 7C0000            xcall _CYFISNP_TimeSet
 07A4 38FC              add SP,-4
 07A6                   .dbline 1109
 07A6           ;         #endif
 07A6           ; 
 07A6           ;         issueRxGo();
 07A6 9DC2              xcall _issueRxGo
 07A8                   .dbline 1114
 07A8           ; 
 07A8           ;         // -------------------------------------------------------------------
 07A8           ;         // Wait for Back Channel packet or Window Timeout
 07A8           ;         // -------------------------------------------------------------------
 07A8           ;         for (;;) {
 07A8           L194:
 07A8                   .dbline 1114
 07A8                   .dbline 1116
 07A8           ; 
 07A8           ;             radioStateCopy = CYFISNP_GetReceiveState();
 07A8 10                push X
 07A9 7C0000            xcall _CYFISNP_GetReceiveState
 07AC 20                pop X
 07AD 531B              mov [_radioStateCopy],A
 07AF                   .dbline 1125
 07AF           ; 
 07AF           ;             // ---------------------------------------------------------------
 07AF           ;             // Monitor Rx Window Timeout
 07AF           ;             // ---------------------------------------------------------------
 07AF           ;             #if CYFISNP_PWR_TYPE == CYFISNP_PWR_COIN        // Use short accurate delay
 07AF           ;             CYFISNP_Delay100uS();                       // Delay 100 uS
 07AF           ;             if (--rspWindowTimer == 0)              // to minimize power
 07AF           ;             #else                                   // ELSE Alkaline battery
 07AF           ;             if (CYFISNP_TimeExpired(&rspWindowTimer))   // use timer
 07AF 5013              mov A,>_rspWindowTimer
 07B1 08                push A
 07B2 5013              mov A,<_rspWindowTimer
 07B4 08                push A
 07B5 7C0000            xcall _CYFISNP_TimeExpired
 07B8 38FE              add SP,-2
 07BA 3900              cmp A,0
 07BC A01B              jz L198
 07BE                   .dbline 1128
 07BE           ;             #endif
 07BE           ;                 {
 07BE           ;                 rxLen = CYFISNP_Abort();
 07BE                   .dbline 1128
 07BE 10                push X
 07BF 7C0000            xcall _CYFISNP_Abort
 07C2 20                pop X
 07C3 531A              mov [_rxLen],A
 07C5                   .dbline 1129
 07C5           ;                 if (rxLen == NO_RX_PACKET) {
 07C5 3C1AFF            cmp [_rxLen],-1
 07C8 B00F              jnz L200
 07CA                   .dbline 1130
 07CA           ;                     if (idleReceive == FALSE)  {
 07CA                   .dbline 1130
 07CA 3C1900            cmp [_idleReceive],0
 07CD B03C              jnz L196
 07CF                   .dbline 1131
 07CF           ;                         CYFISNP_ForceState(CYFISNP_END_STATE_SLEEP);
 07CF                   .dbline 1131
 07CF 10                push X
 07D0 5000              mov A,0
 07D2 7C0000            xcall _CYFISNP_ForceState
 07D5 20                pop X
 07D6                   .dbline 1132
 07D6           ;                     }
 07D6                   .dbline 1133
 07D6           ;                     break;
 07D6 8033              xjmp L196
 07D8           L200:
 07D8                   .dbline 1135
 07D8           ;                 }
 07D8           ;             }
 07D8           L198:
 07D8                   .dbline 1139
 07D8           ;             // ---------------------------------------------------------------
 07D8           ;             // Monitor for Rx Packet Error
 07D8           ;             // ---------------------------------------------------------------
 07D8           ;             if (radioStateCopy & CYFISNP_ERROR) {
 07D8 471B01            tst [_radioStateCopy],1
 07DB A014              jz L204
 07DD                   .dbline 1140
 07DD           ;                 CYFISNP_EndReceive();
 07DD                   .dbline 1140
 07DD 10                push X
 07DE 7C0000            xcall _CYFISNP_EndReceive
 07E1 20                pop X
 07E2                   .dbline 1141
 07E2           ;                 if (idleReceive == FALSE)  {
 07E2 3C1900            cmp [_idleReceive],0
 07E5 B024              jnz L196
 07E7                   .dbline 1142
 07E7           ;                     CYFISNP_ForceState(CYFISNP_END_STATE_SLEEP);
 07E7                   .dbline 1142
 07E7 10                push X
 07E8 5000              mov A,0
 07EA 7C0000            xcall _CYFISNP_ForceState
 07ED 20                pop X
 07EE                   .dbline 1143
 07EE           ;                 }
 07EE                   .dbline 1144
 07EE           ;                 break;
 07EE 801B              xjmp L196
 07F0           L204:
 07F0                   .dbline 1149
 07F0           ;             }
 07F0           ;             // ---------------------------------------------------------------
 07F0           ;             // Monitor for Rx Packet Success
 07F0           ;             // ---------------------------------------------------------------
 07F0           ;             if (radioStateCopy & CYFISNP_COMPLETE) {
 07F0 471B02            tst [_radioStateCopy],2
 07F3 AFB4              jz L194
 07F5                   .dbline 1150
 07F5           ;                 rxLen = CYFISNP_EndReceive();
 07F5                   .dbline 1150
 07F5 10                push X
 07F6 7C0000            xcall _CYFISNP_EndReceive
 07F9 20                pop X
 07FA 531A              mov [_rxLen],A
 07FC                   .dbline 1151
 07FC           ;                 if (idleReceive == FALSE)  {
 07FC 3C1900            cmp [_idleReceive],0
 07FF B008              jnz L210
 0801                   .dbline 1152
 0801           ;                     CYFISNP_ForceState(CYFISNP_END_STATE_SLEEP);
 0801                   .dbline 1152
 0801 10                push X
 0802 5000              mov A,0
 0804 7C0000            xcall _CYFISNP_ForceState
 0807 20                pop X
 0808                   .dbline 1153
 0808           ;                 }
 0808           L210:
 0808                   .dbline 1154
 0808           ;                 runDataModeRx();            // Process Rx Packet
 0808 9E64              xcall _runDataModeRx
 080A                   .dbline 1155
 080A           ;                 break;
 080A                   .dbline 1157
 080A           ;             }
 080A           ;         }
 080A                   .dbline 1114
 080A                   .dbline 1114
 080A           L196:
 080A                   .dbline 1158
 080A           ;         setHubSeed();
 080A 980C              xcall _setHubSeed
 080C                   .dbline 1159
 080C           ;     } // Exit "Else Open Back Channel Receive Window"
 080C           L191:
 080C                   .dbline -2
 080C           L176:
 080C                   .dbline 0 ; func end
 080C 7F                ret
 080D                   .dbend
 080D                   .dbfunc e CYFISNP_RxDataPend _CYFISNP_RxDataPend fc
 080D           _CYFISNP_RxDataPend::
 080D                   .dbline -1
 080D                   .dbline 1168
 080D           ; }
 080D           ; 
 080D           ; 
 080D           ; 
 080D           ; // ---------------------------------------------------------------------------
 080D           ; // CYFISNP_RxDataPend()
 080D           ; // ---------------------------------------------------------------------------
 080D           ; BOOL CYFISNP_RxDataPend(void)
 080D           ; {
 080D                   .dbline 1169
 080D           ;     return (rxBufPend);
 080D 511C              mov A,[_rxBufPend]
 080F                   .dbline -2
 080F           L212:
 080F                   .dbline 0 ; func end
 080F 7F                ret
 0810                   .dbend
 0810                   .dbfunc e CYFISNP_RxDataGet _CYFISNP_RxDataGet fpS[.4]
 0810           _CYFISNP_RxDataGet::
 0810                   .dbline -1
 0810                   .dbline 1177
 0810           ; }
 0810           ; 
 0810           ; // ---------------------------------------------------------------------------
 0810           ; // CYFISNP_RxDataGet()
 0810           ; // ---------------------------------------------------------------------------
 0810           ;     CYFISNP_API_PKT *               // Return pointer to Rx API structure
 0810           ; CYFISNP_RxDataGet(void)
 0810           ; {
 0810                   .dbline 1178
 0810           ;     return((CYFISNP_API_PKT *) &SNP_rxBuf.api);
 0810 550026            mov [__r1],<_SNP_rxBuf
 0813 550026            mov [__r0],>_SNP_rxBuf
 0816                   .dbline -2
 0816           L213:
 0816                   .dbline 0 ; func end
 0816 7F                ret
 0817                   .dbend
 0817                   .dbfunc e CYFISNP_RxDataRelease _CYFISNP_RxDataRelease fV
 0817           _CYFISNP_RxDataRelease::
 0817                   .dbline -1
 0817                   .dbline 1185
 0817           ; }
 0817           ; 
 0817           ; // ---------------------------------------------------------------------------
 0817           ; // CYFISNP_RxDataRelease()
 0817           ; // ---------------------------------------------------------------------------
 0817           ; void CYFISNP_RxDataRelease(void)
 0817           ; {
 0817                   .dbline 1186
 0817           ;     rxBufPend = FALSE;
 0817 551C00            mov [_rxBufPend],0
 081A                   .dbline -2
 081A           L214:
 081A                   .dbline 0 ; func end
 081A 7F                ret
 081B                   .dbend
 081B                   .dbfunc s gotoPingMode _gotoPingMode fV
 081B           _gotoPingMode:
 081B                   .dbline -1
 081B                   .dbline 1198
 081B           ; }
 081B           ; 
 081B           ; 
 081B           ; // ---------------------------------------------------------------------------
 081B           ; //
 081B           ; // gotoPingMode()
 081B           ; //
 081B           ; // runPingMode() -
 081B           ; //
 081B           ; // ---------------------------------------------------------------------------
 081B           ; static void gotoPingMode(void)
 081B           ; {
 081B                   .dbline 1199
 081B           ;     CYFISNP_OutStr("\n\rStart Ping Mode. ");
 081B                   .dbline 1200
 081B           ;     setMaxPaLevel();
 081B 9438              xcall _setMaxPaLevel
 081D                   .dbline 1201
 081D           ;     CYFISNP_eProtState = CYFISNP_PING_MODE;
 081D 553B30            mov [_CYFISNP_eProtState],48
 0820                   .dbline 1202
 0820           ;     wModeCounter   = PING_MODE_COUNT_MAX;
 0820 5510C8            mov [_wModeCounter+1],-56
 0823 550F00            mov [_wModeCounter],0
 0826                   .dbline 1203
 0826           ;     CYFISNP_TimeSet(&wModeDelay, PING_MODE_FAST_TIME);
 0826 5000              mov A,0
 0828 08                push A
 0829 08                push A
 082A 500D              mov A,>_wModeDelay
 082C 08                push A
 082D 500D              mov A,<_wModeDelay
 082F 08                push A
 0830 7C0000            xcall _CYFISNP_TimeSet
 0833 38FC              add SP,-4
 0835                   .dbline 1208
 0835           ; 
 0835           ;     // ------------------
 0835           ;     // Create PING packet
 0835           ;     // ------------------
 0835           ;     SNP_txBuf[0] = PKT_PING_TYPE;
 0835 553300            mov [_SNP_txBuf],0
 0838                   .dbline 1209
 0838           ;     SNP_txBuf[1] = CYFISNP_EEP_NET_REC_ADR->devId;
 0838 503F              mov A,63
 083A 10                push X
 083B 57C5              mov X,-59
 083D 28                romx
 083E 20                pop X
 083F 5334              mov [_SNP_txBuf+1],A
 0841                   .dbline -2
 0841           L215:
 0841                   .dbline 0 ; func end
 0841 7F                ret
 0842                   .dbend
 0842                   .dbfunc s runPingMode _runPingMode fV
 0842           _runPingMode:
 0842                   .dbline -1
 0842                   .dbline 1213
 0842           ; }
 0842           ; 
 0842           ; static void runPingMode(void)
 0842           ; {
 0842                   .dbline 1215
 0842           ; 
 0842           ;     if (CYFISNP_TimeExpired(&wModeDelay) == FALSE) {
 0842 500D              mov A,>_wModeDelay
 0844 08                push A
 0845 500D              mov A,<_wModeDelay
 0847 08                push A
 0848 7C0000            xcall _CYFISNP_TimeExpired
 084B 38FE              add SP,-2
 084D 3900              cmp A,0
 084F                   .dbline 1216
 084F           ;         return;
 084F                   .dbline 1216
 084F A08F              jz L217
 0851           L218:
 0851                   .dbline 1218
 0851           ;     }
 0851           ;     if (wModeCounter > PING_MODE_COUNT_MAX/2 ) {
 0851 5064              mov A,100
 0853 1210              sub A,[_wModeCounter+1]
 0855 5000              mov A,0
 0857 1A0F              sbb A,[_wModeCounter]
 0859 D012              jnc L220
 085B           X14:
 085B                   .dbline 1219
 085B           ;         CYFISNP_TimeSet(&wModeDelay, PING_MODE_FAST_TIME);
 085B                   .dbline 1219
 085B 5000              mov A,0
 085D 08                push A
 085E 08                push A
 085F 500D              mov A,>_wModeDelay
 0861 08                push A
 0862 500D              mov A,<_wModeDelay
 0864 08                push A
 0865 7C0000            xcall _CYFISNP_TimeSet
 0868 38FC              add SP,-4
 086A                   .dbline 1220
 086A           ;     } else {
 086A 8012              xjmp L221
 086C           L220:
 086C                   .dbline 1220
 086C                   .dbline 1221
 086C           ;         CYFISNP_TimeSet(&wModeDelay, PING_MODE_SLOW_TIME);
 086C 5000              mov A,0
 086E 08                push A
 086F 500C              mov A,12
 0871 08                push A
 0872 500D              mov A,>_wModeDelay
 0874 08                push A
 0875 500D              mov A,<_wModeDelay
 0877 08                push A
 0878 7C0000            xcall _CYFISNP_TimeSet
 087B 38FC              add SP,-4
 087D                   .dbline 1222
 087D           ;     }
 087D           L221:
 087D                   .dbline 1224
 087D           ; 
 087D           ;     if (wModeCounter-- == 0) {
 087D 5F0010            mov [__r1],[_wModeCounter+1]
 0880 5F000F            mov [__r0],[_wModeCounter]
 0883 5100              mov A,[__r1]
 0885 1101              sub A,1
 0887 5310              mov [_wModeCounter+1],A
 0889 5100              mov A,[__r0]
 088B 1900              sbb A,0
 088D 530F              mov [_wModeCounter],A
 088F 3C0000            cmp [__r0],0
 0892 B00D              jnz L222
 0894 3C0000            cmp [__r1],0
 0897 B008              jnz L222
 0899           X15:
 0899                   .dbline 1230
 0899           ;         // -------------------------------------------------------------------
 0899           ;         // Since can't find Hub, it's possible that it's been replaced and the
 0899           ;         //  Node should send a packet with BCDR to revalidate the Node's ID,
 0899           ;         //  so timeout in Connect Mode to revalidate at eventual Jog()
 0899           ;         // -------------------------------------------------------------------
 0899           ;         CYFISNP_eProtState = CYFISNP_CON_MODE_TIMEOUT;
 0899                   .dbline 1230
 0899 553B21            mov [_CYFISNP_eProtState],33
 089C                   .dbline 1231
 089C           ;         CYFISNP_OutStr("\n\rPing Timeout, goto Connect Timeout. ");
 089C                   .dbline 1232
 089C           ;         CYFISNP_spiSleep();
 089C 9410              xcall _CYFISNP_spiSleep
 089E                   .dbline 1233
 089E           ;         return;
 089E 8040              xjmp L217
 08A0           L222:
 08A0                   .dbline 1239
 08A0           ;     }
 08A0           ; 
 08A0           ;     // -------------------------------------------------------------------
 08A0           ;     // Send another Ping Request on next channel
 08A0           ;     // -------------------------------------------------------------------
 08A0           ;     nextNetCh();
 08A0 903E              xcall _nextNetCh
 08A2                   .dbline 1240
 08A2           ;     CYFISNP_SetChannel   (CYFISNP_bCurrentChannel);
 08A2 10                push X
 08A3 513A              mov A,[_CYFISNP_bCurrentChannel]
 08A5 7C0000            xcall _CYFISNP_SetChannel
 08A8 20                pop X
 08A9                   .dbline 1241
 08A9           ;     setHubSeed();
 08A9 7C0018            xcall _setHubSeed
 08AC                   .dbline 1242
 08AC           ;     CYFISNP_SetXactConfig(XACT_STATE_IDLE);     // Expect NO BCD
 08AC 10                push X
 08AD 5085              mov A,-123
 08AF 7C0000            xcall _CYFISNP_SetXactConfig
 08B2                   .dbline 1243
 08B2           ;     CYFISNP_SetPtr       (&SNP_txBuf[0]);
 08B2 5033              mov A,>_SNP_txBuf
 08B4 5733              mov X,<_SNP_txBuf
 08B6 7C0000            xcall _CYFISNP_SetPtr
 08B9                   .dbline 1244
 08B9           ;     CYFISNP_StartTransmit(0, PKT_PING_LEN);
 08B9 5702              mov X,2
 08BB 5000              mov A,0
 08BD 7C0000            xcall _CYFISNP_StartTransmit
 08C0 20                pop X
 08C1 8006              xjmp L225
 08C3           L224:
 08C3                   .dbline 1245
 08C3           ;     while ((CYFISNP_State & CYFISNP_COMPLETE) == 0) {
 08C3                   .dbline 1246
 08C3           ;         CYFISNP_GetTransmitState();
 08C3 10                push X
 08C4 7C0000            xcall _CYFISNP_GetTransmitState
 08C7 20                pop X
 08C8                   .dbline 1247
 08C8           ;     }
 08C8           L225:
 08C8                   .dbline 1245
 08C8 470002            tst [_CYFISNP_State],2
 08CB AFF7              jz L224
 08CD                   .dbline 1248
 08CD           ;     radioStateCopy = CYFISNP_State;
 08CD 5F1B00            mov [_radioStateCopy],[_CYFISNP_State]
 08D0                   .dbline 1249
 08D0           ;     CYFISNP_EndTransmit();
 08D0 10                push X
 08D1 7C0000            xcall _CYFISNP_EndTransmit
 08D4 20                pop X
 08D5                   .dbline 1254
 08D5           ; 
 08D5           ;     // -------------------------------------------------------------------
 08D5           ;     // If AutoAck PASSED, then resume Data Mode
 08D5           ;     // -------------------------------------------------------------------
 08D5           ;     if ((radioStateCopy & CYFISNP_ERROR) == 0) {
 08D5 471B01            tst [_radioStateCopy],1
 08D8 B006              jnz L227
 08DA                   .dbline 1255
 08DA           ;         setHubSeed();
 08DA                   .dbline 1255
 08DA 7C0018            xcall _setHubSeed
 08DD                   .dbline 1256
 08DD           ;         gotoDataMode();
 08DD 9C58              xcall _gotoDataMode
 08DF                   .dbline 1257
 08DF           ;     }
 08DF           L227:
 08DF                   .dbline -2
 08DF           L217:
 08DF                   .dbline 0 ; func end
 08DF 7F                ret
 08E0                   .dbend
 08E0                   .dbfunc s nextNetCh _nextNetCh fV
 08E0           ;            hop -> X+0
 08E0           _nextNetCh:
 08E0                   .dbline -1
 08E0 10                push X
 08E1 4F                mov X,SP
 08E2 10                push X
 08E3                   .dbline 1265
 08E3           ; }
 08E3           ; 
 08E3           ; 
 08E3           ; // ---------------------------------------------------------------------------
 08E3           ; // nextNetCh() - Advance to next Data Channel (everything but Bind Mode)
 08E3           ; // ---------------------------------------------------------------------------
 08E3           ; static void nextNetCh(void)
 08E3           ; {
 08E3                   .dbline 1267
 08E3           ;     BYTE hop;
 08E3           ;     hop = CYFISNP_EEP_NET_REC_ADR->chHop + 1;
 08E3 503F              mov A,63
 08E5 10                push X
 08E6 57C2              mov X,-62
 08E8 28                romx
 08E9 20                pop X
 08EA 0101              add A,1
 08EC 5400              mov [X+0],A
 08EE                   .dbline 1268
 08EE           ;     hop = (hop * 2) + (hop * 4);        // hop * 6 (help "lite" compiler)
 08EE 5200              mov A,[X+0]
 08F0 64                asl A
 08F1 64                asl A
 08F2 5300              mov [__r0],A
 08F4 5200              mov A,[X+0]
 08F6 64                asl A
 08F7 5300              mov [__r2],A
 08F9 5100              mov A,[__r0]
 08FB 0200              add A,[__r2]
 08FD 5400              mov [X+0],A
 08FF                   .dbline 1270
 08FF           ; 
 08FF           ;     CYFISNP_bCurrentChannel += hop;
 08FF 5200              mov A,[X+0]
 0901 043A              add [_CYFISNP_bCurrentChannel],A
 0903                   .dbline 1272
 0903           ; 
 0903           ;     if (CYFISNP_bCurrentChannel  > CYFISNP_CHAN_MAX) {
 0903 503A              mov A,58
 0905 3A3A              cmp A,[_CYFISNP_bCurrentChannel]
 0907 D00A              jnc L233
 0909           X16:
 0909                   .dbline 1273
 0909           ;         CYFISNP_bCurrentChannel -= CYFISNP_MAX_CHANNELS;
 0909                   .dbline 1273
 0909 163A4E            sub [_CYFISNP_bCurrentChannel],78
 090C                   .dbline 1274
 090C           ;     }
 090C 8005              xjmp L233
 090E           L232:
 090E                   .dbline 1275
 090E           ;     while ((signed char)CYFISNP_bCurrentChannel < CYFISNP_CHAN_MIN) {
 090E                   .dbline 1276
 090E           ;         CYFISNP_bCurrentChannel += hop;
 090E 5200              mov A,[X+0]
 0910 043A              add [_CYFISNP_bCurrentChannel],A
 0912                   .dbline 1277
 0912           ;     }
 0912           L233:
 0912                   .dbline 1275
 0912 500A              mov A,10
 0914 3A3A              cmp A,[_CYFISNP_bCurrentChannel]
 0916 A009              jz X17
 0918 6D                rrc A
 0919 323A              xor A,[_CYFISNP_bCurrentChannel]
 091B 310A              xor A,10
 091D 6A                rlc A
 091E DFEF              jnc L232
 0920           X17:
 0920                   .dbline -2
 0920           L229:
 0920 20                pop X
 0921 20                pop X
 0922                   .dbline 0 ; func end
 0922 7F                ret
 0923                   .dbsym l hop 0 c
 0923                   .dbend
 0923                   .dbfunc s rxMidEquNodeMid _rxMidEquNodeMid fc
 0923           ;        nodeMid -> X+3
 0923           ;       pNodeMid -> X+1
 0923           ;           ivar -> X+0
 0923           ;         pRxMid -> X-5
 0923           _rxMidEquNodeMid:
 0923                   .dbline -1
 0923 10                push X
 0924 4F                mov X,SP
 0925 380B              add SP,11
 0927                   .dbline 1285
 0927           ; }
 0927           ; 
 0927           ; 
 0927           ; // ---------------------------------------------------------------------------
 0927           ; // rxMidEquNodeMid() - Compare the Rx MID with this Node's MID (from the radio)
 0927           ; // ---------------------------------------------------------------------------
 0927           ; static BOOL rxMidEquNodeMid(BYTE *pRxMid)
 0927           ; {
 0927                   .dbline 1290
 0927           ;     BYTE *pNodeMid;
 0927           ;     char ivar;
 0927           ;     BYTE nodeMid[6];        // CYFISNP_GetFuses( void ) needs 6 Byte MID buffer
 0927           ; 
 0927           ;     CYFISNP_SetPtr(&nodeMid[0]);
 0927 5A00              mov [__r1],X
 0929 060003            add [__r1],3
 092C 10                push X
 092D 5100              mov A,[__r0]
 092F 5800              mov X,[__r1]
 0931 7C0000            xcall _CYFISNP_SetPtr
 0934                   .dbline 1291
 0934           ;     CYFISNP_SetLength(CYFISNP_SIZEOF_MID);
 0934 5004              mov A,4
 0936 7C0000            xcall _CYFISNP_SetLength
 0939                   .dbline 1292
 0939           ;     CYFISNP_GetFuses();
 0939 7C0000            xcall _CYFISNP_GetFuses
 093C 20                pop X
 093D                   .dbline 1294
 093D           ; 
 093D           ;     pNodeMid = &nodeMid[0];
 093D 5A00              mov [__r0],X
 093F 060003            add [__r0],3
 0942 5100              mov A,[__r0]
 0944 5402              mov [X+2],A
 0946                   .dbline 1295
 0946           ;     for (ivar = CYFISNP_SIZEOF_MID; *pNodeMid == *pRxMid && ivar != 0; --ivar) {
 0946 560004            mov [X+0],4
 0949 800D              xjmp L239
 094B           L236:
 094B                   .dbline 1295
 094B                   .dbline 1296
 094B           ;         ++pNodeMid;
 094B 7702              inc [X+2]
 094D 0F0100            adc [X+1],0
 0950                   .dbline 1297
 0950           ;         ++pRxMid;
 0950 77FC              inc [X-4]
 0952 0FFB00            adc [X-5],0
 0955                   .dbline 1298
 0955           ;     }
 0955           L237:
 0955                   .dbline 1295
 0955 7B00              dec [X+0]
 0957           L239:
 0957                   .dbline 1295
 0957 52FC              mov A,[X-4]
 0959 5300              mov [__r1],A
 095B 3E00              mvi A,[__r1]
 095D 5300              mov [__r0],A
 095F 5202              mov A,[X+2]
 0961 5300              mov [__r3],A
 0963 3E00              mvi A,[__r3]
 0965 3A00              cmp A,[__r0]
 0967 B006              jnz L240
 0969 3D0000            cmp [X+0],0
 096C BFDE              jnz L236
 096E           L240:
 096E                   .dbline 1299
 096E           ;     return(ivar == 0);
 096E 3D0000            cmp [X+0],0
 0971 B009              jnz L242
 0973 560A01            mov [X+10],1
 0976 560900            mov [X+9],0
 0979 8007              xjmp L243
 097B           L242:
 097B 560A00            mov [X+10],0
 097E 560900            mov [X+9],0
 0981           L243:
 0981 520A              mov A,[X+10]
 0983                   .dbline -2
 0983           L235:
 0983 38F5              add SP,-11
 0985 20                pop X
 0986                   .dbline 0 ; func end
 0986 7F                ret
 0987                   .dbsym l nodeMid 3 A[6:6]c
 0987                   .dbsym l pNodeMid 1 pc
 0987                   .dbsym l ivar 0 c
 0987                   .dbsym l pRxMid -5 pc
 0987                   .dbend
 0987                   .dbfunc s copyMidToTxPkt _copyMidToTxPkt fV
 0987           _copyMidToTxPkt:
 0987                   .dbline -1
 0987                   .dbline 1306
 0987           ; }
 0987           ; 
 0987           ; // ---------------------------------------------------------------------------
 0987           ; // copyMidToTxPkt() - Copy Node MID to Bind or Connect Req Tx pkt area
 0987           ; // ---------------------------------------------------------------------------
 0987           ; static void copyMidToTxPkt(void)
 0987           ; {
 0987                   .dbline 1307
 0987           ;     CYFISNP_SetPtr   (&SNP_txBuf[2]);
 0987 10                push X
 0988 5035              mov A,>_SNP_txBuf+2
 098A 5735              mov X,<_SNP_txBuf+2
 098C 7C0000            xcall _CYFISNP_SetPtr
 098F                   .dbline 1308
 098F           ;     CYFISNP_SetLength(CYFISNP_SIZEOF_MID);
 098F 5004              mov A,4
 0991 7C0000            xcall _CYFISNP_SetLength
 0994                   .dbline 1309
 0994           ;     CYFISNP_GetFuses ();
 0994 7C0000            xcall _CYFISNP_GetFuses
 0997 20                pop X
 0998                   .dbline -2
 0998           L244:
 0998                   .dbline 0 ; func end
 0998 7F                ret
 0999                   .dbend
 0999                   .dbfunc s putNetParams _putNetParams fV
 0999                   .dbstruct 0 8 .5
 0999                   .dbfield 0 sopIdx c
 0999                   .dbfield 1 chBase c
 0999                   .dbfield 2 chHop c
 0999                   .dbfield 3 hubSeedMsb c
 0999                   .dbfield 4 hubSeedLsb c
 0999                   .dbfield 5 devId c
 0999                   .dbfield 6 nodeSeedMsb c
 0999                   .dbfield 7 nodeSeedLsb c
 0999                   .dbend
 0999           ;            net -> X+0
 0999           ;         pRxPkt -> X-5
 0999           _putNetParams:
 0999                   .dbline -1
 0999 10                push X
 099A 4F                mov X,SP
 099B 3808              add SP,8
 099D                   .dbline 1318
 099D           ; }
 099D           ; 
 099D           ; // ---------------------------------------------------------------------------
 099D           ; //
 099D           ; // putNetParams() - Extract Network Params from BindRsp and put in FLASH
 099D           ; //
 099D           ; // ---------------------------------------------------------------------------
 099D           ; static void putNetParams(BYTE * pRxPkt)
 099D           ; {
 099D                   .dbline 1324
 099D           ;     CYFISNP_EEP_NET_REC net;
 099D           ; 
 099D           ;     // -------------------------------------------------------------------
 099D           ;     // Compose RAM image to write to FLASH
 099D           ;     // -------------------------------------------------------------------
 099D           ;     net.devId       = pRxPkt[1];
 099D 52FC              mov A,[X-4]
 099F 0101              add A,1
 09A1 5300              mov [__r1],A
 09A3 3E00              mvi A,[__r1]
 09A5 5405              mov [X+5],A
 09A7                   .dbline 1325
 09A7           ;     net.hubSeedMsb  = pRxPkt[6];
 09A7 52FC              mov A,[X-4]
 09A9 0106              add A,6
 09AB 5300              mov [__r1],A
 09AD 3E00              mvi A,[__r1]
 09AF 5403              mov [X+3],A
 09B1                   .dbline 1326
 09B1           ;     net.hubSeedLsb  = pRxPkt[7];
 09B1 52FC              mov A,[X-4]
 09B3 0107              add A,7
 09B5 5300              mov [__r1],A
 09B7 3E00              mvi A,[__r1]
 09B9 5404              mov [X+4],A
 09BB                   .dbline 1327
 09BB           ;     net.sopIdx      = pRxPkt[9] >> 3;
 09BB 52FC              mov A,[X-4]
 09BD 0109              add A,9
 09BF 5300              mov [__r1],A
 09C1 3E00              mvi A,[__r1]
 09C3 67                asr A
 09C4 67                asr A
 09C5 67                asr A
 09C6 211F              and A,31
 09C8 5400              mov [X+0],A
 09CA                   .dbline 1328
 09CA           ;     net.chHop       = pRxPkt[9] & 7;            // Flash is {0-7}
 09CA 52FC              mov A,[X-4]
 09CC 0109              add A,9
 09CE 5300              mov [__r1],A
 09D0 3E00              mvi A,[__r1]
 09D2 2107              and A,7
 09D4 5402              mov [X+2],A
 09D6                   .dbline 1329
 09D6           ;     net.chBase      = pRxPkt[8];
 09D6 52FC              mov A,[X-4]
 09D8 0108              add A,8
 09DA 5300              mov [__r1],A
 09DC 3E00              mvi A,[__r1]
 09DE 5401              mov [X+1],A
 09E0                   .dbline 1330
 09E0           ;     net.nodeSeedMsb = pRxPkt[6];
 09E0 52FC              mov A,[X-4]
 09E2 0106              add A,6
 09E4 5300              mov [__r1],A
 09E6 3E00              mvi A,[__r1]
 09E8 5406              mov [X+6],A
 09EA                   .dbline 1331
 09EA           ;     net.nodeSeedLsb = pRxPkt[7] ^ pRxPkt[1];    // LSB Hub Seed ^ devId
 09EA 52FC              mov A,[X-4]
 09EC 0101              add A,1
 09EE 5300              mov [__r1],A
 09F0 3E00              mvi A,[__r1]
 09F2 5300              mov [__r0],A
 09F4 52FC              mov A,[X-4]
 09F6 0107              add A,7
 09F8 5300              mov [__r3],A
 09FA 3E00              mvi A,[__r3]
 09FC 5300              mov [__r2],A
 09FE 5100              mov A,[__r0]
 0A00 3200              xor A,[__r2]
 0A02 5407              mov [X+7],A
 0A04                   .dbline 1333
 0A04           ; 
 0A04           ;     CYFISNP_OutStr("--Got netParams ");
 0A04                   .dbline 1334
 0A04           ;     flashWrite((char *)&net);
 0A04 08                push A
 0A05 10                push X
 0A06 9034              xcall _flashWrite
 0A08 38FE              add SP,-2
 0A0A                   .dbline -2
 0A0A           L246:
 0A0A 38F8              add SP,-8
 0A0C 20                pop X
 0A0D                   .dbline 0 ; func end
 0A0D 7F                ret
 0A0E                   .dbsym l net 0 S[.5]
 0A0E                   .dbsym l pRxPkt -5 pc
 0A0E                   .dbend
 0A0E                   .dbfunc e CYFISNP_Unbind _CYFISNP_Unbind fV
 0A0E           ;            net -> X+0
 0A0E           _CYFISNP_Unbind::
 0A0E                   .dbline -1
 0A0E 10                push X
 0A0F 4F                mov X,SP
 0A10 3808              add SP,8
 0A12                   .dbline 1344
 0A12           ; }
 0A12           ; 
 0A12           ; 
 0A12           ; // ---------------------------------------------------------------------------
 0A12           ; //
 0A12           ; // CYFISNP_Unbind()
 0A12           ; //
 0A12           ; // ---------------------------------------------------------------------------
 0A12           ; void CYFISNP_Unbind(void)
 0A12           ; {
 0A12                   .dbline 1347
 0A12           ;     CYFISNP_EEP_NET_REC net;
 0A12           ; 
 0A12           ;     net.devId       = 0;            // ------------------------------------
 0A12 560500            mov [X+5],0
 0A15                   .dbline 1348
 0A15           ;     net.hubSeedMsb  = 0;            // Compose RAM image to write to FLASH
 0A15 560300            mov [X+3],0
 0A18                   .dbline 1349
 0A18           ;     net.hubSeedLsb  = 0;            // ------------------------------------
 0A18 560400            mov [X+4],0
 0A1B                   .dbline 1350
 0A1B           ;     net.sopIdx      = 0;
 0A1B 560000            mov [X+0],0
 0A1E                   .dbline 1351
 0A1E           ;     net.chHop       = 0;
 0A1E 560200            mov [X+2],0
 0A21                   .dbline 1352
 0A21           ;     net.chBase      = 0;
 0A21 560100            mov [X+1],0
 0A24                   .dbline 1353
 0A24           ;     net.nodeSeedMsb = 0;
 0A24 560600            mov [X+6],0
 0A27                   .dbline 1354
 0A27           ;     net.nodeSeedLsb = 0;
 0A27 560700            mov [X+7],0
 0A2A                   .dbline 1356
 0A2A           ; 
 0A2A           ;     CYFISNP_OutStr("--Unbinding...");
 0A2A                   .dbline 1357
 0A2A           ;     flashWrite((char *)&net);
 0A2A 5100              mov A,[__r0]
 0A2C 08                push A
 0A2D 10                push X
 0A2E 900C              xcall _flashWrite
 0A30 38FE              add SP,-2
 0A32                   .dbline 1358
 0A32           ;     CYFISNP_OutStr("Done. ");
 0A32                   .dbline 1359
 0A32           ;     gotoUnboundMode();
 0A32 7C0108            xcall _gotoUnboundMode
 0A35                   .dbline -2
 0A35           L254:
 0A35 38F8              add SP,-8
 0A37 20                pop X
 0A38                   .dbline 0 ; func end
 0A38 7F                ret
 0A39                   .dbsym l net 0 S[.5]
 0A39                   .dbend
 0A39                   .dbfunc e CYFISNP_GetDieTemp _CYFISNP_GetDieTemp fc
 0A39           _CYFISNP_GetDieTemp::
 0A39                   .dbline -1
 0A39                   .dbline 1371
 0A39           ; }
 0A39           ; 
 0A39           ; 
 0A39           ; // ---------------------------------------------------------------------------
 0A39           ; //
 0A39           ; // flashWrite() - Write RAM image to FLASH by possibly device-specific method
 0A39           ; //
 0A39           ; // ---------------------------------------------------------------------------
 0A39           ; 
 0A39           ; // Dummy function (for now)
 0A39           ; BYTE CYFISNP_GetDieTemp(void)
 0A39           ; {
 0A39                   .dbline 1373
 0A39           ; // @PSoC_UserCode_DieTemp@ (Do not change this line.)
 0A39           ;     return 20;
 0A39 5014              mov A,20
 0A3B                   .dbline -2
 0A3B           L262:
 0A3B                   .dbline 0 ; func end
 0A3B 7F                ret
 0A3C                   .dbend
 0A3C                   .dbfunc s flashWrite _flashWrite fV
 0A3C                   .dbstruct 0 7 .1
 0A3C                   .dbfield 0 bARG_BlockId c
 0A3C                   .dbfield 1 pARG_FlashBuffer pc
 0A3C                   .dbfield 3 cARG_Temperature C
 0A3C                   .dbfield 4 bDATA_PWErase c
 0A3C                   .dbfield 5 bDATA_PWProgram c
 0A3C                   .dbfield 6 bDATA_PWMultiplier c
 0A3C                   .dbend
 0A3C           ;       fwStruct -> X+0
 0A3C           ;           pRam -> X+3
 0A3C           ;         pFlash -> X+1
 0A3C           ;           ivar -> X+0
 0A3C           ;           pSrc -> X-5
 0A3C           _flashWrite:
 0A3C                   .dbline -1
 0A3C 10                push X
 0A3D 4F                mov X,SP
 0A3E 3807              add SP,7
 0A40                   .dbline 1383
 0A40           ; // @PSoC_UserCode_END@ (Do not change this line.)
 0A40           ; }
 0A40           ; 
 0A40           ; 
 0A40           ; #if HI_TECH_C
 0A40           ; #pragma warning push
 0A40           ; #pragma warning disable 350
 0A40           ; #endif
 0A40           ; static void flashWrite (BYTE *pSrc)
 0A40           ; {
 0A40                   .dbline 1387
 0A40           ;     // -----------------------------------------------------------------------
 0A40           ;     // If this RAM image already exists in FLASH, then no need to write it
 0A40           ;     // -----------------------------------------------------------------------
 0A40           ;     {
 0A40                   .dbline 1391
 0A40           ;         char ivar;
 0A40           ;         const BYTE *pFlash;
 0A40           ;         BYTE       *pRam;
 0A40           ;         pRam   = pSrc;
 0A40 52FC              mov A,[X-4]
 0A42 5404              mov [X+4],A
 0A44                   .dbline 1392
 0A44           ;         pFlash = (const BYTE *)CYFISNP_EEP_PHY_ADR;
 0A44 5602C0            mov [X+2],-64
 0A47 56013F            mov [X+1],63
 0A4A                   .dbline 1393
 0A4A           ;         ivar = sizeof(CYFISNP_EEP_NET_REC);
 0A4A 560008            mov [X+0],8
 0A4D                   .dbline 1394
 0A4D           ;         for (; ivar != 0 && *pRam++ == *pFlash++; --ivar);
 0A4D 8003              xjmp L267
 0A4F           L264:
 0A4F                   .dbline 1394
 0A4F           L265:
 0A4F                   .dbline 1394
 0A4F 7B00              dec [X+0]
 0A51           L267:
 0A51                   .dbline 1394
 0A51 3D0000            cmp [X+0],0
 0A54 A038              jz L268
 0A56 5204              mov A,[X+4]
 0A58 5300              mov [__r1],A
 0A5A 5203              mov A,[X+3]
 0A5C 5300              mov [__r0],A
 0A5E 5100              mov A,[__r1]
 0A60 0101              add A,1
 0A62 5404              mov [X+4],A
 0A64 5100              mov A,[__r0]
 0A66 0900              adc A,0
 0A68 5403              mov [X+3],A
 0A6A 5202              mov A,[X+2]
 0A6C 5300              mov [__r3],A
 0A6E 5201              mov A,[X+1]
 0A70 5300              mov [__r2],A
 0A72 5100              mov A,[__r3]
 0A74 0101              add A,1
 0A76 5402              mov [X+2],A
 0A78 5100              mov A,[__r2]
 0A7A 0900              adc A,0
 0A7C 5401              mov [X+1],A
 0A7E 5100              mov A,[__r2]
 0A80 10                push X
 0A81 5800              mov X,[__r3]
 0A83 28                romx
 0A84 20                pop X
 0A85 5300              mov [__r2],A
 0A87 3E00              mvi A,[__r1]
 0A89 3A00              cmp A,[__r2]
 0A8B AFC3              jz L264
 0A8D           L268:
 0A8D                   .dbline 1395
 0A8D           ;         if (ivar == 0) {
 0A8D 3D0000            cmp [X+0],0
 0A90                   .dbline 1396
 0A90           ;             return;
 0A90                   .dbline 1396
 0A90 A017              jz L263
 0A92           L269:
 0A92                   .dbline 1398
 0A92           ;         }
 0A92           ;     }
 0A92                   .dbline 1403
 0A92           ; 
 0A92           ;     // -----------------------------------------------------------------------
 0A92           ;     // Write the RAM image to FLASH
 0A92           ;     // -----------------------------------------------------------------------
 0A92           ;     CYFISNP_OutStr("--Writing to Flash...");
 0A92                   .dbline 1404
 0A92           ;     {
 0A92                   .dbline 1420
 0A92           ; //      struct {
 0A92           ; //          BYTE   bARG_BlockId;           // block ID
 0A92           ; //          BYTE  *pARG_FlashBuffer;       // flash buffer pointer - 2 bytes
 0A92           ; //          CHAR   cARG_Temperature;       // die Temperature, -40 to 100
 0A92           ; //          BYTE   bDATA_PWErase;          // Temporary storage (reserved)
 0A92           ; //          BYTE   bDATA_PWProgram;        // Temporary storage (reserved)
 0A92           ; //          BYTE   bDATA_PWMultiplier;     // Temporary storage (reserved)
 0A92           ; //      } fwStruct;
 0A92           ;         FLASH_WRITE_STRUCT fwStruct;
 0A92           ; 
 0A92           ;     #define CYFISNP_EEP_BLK_NUM ( CYFISNP_EEP_PHY_ADR / 0x40 )  // 64-Bytes/Flash Page
 0A92           ; 
 0A92           ;     #if (CYFISNP_FLASH_BLOCK_NUMBER_IS_WORD)
 0A92           ;         fwStruct.wARG_BlockId     = CYFISNP_EEP_BLK_NUM;
 0A92           ;     #else
 0A92           ;         fwStruct.bARG_BlockId     = CYFISNP_EEP_BLK_NUM;
 0A92 5600FF            mov [X+0],-1
 0A95                   .dbline 1423
 0A95           ;     #endif
 0A95           ; 
 0A95           ;         fwStruct.pARG_FlashBuffer = pSrc;
 0A95 52FC              mov A,[X-4]
 0A97 5402              mov [X+2],A
 0A99                   .dbline 1424
 0A99           ;         fwStruct.cARG_Temperature = CYFISNP_GetDieTemp();
 0A99 9F9E              xcall _CYFISNP_GetDieTemp
 0A9B 5403              mov [X+3],A
 0A9D                   .dbline 1425
 0A9D           ;         if (bFlashWriteBlock((FLASH_WRITE_STRUCT*)&fwStruct) == 0) {
 0A9D 10                push X
 0A9E 7C0000            xcall _bFlashWriteBlock
 0AA1 20                pop X
 0AA2 3900              cmp A,0
 0AA4 B003              jnz L273
 0AA6                   .dbline 1426
 0AA6           ;             while (1);      // Flash write failed, halt here
 0AA6           L275:
 0AA6                   .dbline 1426
 0AA6           L276:
 0AA6                   .dbline 1426
 0AA6 8FFF              xjmp L275
 0AA8           L273:
 0AA8                   .dbline 1428
 0AA8           ;         }
 0AA8           ;     }
 0AA8                   .dbline 1429
 0AA8           ;     CYFISNP_OutStr("Done. ");
 0AA8                   .dbline -2
 0AA8           L263:
 0AA8 38F9              add SP,-7
 0AAA 20                pop X
 0AAB                   .dbline 0 ; func end
 0AAB 7F                ret
 0AAC                   .dbsym l fwStruct 0 S[.1]
 0AAC                   .dbsym l pRam 3 pc
 0AAC                   .dbsym l pFlash 1 pkc
 0AAC                   .dbsym l ivar 0 c
 0AAC                   .dbsym l pSrc -5 pc
 0AAC                   .dbend
 0AAC                   .dbfunc s dynPaUpdate _dynPaUpdate fV
 0AAC           ;      ackResult -> X-4
 0AAC           _dynPaUpdate:
 0AAC                   .dbline -1
 0AAC 10                push X
 0AAD 4F                mov X,SP
 0AAE                   .dbline 1444
 0AAE           ; }
 0AAE           ; #if HI_TECH_C
 0AAE           ; #pragma warning pop
 0AAE           ; #endif
 0AAE           ; 
 0AAE           ; 
 0AAE           ; 
 0AAE           ; 
 0AAE           ; // ---------------------------------------------------------------------------
 0AAE           ; //
 0AAE           ; // dynPaUpdate() - Based on AutoAck result, update GSK or 8DR statistic.
 0AAE           ; //
 0AAE           ; // ---------------------------------------------------------------------------
 0AAE           ; static void dynPaUpdate(BOOL ackResult)
 0AAE           ; {
 0AAE                   .dbline 1445
 0AAE           ;     if (GFSK_INUSE) {
 0AAE 472518            tst [_CYFISNP_radioTxConfig],24
 0AB1 B016              jnz L279
 0AB3                   .dbline 1446
 0AB3           ;         dpwrQualGfsk = dpwrQualGfsk + ackResult
 0AB3                   .dbline 1446
 0AB3 5123              mov A,[_dpwrQualGfsk]
 0AB5 0107              add A,7
 0AB7 67                asr A
 0AB8 67                asr A
 0AB9 67                asr A
 0ABA 211F              and A,31
 0ABC 5300              mov [__r0],A
 0ABE 5123              mov A,[_dpwrQualGfsk]
 0AC0 03FC              add A,[X-4]
 0AC2 1200              sub A,[__r0]
 0AC4 5323              mov [_dpwrQualGfsk],A
 0AC6                   .dbline 1448
 0AC6           ;                    - ((dpwrQualGfsk + QUAL_ROUNDOFF) >> QUAL_KSHIFT);
 0AC6           ;     }
 0AC6 8014              xjmp L280
 0AC8           L279:
 0AC8                   .dbline 1449
 0AC8           ;     else {
 0AC8                   .dbline 1450
 0AC8           ;         dpwrQual8dr = dpwrQual8dr  + ackResult
 0AC8 5122              mov A,[_dpwrQual8dr]
 0ACA 0107              add A,7
 0ACC 67                asr A
 0ACD 67                asr A
 0ACE 67                asr A
 0ACF 211F              and A,31
 0AD1 5300              mov [__r0],A
 0AD3 5122              mov A,[_dpwrQual8dr]
 0AD5 03FC              add A,[X-4]
 0AD7 1200              sub A,[__r0]
 0AD9 5322              mov [_dpwrQual8dr],A
 0ADB                   .dbline 1452
 0ADB           ;                   - ((dpwrQual8dr + QUAL_ROUNDOFF) >> QUAL_KSHIFT);
 0ADB           ;     }
 0ADB           L280:
 0ADB                   .dbline -2
 0ADB           L278:
 0ADB 20                pop X
 0ADC                   .dbline 0 ; func end
 0ADC 7F                ret
 0ADD                   .dbsym l ackResult -4 c
 0ADD                   .dbend
 0ADD                   .dbfunc s dynPaApply _dynPaApply fV
 0ADD           _dynPaApply:
 0ADD                   .dbline -1
 0ADD 10                push X
 0ADE 4F                mov X,SP
 0ADF 3802              add SP,2
 0AE1                   .dbline 1464
 0AE1           ; }
 0AE1           ; 
 0AE1           ; 
 0AE1           ; 
 0AE1           ; // ---------------------------------------------------------------------------
 0AE1           ; //
 0AE1           ; // dynPaApply() - Select desired power level and modulation for Tx packet
 0AE1           ; //
 0AE1           ; // ---------------------------------------------------------------------------
 0AE1           ; #define incSaturate(val)   (val = (val<QUAL_CONSEC_MAX) ? val+1 : val)
 0AE1           ; static void dynPaApply(void)
 0AE1           ; {
 0AE1                   .dbline 1468
 0AE1           ;     // -----------------------------------------------------------------------
 0AE1           ;     // Track how long each statistic has been at QUAL_MAX
 0AE1           ;     // -----------------------------------------------------------------------
 0AE1           ;     if (dpwrQualGfsk == QUAL_MAX) {
 0AE1 3C2339            cmp [_dpwrQualGfsk],57
 0AE4 B021              jnz L282
 0AE6                   .dbline 1469
 0AE6           ;         incSaturate(dpwrMaxConsecGfsk);     // ++counter to QUAL_CONSEC_MAX
 0AE6                   .dbline 1469
 0AE6 3C2108            cmp [_dpwrMaxConsecGfsk],8
 0AE9 D00F              jnc L285
 0AEB           X18:
 0AEB 5121              mov A,[_dpwrMaxConsecGfsk]
 0AED 0101              add A,1
 0AEF 5401              mov [X+1],A
 0AF1 5000              mov A,0
 0AF3 0900              adc A,0
 0AF5 5400              mov [X+0],A
 0AF7 8008              xjmp L286
 0AF9           L285:
 0AF9 5121              mov A,[_dpwrMaxConsecGfsk]
 0AFB 5401              mov [X+1],A
 0AFD 560000            mov [X+0],0
 0B00           L286:
 0B00 5201              mov A,[X+1]
 0B02 5321              mov [_dpwrMaxConsecGfsk],A
 0B04                   .dbline 1470
 0B04           ;     } else {
 0B04 8004              xjmp L283
 0B06           L282:
 0B06                   .dbline 1470
 0B06                   .dbline 1471
 0B06           ;         dpwrMaxConsecGfsk = 0;
 0B06 552100            mov [_dpwrMaxConsecGfsk],0
 0B09                   .dbline 1472
 0B09           ;     }
 0B09           L283:
 0B09                   .dbline 1473
 0B09           ;     if (dpwrQual8dr  == QUAL_MAX) {
 0B09 3C2239            cmp [_dpwrQual8dr],57
 0B0C B021              jnz L287
 0B0E                   .dbline 1474
 0B0E           ;         incSaturate(dpwrMaxConsec8dr);      // ++counter to QUAL_CONSEC_MAX
 0B0E                   .dbline 1474
 0B0E 3C2008            cmp [_dpwrMaxConsec8dr],8
 0B11 D00F              jnc L290
 0B13           X19:
 0B13 5120              mov A,[_dpwrMaxConsec8dr]
 0B15 0101              add A,1
 0B17 5401              mov [X+1],A
 0B19 5000              mov A,0
 0B1B 0900              adc A,0
 0B1D 5400              mov [X+0],A
 0B1F 8008              xjmp L291
 0B21           L290:
 0B21 5120              mov A,[_dpwrMaxConsec8dr]
 0B23 5401              mov [X+1],A
 0B25 560000            mov [X+0],0
 0B28           L291:
 0B28 5201              mov A,[X+1]
 0B2A 5320              mov [_dpwrMaxConsec8dr],A
 0B2C                   .dbline 1475
 0B2C           ;     } else {
 0B2C 8004              xjmp L288
 0B2E           L287:
 0B2E                   .dbline 1475
 0B2E                   .dbline 1476
 0B2E           ;         dpwrMaxConsec8dr = 0;
 0B2E 552000            mov [_dpwrMaxConsec8dr],0
 0B31                   .dbline 1477
 0B31           ;     }
 0B31           L288:
 0B31                   .dbline 1482
 0B31           ; 
 0B31           ;     // -----------------------------------------------------------------------
 0B31           ;     // If both statistics are QUAL_MAX for QUAL_CONSEC_MAX, then reduce PA
 0B31           ;     // -----------------------------------------------------------------------
 0B31           ;     if ((dpwrQualGfsk == QUAL_MAX && dpwrMaxConsecGfsk == QUAL_CONSEC_MAX)
 0B31 3C2339            cmp [_dpwrQualGfsk],57
 0B34 B01A              jnz L292
 0B36 3C2108            cmp [_dpwrMaxConsecGfsk],8
 0B39 B015              jnz L292
 0B3B 3C2239            cmp [_dpwrQual8dr],57
 0B3E B010              jnz L292
 0B40 3C2008            cmp [_dpwrMaxConsec8dr],8
 0B43 B00B              jnz L292
 0B45                   .dbline 1484
 0B45           ;      && (dpwrQual8dr  == QUAL_MAX && dpwrMaxConsec8dr  == QUAL_CONSEC_MAX)) {
 0B45           ;         decPaLevel();
 0B45                   .dbline 1484
 0B45 9137              xcall _decPaLevel
 0B47                   .dbline 1485
 0B47           ;         dpwrMaxConsecGfsk = dpwrMaxConsec8dr = 0;
 0B47 552000            mov [_dpwrMaxConsec8dr],0
 0B4A 552100            mov [_dpwrMaxConsecGfsk],0
 0B4D                   .dbline 1486
 0B4D           ;     }
 0B4D 804B              xjmp L293
 0B4F           L292:
 0B4F                   .dbline 1491
 0B4F           ; 
 0B4F           ;     // -----------------------------------------------------------------------
 0B4F           ;     // Else if both statistics "stink", then PA = MAX
 0B4F           ;     // -----------------------------------------------------------------------
 0B4F           ;     else if (dpwrQualGfsk < QUAL_THRESHOLD && dpwrQual8dr < QUAL_THRESHOLD) {
 0B4F 5042              mov A,66
 0B51 08                push A
 0B52 501F              mov A,31
 0B54 08                push A
 0B55 5099              mov A,-103
 0B57 08                push A
 0B58 509A              mov A,-102
 0B5A 08                push A
 0B5B 5000              mov A,0
 0B5D 08                push A
 0B5E 08                push A
 0B5F 08                push A
 0B60 5123              mov A,[_dpwrQualGfsk]
 0B62 08                push A
 0B63 7C0000            xcall __long2fp
 0B66 7C0000            xcall __fpcmp
 0B69 38F8              add SP,-8
 0B6B 3900              cmp A,0
 0B6D A02B              jz L294
 0B6F 3901              cmp A,1
 0B71 A027              jz L294
 0B73 5042              mov A,66
 0B75 08                push A
 0B76 501F              mov A,31
 0B78 08                push A
 0B79 5099              mov A,-103
 0B7B 08                push A
 0B7C 509A              mov A,-102
 0B7E 08                push A
 0B7F 5000              mov A,0
 0B81 08                push A
 0B82 08                push A
 0B83 08                push A
 0B84 5122              mov A,[_dpwrQual8dr]
 0B86 08                push A
 0B87 7C0000            xcall __long2fp
 0B8A 7C0000            xcall __fpcmp
 0B8D 38F8              add SP,-8
 0B8F 3900              cmp A,0
 0B91 A007              jz L294
 0B93 3901              cmp A,1
 0B95 A003              jz L294
 0B97                   .dbline 1492
 0B97           ;         setMaxPaLevel();
 0B97                   .dbline 1492
 0B97 90BC              xcall _setMaxPaLevel
 0B99                   .dbline 1493
 0B99           ;     }
 0B99           L294:
 0B99           L293:
 0B99                   .dbline 1498
 0B99           ; 
 0B99           ;     // -----------------------------------------------------------------------
 0B99           ;     // Pick the Data Rate with the best statistic, favor GFSK
 0B99           ;     // -----------------------------------------------------------------------
 0B99           ;     if (--dpwrStayCt == 0) {
 0B99 161F01            sub [_dpwrStayCt],1
 0B9C 3C1F00            cmp [_dpwrStayCt],0
 0B9F B08C              jnz L296
 0BA1                   .dbline 1499
 0BA1           ;         toggleDataRate();                       // CHANGE MODULATION
 0BA1                   .dbline 1499
 0BA1 908D              xcall _toggleDataRate
 0BA3                   .dbline 1500
 0BA3           ;         if (dpwrQualGfsk >= QUAL_THRESHOLD) {       // GFSK=HI, 8DR=dont-care
 0BA3 5042              mov A,66
 0BA5 08                push A
 0BA6 501F              mov A,31
 0BA8 08                push A
 0BA9 5099              mov A,-103
 0BAB 08                push A
 0BAC 509A              mov A,-102
 0BAE 08                push A
 0BAF 5000              mov A,0
 0BB1 08                push A
 0BB2 08                push A
 0BB3 08                push A
 0BB4 5123              mov A,[_dpwrQualGfsk]
 0BB6 08                push A
 0BB7 7C0000            xcall __long2fp
 0BBA 7C0000            xcall __fpcmp
 0BBD 38F8              add SP,-8
 0BBF 39FF              cmp A,-1
 0BC1 A01A              jz L298
 0BC3                   .dbline 1501
 0BC3           ;             dpwrStayCt = GFSK_INUSE ? 4 : 1;        // 4 GFSK : 1 8DR
 0BC3                   .dbline 1501
 0BC3 472518            tst [_CYFISNP_radioTxConfig],24
 0BC6 B009              jnz L301
 0BC8 560104            mov [X+1],4
 0BCB 560000            mov [X+0],0
 0BCE 8007              xjmp L302
 0BD0           L301:
 0BD0 560101            mov [X+1],1
 0BD3 560000            mov [X+0],0
 0BD6           L302:
 0BD6 5201              mov A,[X+1]
 0BD8 531F              mov [_dpwrStayCt],A
 0BDA                   .dbline 1502
 0BDA           ;         }
 0BDA 8051              xjmp L299
 0BDC           L298:
 0BDC                   .dbline 1503
 0BDC           ;         else if  (dpwrQual8dr >= QUAL_THRESHOLD) {  // GFSK=LO, 8DR=HI
 0BDC 5042              mov A,66
 0BDE 08                push A
 0BDF 501F              mov A,31
 0BE1 08                push A
 0BE2 5099              mov A,-103
 0BE4 08                push A
 0BE5 509A              mov A,-102
 0BE7 08                push A
 0BE8 5000              mov A,0
 0BEA 08                push A
 0BEB 08                push A
 0BEC 08                push A
 0BED 5122              mov A,[_dpwrQual8dr]
 0BEF 08                push A
 0BF0 7C0000            xcall __long2fp
 0BF3 7C0000            xcall __fpcmp
 0BF6 38F8              add SP,-8
 0BF8 39FF              cmp A,-1
 0BFA A01A              jz L303
 0BFC                   .dbline 1504
 0BFC           ;             dpwrStayCt = GFSK_INUSE ? 1 : 4;        // 1 GFSK : 4 8DR
 0BFC                   .dbline 1504
 0BFC 472518            tst [_CYFISNP_radioTxConfig],24
 0BFF B009              jnz L306
 0C01 560101            mov [X+1],1
 0C04 560000            mov [X+0],0
 0C07 8007              xjmp L307
 0C09           L306:
 0C09 560104            mov [X+1],4
 0C0C 560000            mov [X+0],0
 0C0F           L307:
 0C0F 5201              mov A,[X+1]
 0C11 531F              mov [_dpwrStayCt],A
 0C13                   .dbline 1505
 0C13           ;         }
 0C13 8018              xjmp L304
 0C15           L303:
 0C15                   .dbline 1506
 0C15           ;         else {                                      // GFSK=LO, 8DR=LO
 0C15                   .dbline 1507
 0C15           ;             dpwrStayCt = GFSK_INUSE ? 1 : 1;        // 1 GFSK : 1 8DR
 0C15 472518            tst [_CYFISNP_radioTxConfig],24
 0C18 B009              jnz L309
 0C1A 560101            mov [X+1],1
 0C1D 560000            mov [X+0],0
 0C20 8007              xjmp L310
 0C22           L309:
 0C22 560101            mov [X+1],1
 0C25 560000            mov [X+0],0
 0C28           L310:
 0C28 5201              mov A,[X+1]
 0C2A 531F              mov [_dpwrStayCt],A
 0C2C                   .dbline 1508
 0C2C           ;         }
 0C2C           L304:
 0C2C           L299:
 0C2C                   .dbline 1509
 0C2C           ;     }
 0C2C           L296:
 0C2C                   .dbline -2
 0C2C           L281:
 0C2C 38FE              add SP,-2
 0C2E 20                pop X
 0C2F                   .dbline 0 ; func end
 0C2F 7F                ret
 0C30                   .dbend
 0C30                   .dbfunc s toggleDataRate _toggleDataRate fV
 0C30           _toggleDataRate:
 0C30                   .dbline -1
 0C30                   .dbline 1527
 0C30           ; 
 0C30           ; //  // DEBUG stuff only compiles if CYFISNP_DEBUG is defined
 0C30           ; //  CYFISNP_OutStr(" <dynPA:");
 0C30           ; //  CYFISNP_OutHex(CYFISNP_GetQualGfsk());              // GFSK quality
 0C30           ; //  CYFISNP_OutHex(CYFISNP_GetQual8dr());               // 8DR quality
 0C30           ; //  CYFISNP_OutChar((CYFISNP_radioTxConfig & 8) ? '.' : 'G'); // (.)8DR or (G)GFSK
 0C30           ; //  CYFISNP_OutNibble(CYFISNP_paLevel);                 // PA Level
 0C30           ; //  CYFISNP_OutNibble(CYFISNP_Read(CYFISNP_TX_CFG_ADR) & 7);  // Radio PA Level
 0C30           ; //  CYFISNP_OutStr(">");
 0C30           ; }
 0C30           ; 
 0C30           ; // ---------------------------------------------------------------------------
 0C30           ; //
 0C30           ; // toggleDataRate() - Toggle between GFSK and 8DR
 0C30           ; //
 0C30           ; // ---------------------------------------------------------------------------
 0C30           ; static void toggleDataRate(void)
 0C30           ; {
 0C30                   .dbline 1528
 0C30           ;     if (GFSK_INUSE) {
 0C30 472518            tst [_CYFISNP_radioTxConfig],24
 0C33 B012              jnz L312
 0C35                   .dbline 1529
 0C35           ;         CYFISNP_radioTxConfig &= ~CYFISNP_TX_DATMODE_MSK;
 0C35                   .dbline 1529
 0C35 2625E7            and [_CYFISNP_radioTxConfig],-25
 0C38                   .dbline 1530
 0C38           ;         CYFISNP_radioTxConfig |=  CYFISNP_DATMODE_8DR;
 0C38 2E2508            or [_CYFISNP_radioTxConfig],8
 0C3B                   .dbline 1531
 0C3B           ;         CYFISNP_Write(CYFISNP_ANALOG_CTRL_ADR, 0);  // Disable all slow
 0C3B 10                push X
 0C3C 5700              mov X,0
 0C3E 5039              mov A,57
 0C40 7C0000            xcall _CYFISNP_Write
 0C43 20                pop X
 0C44                   .dbline 1532
 0C44           ;     }
 0C44 800D              xjmp L313
 0C46           L312:
 0C46                   .dbline 1533
 0C46           ;     else {  // 8DR Used
 0C46                   .dbline 1534
 0C46           ;         CYFISNP_radioTxConfig &= ~CYFISNP_TX_DATMODE_MSK;
 0C46 2625E7            and [_CYFISNP_radioTxConfig],-25
 0C49                   .dbline 1535
 0C49           ;         CYFISNP_radioTxConfig |=  CYFISNP_DATMODE_1MBPS;
 0C49                   .dbline 1536
 0C49           ;         CYFISNP_Write(CYFISNP_ANALOG_CTRL_ADR, CYFISNP_ALLSLOW);
 0C49 10                push X
 0C4A 5701              mov X,1
 0C4C 5039              mov A,57
 0C4E 7C0000            xcall _CYFISNP_Write
 0C51 20                pop X
 0C52                   .dbline 1537
 0C52           ;     }
 0C52           L313:
 0C52                   .dbline 1538
 0C52           ;     writeHwPa();
 0C52 9034              xcall _writeHwPa
 0C54                   .dbline -2
 0C54           L311:
 0C54                   .dbline 0 ; func end
 0C54 7F                ret
 0C55                   .dbend
 0C55                   .dbfunc s setMaxPaLevel _setMaxPaLevel fV
 0C55           _setMaxPaLevel:
 0C55                   .dbline -1
 0C55                   .dbline 1546
 0C55           ; }
 0C55           ; 
 0C55           ; 
 0C55           ; // ---------------------------------------------------------------------------
 0C55           ; // setMaxPaLevel() - Set Maximum Tx power
 0C55           ; // ---------------------------------------------------------------------------
 0C55           ; static void setMaxPaLevel(void)
 0C55           ; {
 0C55                   .dbline 1547
 0C55           ;     setPaLevel(PA_LEVEL_MAX);
 0C55 5007              mov A,7
 0C57 08                push A
 0C58 900B              xcall _setPaLevel
 0C5A 38FF              add SP,-1
 0C5C                   .dbline -2
 0C5C           L314:
 0C5C                   .dbline 0 ; func end
 0C5C 7F                ret
 0C5D                   .dbend
 0C5D                   .dbfunc s setBindPaLevel _setBindPaLevel fV
 0C5D           _setBindPaLevel:
 0C5D                   .dbline -1
 0C5D                   .dbline 1554
 0C5D           ; }
 0C5D           ; 
 0C5D           ; // ---------------------------------------------------------------------------
 0C5D           ; // setBindPaLevel() - Possibly set lower Tx power for Bind Request
 0C5D           ; // ---------------------------------------------------------------------------
 0C5D           ; static void setBindPaLevel(void)
 0C5D           ; {
 0C5D                   .dbline 1555
 0C5D           ;     setPaLevel(CYFISNP_PA_LEVEL_BIND);
 0C5D 5006              mov A,6
 0C5F 08                push A
 0C60 9003              xcall _setPaLevel
 0C62 38FF              add SP,-1
 0C64                   .dbline -2
 0C64           L315:
 0C64                   .dbline 0 ; func end
 0C64 7F                ret
 0C65                   .dbend
 0C65                   .dbfunc s setPaLevel _setPaLevel fV
 0C65           ;        paLevel -> X-4
 0C65           _setPaLevel:
 0C65                   .dbline -1
 0C65 10                push X
 0C66 4F                mov X,SP
 0C67                   .dbline 1563
 0C67           ; }
 0C67           ; 
 0C67           ; 
 0C67           ; // ---------------------------------------------------------------------------
 0C67           ; // setPaLevel() - Set Tx power and assume everything's OK
 0C67           ; // ---------------------------------------------------------------------------
 0C67           ; static void setPaLevel(BYTE paLevel)
 0C67           ; {
 0C67                   .dbline 1564
 0C67           ;     CYFISNP_paLevel = paLevel;
 0C67 52FC              mov A,[X-4]
 0C69 5324              mov [_CYFISNP_paLevel],A
 0C6B                   .dbline 1565
 0C6B           ;     writeHwPa();
 0C6B 901B              xcall _writeHwPa
 0C6D                   .dbline 1567
 0C6D           ; 
 0C6D           ;     dpwrQualGfsk = QUAL_MAX;    // Quality metric at MAX (assume we're OK)
 0C6D 552339            mov [_dpwrQualGfsk],57
 0C70                   .dbline 1568
 0C70           ;     dpwrQual8dr  = QUAL_MAX;    // Quality metric at MAX (assume we're OK)
 0C70 552239            mov [_dpwrQual8dr],57
 0C73                   .dbline 1570
 0C73           ; 
 0C73           ;     dpwrMaxConsecGfsk = 0;      // Zero consecutive counters
 0C73 552100            mov [_dpwrMaxConsecGfsk],0
 0C76                   .dbline 1571
 0C76           ;     dpwrMaxConsec8dr  = 0;      // Zero consecutive counters
 0C76 552000            mov [_dpwrMaxConsec8dr],0
 0C79                   .dbline 1572
 0C79           ;     dpwrStayCt = 1;             // Will start toggling
 0C79 551F01            mov [_dpwrStayCt],1
 0C7C                   .dbline -2
 0C7C           L316:
 0C7C 20                pop X
 0C7D                   .dbline 0 ; func end
 0C7D 7F                ret
 0C7E                   .dbsym l paLevel -4 c
 0C7E                   .dbend
 0C7E                   .dbfunc s decPaLevel _decPaLevel fV
 0C7E           _decPaLevel:
 0C7E                   .dbline -1
 0C7E                   .dbline 1579
 0C7E           ; }
 0C7E           ; 
 0C7E           ; // ---------------------------------------------------------------------------
 0C7E           ; // decPaLevel() - Metrics are good, try decreasing Tx power
 0C7E           ; // ---------------------------------------------------------------------------
 0C7E           ; static void decPaLevel(void)
 0C7E           ; {
 0C7E                   .dbline 1580
 0C7E           ;     if (CYFISNP_paLevel == PA_LEVEL_MIN) {
 0C7E 3C2400            cmp [_CYFISNP_paLevel],0
 0C81                   .dbline 1581
 0C81           ;         return;
 0C81                   .dbline 1581
 0C81 A005              jz L317
 0C83           L318:
 0C83                   .dbline 1584
 0C83           ;     }
 0C83           ; #ifndef TEST_DISABLE_DYNAMIC_PA
 0C83           ;     --CYFISNP_paLevel;
 0C83 7A24              dec [_CYFISNP_paLevel]
 0C85                   .dbline 1586
 0C85           ; #endif
 0C85           ;     writeHwPa();
 0C85 9001              xcall _writeHwPa
 0C87                   .dbline -2
 0C87           L317:
 0C87                   .dbline 0 ; func end
 0C87 7F                ret
 0C88                   .dbend
 0C88                   .dbfunc s writeHwPa _writeHwPa fV
 0C88           ;         regVal -> X+0
 0C88           _writeHwPa:
 0C88                   .dbline -1
 0C88 10                push X
 0C89 4F                mov X,SP
 0C8A 10                push X
 0C8B                   .dbline 1594
 0C8B           ; }
 0C8B           ; 
 0C8B           ; 
 0C8B           ; // ---------------------------------------------------------------------------
 0C8B           ; // writeHwPa() - Write PA Level to hardware
 0C8B           ; // ---------------------------------------------------------------------------
 0C8B           ; static void writeHwPa(void)
 0C8B           ; {
 0C8B                   .dbline 1595
 0C8B           ;     BYTE regVal = CYFISNP_PA_PHY_TBL[CYFISNP_paLevel]
 0C8B 5F0024            mov [__r1],[_CYFISNP_paLevel]
 0C8E 550000            mov [__r0],0
 0C91 060000            add [__r1],<_CYFISNP_PA_PHY_TBL
 0C94 0E0000            adc [__r0],>_CYFISNP_PA_PHY_TBL
 0C97 5100              mov A,[__r0]
 0C99 10                push X
 0C9A 5800              mov X,[__r1]
 0C9C 28                romx
 0C9D 20                pop X
 0C9E 2107              and A,7
 0CA0 5400              mov [X+0],A
 0CA2                   .dbline 1604
 0CA2           ;                 & CYFISNP_PA_VAL_MSK;
 0CA2           ; 
 0CA2           ; #if (CYFISNP_EXTERNAL_PA)
 0CA2           ;     BOOL paOn = ((CYFISNP_PA_PHY_TBL[CYFISNP_paLevel] & 0xF0) != 0);
 0CA2           ;     if (paOn )      externalPaEnable();
 0CA2           ;     else            externalPaDisable();
 0CA2           ; #endif
 0CA2           ; 
 0CA2           ;     CYFISNP_SetTxConfig(CYFISNP_radioTxConfig + regVal);
 0CA2 5125              mov A,[_CYFISNP_radioTxConfig]
 0CA4 0300              add A,[X+0]
 0CA6 10                push X
 0CA7 7C0000            xcall _CYFISNP_SetTxConfig
 0CAA 20                pop X
 0CAB                   .dbline -2
 0CAB           L320:
 0CAB 20                pop X
 0CAC 20                pop X
 0CAD                   .dbline 0 ; func end
 0CAD 7F                ret
 0CAE                   .dbsym l regVal 0 c
 0CAE                   .dbend
 0CAE                   .dbfunc e CYFISNP_spiSleep _CYFISNP_spiSleep fV
 0CAE           _CYFISNP_spiSleep::
 0CAE                   .dbline -1
 0CAE                   .dbline 1683
 0CAE           ; }
 0CAE           ; 
 0CAE           ; 
 0CAE           ; // If external PA hardware is installed (either Disabled or Enabled)
 0CAE           ; #if (CYFISNP_EXTERNAL_PA)
 0CAE           ; // ---------------------------------------------------------------------------
 0CAE           ; //
 0CAE           ; // externalPaEnable()  - Enable  external PA
 0CAE           ; // externalPaDisable() - Disable external PA
 0CAE           ; //
 0CAE           ; // ---------------------------------------------------------------------------
 0CAE           ; static void externalPaEnable(void)
 0CAE           ; {
 0CAE           ;     char regVal;
 0CAE           ;     // -----------------------------------------------------------------------
 0CAE           ;     // PACTL_pin = PACTL Function
 0CAE           ;     // -----------------------------------------------------------------------
 0CAE           ;     regVal  =  CYFISNP_Read(CYFISNP_IO_CFG_ADR);
 0CAE           ;     regVal &= ~CYFISNP_PACTL_GPIO;
 0CAE           ;     CYFISNP_Write(CYFISNP_IO_CFG_ADR, regVal);
 0CAE           ; 
 0CAE           ;     // -----------------------------------------------------------------------
 0CAE           ;     //  XOUT_pin = ~PACTL Function (inverse of PACTL)
 0CAE           ;     // -----------------------------------------------------------------------
 0CAE           ;     regVal  =  CYFISNP_Read(CYFISNP_XTAL_CTRL_ADR);
 0CAE           ;     regVal &= ~CYFISNP_XOUT_FNC_MSK;
 0CAE           ;     regVal |=  CYFISNP_XOUT_FNC_PA_N;
 0CAE           ;     CYFISNP_Write(CYFISNP_XTAL_CTRL_ADR, regVal);
 0CAE           ; }
 0CAE           ; 
 0CAE           ; static void externalPaDisable(void)
 0CAE           ; {
 0CAE           ;     char regVal;
 0CAE           ; 
 0CAE           ; //  // -----------------------------------------------------------------------
 0CAE           ; //  // Values for PACTL and XOUT when configured for Vendor_A GPIO
 0CAE           ; //  // PACTL = GPIO = 0 (no power for External PA)
 0CAE           ; //  //  XOUT = GPIO = 1 (connect Radio directly to antenna)
 0CAE           ; //  // -----------------------------------------------------------------------
 0CAE           ; //  regVal  =  CYFISNP_Read(CYFISNP_GPIO_CTRL_ADR);
 0CAE           ; //  regVal |=  CYFISNP_XOUT_OP;                 //  XOUT = 1
 0CAE           ; //  regVal &= ~CYFISNP_PACTL_OP;                // PACTL = 0
 0CAE           ; //  CYFISNP_Write(CYFISNP_GPIO_CTRL_ADR, regVal);
 0CAE           ; 
 0CAE           ;     // -----------------------------------------------------------------------
 0CAE           ;     //  PACTL_pin = GPIO Function  (= LOW)
 0CAE           ;     // -----------------------------------------------------------------------
 0CAE           ;     regVal  = CYFISNP_Read(CYFISNP_IO_CFG_ADR);
 0CAE           ;     regVal |= CYFISNP_PACTL_GPIO;
 0CAE           ;     CYFISNP_Write(CYFISNP_IO_CFG_ADR, regVal);
 0CAE           ; 
 0CAE           ;     // -----------------------------------------------------------------------
 0CAE           ;     //  XOUT_pin = GPIO Function (= HIGH)
 0CAE           ;     // -----------------------------------------------------------------------
 0CAE           ;     regVal  =  CYFISNP_Read(CYFISNP_XTAL_CTRL_ADR);
 0CAE           ;     regVal &= ~CYFISNP_XOUT_FNC_MSK;
 0CAE           ;     regVal |=  CYFISNP_XOUT_FNC_GPIO;
 0CAE           ;     CYFISNP_Write(CYFISNP_XTAL_CTRL_ADR, regVal);
 0CAE           ; }
 0CAE           ; #endif //  #if (CYFISNP_EXTERNAL_PA)
 0CAE           ; 
 0CAE           ; 
 0CAE           ; #if (CYFISNP_PWR_TYPE != CYFISNP_PWR_WALL)
 0CAE           ; // ---------------------------------------------------------------------------
 0CAE           ; //
 0CAE           ; // CYFISNP_spiSleep() - Minimize LRADIO power
 0CAE           ; //
 0CAE           ; //  This disconnects SPI, so you can't communicate with the Radio until
 0CAE           ; //   subsequently calling CYFISNP_spiWake().
 0CAE           ; //
 0CAE           ; // ---------------------------------------------------------------------------
 0CAE           ; static BYTE old_XtalCtrlAdr;
 0CAE           ; static BYTE old_IoCfgAdr;
 0CAE           ; static BYTE old_GpioCtrlAdr;
 0CAE           ; static BYTE old_XactCfgAdr;
 0CAE           ; static BOOL spiSleeping;
 0CAE           ; 
 0CAE           ; void CYFISNP_spiSleep(void)
 0CAE           ; {
 0CAE                   .dbline 1684
 0CAE           ;     if (spiSleeping == TRUE) {
 0CAE 3C0001            cmp [_spiSleeping],1
 0CB1                   .dbline 1685
 0CB1           ;         return;
 0CB1                   .dbline 1685
 0CB1 A04C              jz L321
 0CB3           L322:
 0CB3                   .dbline 1687
 0CB3           ;     }
 0CB3           ;     spiSleeping = TRUE;
 0CB3 550001            mov [_spiSleeping],1
 0CB6                   .dbline 1692
 0CB6           ; 
 0CB6           ;     // -----------------------------------------------------------------------
 0CB6           ;     // Save CYFISPI settings so they can be restored via CYFISNP_spiWake()
 0CB6           ;     // -----------------------------------------------------------------------
 0CB6           ;     old_XtalCtrlAdr = CYFISNP_Read(CYFISNP_XTAL_CTRL_ADR);
 0CB6 10                push X
 0CB7 500C              mov A,12
 0CB9 7C0000            xcall _CYFISNP_Read
 0CBC 20                pop X
 0CBD 5304              mov [_old_XtalCtrlAdr],A
 0CBF                   .dbline 1693
 0CBF           ;     old_IoCfgAdr    = CYFISNP_Read(CYFISNP_IO_CFG_ADR);
 0CBF 10                push X
 0CC0 500D              mov A,13
 0CC2 7C0000            xcall _CYFISNP_Read
 0CC5 20                pop X
 0CC6 5303              mov [_old_IoCfgAdr],A
 0CC8                   .dbline 1694
 0CC8           ;     old_XactCfgAdr  = CYFISNP_GetXactConfig();
 0CC8 10                push X
 0CC9 7C0000            xcall _CYFISNP_GetXactConfig
 0CCC 20                pop X
 0CCD 5301              mov [_old_XactCfgAdr],A
 0CCF                   .dbline 1695
 0CCF           ;     old_GpioCtrlAdr = CYFISNP_Read(CYFISNP_GPIO_CTRL_ADR);
 0CCF 10                push X
 0CD0 500E              mov A,14
 0CD2 7C0000            xcall _CYFISNP_Read
 0CD5 20                pop X
 0CD6 5302              mov [_old_GpioCtrlAdr],A
 0CD8                   .dbline 1705
 0CD8           ; #if (CYFISNP_EXTERNAL_PA)
 0CD8           ;     old_GpioCtrlAdr |=  CYFISNP_XOUT_OP;       //  XOUT = 1
 0CD8           ;     old_GpioCtrlAdr &= ~CYFISNP_PACTL_OP;      // PACTL = 0
 0CD8           ; #endif
 0CD8           ; 
 0CD8           ;     // -----------------------------------------------------------------------
 0CD8           ;     // If RADIO is not sleeping, then manually FORCE to sleep
 0CD8           ;     //  (if it's already asleep, then don't wakeup just to put it to sleep).
 0CD8           ;     // -----------------------------------------------------------------------
 0CD8           ;     if ((old_XactCfgAdr&CYFISNP_END_STATE_MSK) != CYFISNP_END_STATE_SLEEP) {
 0CD8 47011C            tst [_old_XactCfgAdr],28
 0CDB A008              jz L324
 0CDD                   .dbline 1706
 0CDD           ;         CYFISNP_ForceState(0);
 0CDD                   .dbline 1706
 0CDD 10                push X
 0CDE 5000              mov A,0
 0CE0 7C0000            xcall _CYFISNP_ForceState
 0CE3 20                pop X
 0CE4                   .dbline 1707
 0CE4           ;     }
 0CE4           L324:
 0CE4                   .dbline 1717
 0CE4           ; 
 0CE4           ;     // -----------------------------------------------------------------------
 0CE4           ;     // Since Radio could be operating on lower voltage than CPU, drive
 0CE4           ;     //  {MOSI,SCK,nSS} CPU outputs LOW to stop leakage from CPU to RADIO power
 0CE4           ;     //
 0CE4           ;     // Set XOUT LOW by setting to GPIO to minimize SPI/Radio current.
 0CE4           ;     // Set MISO LOW by changing to GPIO to keep from floating.
 0CE4           ;     // Set MOSI LOW by ensuring MISO is LOW during final SPI operation
 0CE4           ;     // -----------------------------------------------------------------------
 0CE4           ;     CYFISNP_Write(CYFISNP_XTAL_CTRL_ADR,
 0CE4 10                push X
 0CE5 57C0              mov X,-64
 0CE7 500C              mov A,12
 0CE9 7C0000            xcall _CYFISNP_Write
 0CEC                   .dbline 1719
 0CEC           ;                   CYFISNP_XOUT_FNC_GPIO);           // XOUT=GPIO
 0CEC           ;     CYFISNP_Write(CYFISNP_IO_CFG_ADR, 0x42);        // SPI3PIN & MISO GPIO
 0CEC 5742              mov X,66
 0CEE 500D              mov A,13
 0CF0 7C0000            xcall _CYFISNP_Write
 0CF3                   .dbline 1721
 0CF3           ;                     // MISO goes LOW because that's MISO_GPIO's default
 0CF3           ;     CYFISNP_Write(CYFISNP_GPIO_CTRL_ADR ,0x00);     // XOUT=0 and leave MISO=0
 0CF3 5700              mov X,0
 0CF5 500E              mov A,14
 0CF7 7C0000            xcall _CYFISNP_Write
 0CFA 20                pop X
 0CFB                   .dbline 1723
 0CFB           ;                     // MOSI ends LOW because MISO[7] was 0 during last Write
 0CFB           ;     CYFISNP_RADIO_SELECT;
 0CFB                   .dbline 1723
 0CFB 41087F            and REG[0x8],127
 0CFE                   .dbline 1723
 0CFE                   .dbline 1723
 0CFE                   .dbline -2
 0CFE           L321:
 0CFE                   .dbline 0 ; func end
 0CFE 7F                ret
 0CFF                   .dbend
 0CFF                   .dbfunc e CYFISNP_spiWake _CYFISNP_spiWake fV
 0CFF           _CYFISNP_spiWake::
 0CFF                   .dbline -1
 0CFF                   .dbline 1734
 0CFF           ;     // SPI NOT FUNCTIONAL UNTIL CYFISNP_spiWake() IS CALLED
 0CFF           ; }
 0CFF           ; 
 0CFF           ; // ---------------------------------------------------------------------------
 0CFF           ; //
 0CFF           ; // CYFISNP_spiWake() - Restore normal Radio operation,
 0CFF           ; //                              Called to exit CYFISNP_spiSleep().
 0CFF           ; //
 0CFF           ; // ---------------------------------------------------------------------------
 0CFF           ; void CYFISNP_spiWake(void)
 0CFF           ; {
 0CFF                   .dbline 1735
 0CFF           ;     if (spiSleeping == FALSE) {
 0CFF 3C0000            cmp [_spiSleeping],0
 0D02                   .dbline 1736
 0D02           ;         return;
 0D02                   .dbline 1736
 0D02 A02A              jz L326
 0D04           L327:
 0D04                   .dbline 1738
 0D04           ;     }
 0D04           ;     spiSleeping = FALSE;
 0D04 550000            mov [_spiSleeping],0
 0D07                   .dbline 1739
 0D07           ;       CYFISNP_RADIO_DESELECT;
 0D07                   .dbline 1739
 0D07 430880            or REG[0x8],-128
 0D0A                   .dbline 1739
 0D0A                   .dbline 1739
 0D0A                   .dbline 1740
 0D0A           ;     CYFISNP_Write(CYFISNP_IO_CFG_ADR,    old_IoCfgAdr);     // Restore SPI3PIN
 0D0A 10                push X
 0D0B 5803              mov X,[_old_IoCfgAdr]
 0D0D 500D              mov A,13
 0D0F 7C0000            xcall _CYFISNP_Write
 0D12                   .dbline 1741
 0D12           ;     CYFISNP_Write(CYFISNP_GPIO_CTRL_ADR, old_GpioCtrlAdr);  // Restore GPIO
 0D12 5802              mov X,[_old_GpioCtrlAdr]
 0D14 500E              mov A,14
 0D16 7C0000            xcall _CYFISNP_Write
 0D19                   .dbline 1742
 0D19           ;     CYFISNP_Write(CYFISNP_XTAL_CTRL_ADR, old_XtalCtrlAdr);  // Restore XOUT FN
 0D19 5804              mov X,[_old_XtalCtrlAdr]
 0D1B 500C              mov A,12
 0D1D 7C0000            xcall _CYFISNP_Write
 0D20 20                pop X
 0D21                   .dbline 1744
 0D21           ; 
 0D21           ;     if ((old_XactCfgAdr&CYFISNP_END_STATE_MSK) != CYFISNP_END_STATE_SLEEP) {
 0D21 47011C            tst [_old_XactCfgAdr],28
 0D24 A008              jz L329
 0D26                   .dbline 1745
 0D26           ;         CYFISNP_ForceState(old_XactCfgAdr);          // Restore radio state
 0D26                   .dbline 1745
 0D26 10                push X
 0D27 5101              mov A,[_old_XactCfgAdr]
 0D29 7C0000            xcall _CYFISNP_ForceState
 0D2C 20                pop X
 0D2D                   .dbline 1746
 0D2D           ;     }
 0D2D           L329:
 0D2D                   .dbline -2
 0D2D           L326:
 0D2D                   .dbline 0 ; func end
 0D2D 7F                ret
 0D2E                   .dbend
 0D2E                   .dbfunc s netParamsPresent _netParamsPresent fc
 0D2E           _netParamsPresent:
 0D2E                   .dbline -1
 0D2E                   .dbline 1757
 0D2E           ; }
 0D2E           ; #endif // (CYFISNP_PWR_TYPE != CYFISNP_PWR_WALL)
 0D2E           ; 
 0D2E           ; 
 0D2E           ; // ---------------------------------------------------------------------------
 0D2E           ; //
 0D2E           ; // netParamsPresent() - Determine currently Bound
 0D2E           ; //                          A valid hubSeedMsb is never 0x00
 0D2E           ; //
 0D2E           ; // ---------------------------------------------------------------------------
 0D2E           ; static BOOL netParamsPresent (void) {
 0D2E                   .dbline 1758
 0D2E           ;     if (CYFISNP_EEP_NET_REC_ADR->hubSeedMsb != 0) {
 0D2E 503F              mov A,63
 0D30 10                push X
 0D31 57C3              mov X,-61
 0D33 28                romx
 0D34 20                pop X
 0D35 3900              cmp A,0
 0D37 A005              jz L332
 0D39                   .dbline 1759
 0D39           ;         return(TRUE);
 0D39                   .dbline 1759
 0D39 5001              mov A,1
 0D3B 8003              xjmp L331
 0D3D           L332:
 0D3D                   .dbline 1761
 0D3D           ;     }
 0D3D           ;     return(FALSE);
 0D3D 5000              mov A,0
 0D3F                   .dbline -2
 0D3F           L331:
 0D3F                   .dbline 0 ; func end
 0D3F 7F                ret
 0D40                   .dbend
 0D40                   .dbfunc s crc0AutoAck _crc0AutoAck fV
 0D40           ;         enable -> X-4
 0D40           _crc0AutoAck:
 0D40                   .dbline -1
 0D40 10                push X
 0D41 4F                mov X,SP
 0D42                   .dbline 1770
 0D42           ; }
 0D42           ; 
 0D42           ; // ---------------------------------------------------------------------------
 0D42           ; // crc0AutoAck() - Disable and enable autoacks for CRC0 packets.
 0D42           ; //
 0D42           ; //  When transmitting w/CRC0, we expect an AutoAck (e.g. Bind/ParamReq).
 0D42           ; //  When receiving w/CRC0, we don't want to return an AutoAck (e.g. Beacon)
 0D42           ; // ---------------------------------------------------------------------------
 0D42           ; static void crc0AutoAck(BOOL enable) {
 0D42                   .dbline 1771
 0D42           ;     if (enable == TRUE) {
 0D42 3DFC01            cmp [X-4],1
 0D45 B00C              jnz L335
 0D47                   .dbline 1772
 0D47           ;         CYFISNP_Write(CYFISNP_RX_OVERRIDE_ADR, 0);
 0D47                   .dbline 1772
 0D47 10                push X
 0D48 5700              mov X,0
 0D4A 501E              mov A,30
 0D4C 7C0000            xcall _CYFISNP_Write
 0D4F 20                pop X
 0D50                   .dbline 1773
 0D50           ;     } else {
 0D50 800A              xjmp L336
 0D52           L335:
 0D52                   .dbline 1773
 0D52                   .dbline 1774
 0D52           ;         CYFISNP_Write(CYFISNP_RX_OVERRIDE_ADR, CYFISNP_DIS_CRC0);
 0D52 10                push X
 0D53 5708              mov X,8
 0D55 501E              mov A,30
 0D57 7C0000            xcall _CYFISNP_Write
 0D5A 20                pop X
 0D5B                   .dbline 1775
 0D5B           ;     }
 0D5B           L336:
 0D5B                   .dbline -2
 0D5B           L334:
 0D5B 20                pop X
 0D5C                   .dbline 0 ; func end
 0D5C 7F                ret
 0D5D                   .dbsym l enable -4 c
 0D5D                   .dbend
 0D5D                   .dbfunc e CYFISNP_GetQualGfsk _CYFISNP_GetQualGfsk fc
 0D5D           _CYFISNP_GetQualGfsk::
 0D5D                   .dbline -1
 0D5D                   .dbline 1779
 0D5D           ; }
 0D5D           ; 
 0D5D           ; 
 0D5D           ; BYTE CYFISNP_GetQualGfsk(void) {        // Debug access for API
 0D5D                   .dbline 1780
 0D5D           ;     return (dpwrQualGfsk);
 0D5D 5123              mov A,[_dpwrQualGfsk]
 0D5F                   .dbline -2
 0D5F           L337:
 0D5F                   .dbline 0 ; func end
 0D5F 7F                ret
 0D60                   .dbend
 0D60                   .dbfunc e CYFISNP_GetQual8dr _CYFISNP_GetQual8dr fc
 0D60           _CYFISNP_GetQual8dr::
 0D60                   .dbline -1
 0D60                   .dbline 1782
 0D60           ; }
 0D60           ; BYTE CYFISNP_GetQual8dr(void) {         // Debug access for API
 0D60                   .dbline 1783
 0D60           ;     return(dpwrQual8dr);
 0D60 5122              mov A,[_dpwrQual8dr]
 0D62                   .dbline -2
 0D62           L338:
 0D62                   .dbline 0 ; func end
 0D62 7F                ret
 0D63                   .dbend
                        .area bss(ram, con, rel)
 0000                   .dbfile D:\Studia\PSOC\RF_I2C_BRIDGE\RF_I2C_BRIDGE\lib\cyfisnp_protocol.c
 0000           _spiSleeping:
 0000                   .blkb 1
 0001                   .dbsym s spiSleeping _spiSleeping c
 0001           _old_XactCfgAdr:
 0001                   .blkb 1
 0002                   .dbsym s old_XactCfgAdr _old_XactCfgAdr c
 0002           _old_GpioCtrlAdr:
 0002                   .blkb 1
 0003                   .dbsym s old_GpioCtrlAdr _old_GpioCtrlAdr c
 0003           _old_IoCfgAdr:
 0003                   .blkb 1
 0004                   .dbsym s old_IoCfgAdr _old_IoCfgAdr c
 0004           _old_XtalCtrlAdr:
 0004                   .blkb 1
 0005                   .dbsym s old_XtalCtrlAdr _old_XtalCtrlAdr c
 0005           _CYFISNP_inRxGo:
 0005                   .blkb 1
 0006                   .dbsym s CYFISNP_inRxGo _CYFISNP_inRxGo c
 0006           _beaconMaxTimer:
 0006                   .blkb 2
 0008                   .dbsym s beaconMaxTimer _beaconMaxTimer i
 0008           _bindReqTimer:
 0008                   .blkb 2
 000A                   .dbsym s bindReqTimer _bindReqTimer i
 000A           _wBindModeCounter:
 000A                   .blkb 2
 000C                   .dbsym s wBindModeCounter _wBindModeCounter i
 000C           _bindChIdx:
 000C                   .blkb 1
 000D                   .dbsym s bindChIdx _bindChIdx c
 000D           _wModeDelay:
 000D                   .blkb 2
 000F                   .dbsym s wModeDelay _wModeDelay i
 000F           _wModeCounter:
 000F                   .blkb 2
 0011                   .dbsym s wModeCounter _wModeCounter i
 0011           _fGotChanAck:
 0011                   .blkb 1
 0012                   .dbsym s fGotChanAck _fGotChanAck c
 0012           _onChanTxLeft:
 0012                   .blkb 1
 0013                   .dbsym s onChanTxLeft _onChanTxLeft c
 0013           _rspWindowTimer:
 0013                   .blkb 2
 0015                   .dbsym s rspWindowTimer _rspWindowTimer i
 0015           _txPending:
 0015                   .blkb 1
 0016                   .dbsym s txPending _txPending c
 0016           _pTxStruct:
 0016                   .blkb 2
 0018                   .dbsym s pTxStruct _pTxStruct pS[.4]
 0018           _bDataRetryCt:
 0018                   .blkb 1
 0019                   .dbsym s bDataRetryCt _bDataRetryCt c
 0019           _idleReceive:
 0019                   .blkb 1
 001A                   .dbsym s idleReceive _idleReceive c
 001A           _rxLen:
 001A                   .blkb 1
 001B                   .dbsym s rxLen _rxLen c
 001B           _radioStateCopy:
 001B                   .blkb 1
 001C                   .dbsym s radioStateCopy _radioStateCopy c
 001C           _rxBufPend:
 001C                   .blkb 1
 001D                   .dbsym s rxBufPend _rxBufPend c
 001D           _fEsb:
 001D                   .blkb 1
 001E                   .dbsym s fEsb _fEsb c
 001E           _fTsb:
 001E                   .blkb 1
 001F                   .dbsym s fTsb _fTsb c
 001F           _dpwrStayCt:
 001F                   .blkb 1
 0020                   .dbsym s dpwrStayCt _dpwrStayCt c
 0020           _dpwrMaxConsec8dr:
 0020                   .blkb 1
 0021                   .dbsym s dpwrMaxConsec8dr _dpwrMaxConsec8dr c
 0021           _dpwrMaxConsecGfsk:
 0021                   .blkb 1
 0022                   .dbsym s dpwrMaxConsecGfsk _dpwrMaxConsecGfsk c
 0022           _dpwrQual8dr:
 0022                   .blkb 1
 0023                   .dbsym s dpwrQual8dr _dpwrQual8dr c
 0023           _dpwrQualGfsk:
 0023                   .blkb 1
 0024                   .dbsym s dpwrQualGfsk _dpwrQualGfsk c
 0024           _CYFISNP_paLevel::
 0024                   .blkb 1
 0025                   .dbsym e CYFISNP_paLevel _CYFISNP_paLevel c
 0025           _CYFISNP_radioTxConfig::
 0025                   .blkb 1
 0026                   .dbsym e CYFISNP_radioTxConfig _CYFISNP_radioTxConfig c
 0026           _SNP_rxBuf:
 0026                   .blkb 13
 0033                   .dbstruct 0 9 .7
 0033                   .dbfield 0 length c
 0033                   .dbfield 1 rssi c
 0033                   .dbfield 2 type c
 0033                   .dbfield 3 devId c
 0033                   .dbfield 4 payload A[5:5]c
 0033                   .dbend
 0033                   .dbstruct 0 13 .8
 0033                   .dbfield 0 length c
 0033                   .dbfield 1 rssi c
 0033                   .dbfield 2 devId c
 0033                   .dbfield 3 pkt A[10:10]c
 0033                   .dbend
 0033                   .dbunion 0 13 .6
 0033                   .dbfield 0 api S[.7]
 0033                   .dbfield 0 snp S[.8]
 0033                   .dbend
 0033                   .dbsym s SNP_rxBuf _SNP_rxBuf S[.6]
 0033           _SNP_txBuf:
 0033                   .blkb 7
 003A                   .dbsym s SNP_txBuf _SNP_txBuf A[7:7]c
 003A           _CYFISNP_bCurrentChannel::
 003A                   .blkb 1
 003B                   .dbsym e CYFISNP_bCurrentChannel _CYFISNP_bCurrentChannel c
 003B           _CYFISNP_eProtState::
 003B                   .blkb 1
 003C                   .dbsym e CYFISNP_eProtState _CYFISNP_eProtState c
