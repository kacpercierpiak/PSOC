FILE: .\boot.asm                        (0001) ;  Generated by PSoC Designer 5.4.3191
                                        (0002) ;
                                        (0003) ;@Id: boot.tpl#903 @
                                        (0004) ;=============================================================================
                                        (0005) ;  FILENAME:   boot.asm
                                        (0006) ;  Version:    4.30
                                        (0007) ;
                                        (0008) ;  DESCRIPTION:
                                        (0009) ;  M8C Boot Code for CY8C27xxx microcontroller family.
                                        (0010) ;
                                        (0011) ;  Copyright (c) Cypress Semiconductor 2015. All Rights Reserved.
                                        (0012) ;
                                        (0013) ; NOTES:
                                        (0014) ; PSoC Designer's Device Editor uses a template file, BOOT.TPL, located in
                                        (0015) ; the project's root directory to create BOOT.ASM. Any changes made to
                                        (0016) ; BOOT.ASM will be  overwritten every time the project is generated; therefore
                                        (0017) ; changes should be made to BOOT.TPL not BOOT.ASM. Care must be taken when
                                        (0018) ; modifying BOOT.TPL so that replacement strings (such as @PROJECT_NAME)
                                        (0019) ; are not accidentally modified.
                                        (0020) ;
                                        (0021) ;=============================================================================
                                        (0022) 
                                        (0023) include ".\lib\GlobalParams.inc"	;File generated by PSoC Designer (Project dependent)
                                        (0024) include "m8c.inc"			;Part specific file
                                        (0025) include "m8ssc.inc"			;Part specific file
                                        (0026) include "memory.inc"			;File generated by PSoC Designer (Project dependent)
                                        (0027) 
                                        (0028) ;--------------------------------------
                                        (0029) ; Export Declarations
                                        (0030) ;--------------------------------------
                                        (0031) 
                                        (0032) export __Start
                                        (0033) IF	(TOOLCHAIN & HITECH)
                                        (0034) ELSE
                                        (0035) export __bss_start
                                        (0036) export __data_start
                                        (0037) export __idata_start
                                        (0038) export __func_lit_start
                                        (0039) export __text_start
                                        (0040) ENDIF
                                        (0041) export  _bGetPowerSetting
                                        (0042) export   bGetPowerSetting
                                        (0043) 
                                        (0044) 
                                        (0045) ;--------------------------------------
                                        (0046) ; Optimization flags
                                        (0047) ;--------------------------------------
                                        (0048) ;
                                        (0049) ; To change the value of these flags, modify the file boot.tpl, not
                                        (0050) ; boot.asm. See the notes in the banner comment at the beginning of
                                        (0051) ; this file.
                                        (0052) 
                                        (0053) ; Optimization for Assembly language (only) projects and C-language projects
                                        (0054) ; that do not depend on the C compiler to initialize the values of RAM variables.
                                        (0055) ;   Set to 1: Support for C Run-time Environment initialization
                                        (0056) ;   Set to 0: Support for C not included. Faster start up, smaller code space.
                                        (0057) ;
                                        (0058) IF	(TOOLCHAIN & HITECH)
                                        (0059) ; The C compiler will customize the startup code - it's not required here
                                        (0060) 
                                        (0061) C_LANGUAGE_SUPPORT:              equ 0
                                        (0062) ELSE
                                        (0063) C_LANGUAGE_SUPPORT:              equ 1
                                        (0064) ENDIF
                                        (0065) 
                                        (0066) 
                                        (0067) ; The following equate is required for proper operation. Reseting its value
                                        (0068) ; is discouraged.  WAIT_FOR_32K is effective only if the crystal oscillator is
                                        (0069) ; selected.  If the designer chooses to not wait then stabilization of the ECO
                                        (0070) ; and PLL_Lock must take place within user code. See the family data sheet for
                                        (0071) ; the requirements of starting the ECO and PLL lock mode.
                                        (0072) ;
                                        (0073) ;   Set to 1: Wait for XTAL (& PLL if selected) to stabilize before
                                        (0074) ;                invoking main
                                        (0075) ;   Set to 0: Boot code does not wait; clock may not have stabilized by
                                        (0076) ;               the time code in main starts executing.
                                        (0077) ;
                                        (0078) WAIT_FOR_32K:                    equ 1
                                        (0079) 
                                        (0080) 
                                        (0081) ; For historical reasons, by default the boot code uses an lcall instruction
                                        (0082) ; to invoke the user's _main code. If _main executes a return instruction,
                                        (0083) ; boot provides an infinite loop. By changing the following equate from zero
                                        (0084) ; to 1, boot's lcall will be replaced by a ljmp instruction, saving two
                                        (0085) ; bytes on the stack which are otherwise required for the return address. If
                                        (0086) ; this option is enabled, _main must not return. (Beginning with the 4.2
                                        (0087) ; release, the C compiler automatically places an infinite loop at the end
                                        (0088) ; of main, rather than a return instruction.)
                                        (0089) ;
                                        (0090) ENABLE_LJMP_TO_MAIN:             equ 0
                                        (0091) 
                                        (0092) 
                                        (0093) ;-----------------------------------------------------------------------------
                                        (0094) ; Interrupt Vector Table
                                        (0095) ;-----------------------------------------------------------------------------
                                        (0096) ;
                                        (0097) ; Interrupt vector table entries are 4 bytes long.  Each one contains
                                        (0098) ; a jump instruction to an ISR (Interrupt Service Routine), although
                                        (0099) ; very short ISRs could be encoded within the table itself. Normally,
                                        (0100) ; vector jump targets are modified automatically according to the user
                                        (0101) ; modules selected. This occurs when the 'Generate Application' opera-
                                        (0102) ; tion is run causing PSoC Designer to create boot.asm and the other
                                        (0103) ; configuration files. If you need to hard code a vector, update the
                                        (0104) ; file boot.tpl, not boot.asm. See the banner comment at the beginning
                                        (0105) ; of this file.
                                        (0106) ;-----------------------------------------------------------------------------
                                        (0107) 
                                        (0108)     AREA TOP (ROM, ABS, CON)
                                        (0109) 
                                        (0110)     org   0                        ;Reset Interrupt Vector
                                        (0111) IF	(TOOLCHAIN & HITECH)
                                        (0112) ;   jmp   __Start                  ;C compiler fills in this vector
                                        (0113) ELSE
0000: 80 67    JMP   0x0068             (0114)     jmp   __Start                  ;First instruction executed following a Reset
                                        (0115) ENDIF
                                        (0116)     ;@PSoC_BOOT_ISR_UserCode_START@
                                        (0117)     ;---------------------------------------------------
                                        (0118)     ; Insert your custom code below this banner
                                        (0119)     ;---------------------------------------------------
                                        (0120) 
                                        (0121)     org   04h                      ;Low Voltage Detect (LVD) Interrupt Vector
0004: 30       HALT                     (0122)     halt                           ;Stop execution if power falls too low
                                        (0123) 
                                        (0124)     org   08h                      ;Analog Column 0 Interrupt Vector
                                        (0125)     // call	void_handler
0008: 7E       RETI                     (0126)     reti
                                        (0127) 
                                        (0128)     org   0Ch                      ;Analog Column 1 Interrupt Vector
                                        (0129)     // call	void_handler
000C: 7E       RETI                     (0130)     reti
                                        (0131) 
                                        (0132)     org   10h                      ;Analog Column 2 Interrupt Vector
                                        (0133)     // call	void_handler
0010: 7E       RETI                     (0134)     reti
                                        (0135) 
                                        (0136)     org   14h                      ;Analog Column 3 Interrupt Vector
                                        (0137)     // call	void_handler
0014: 7E       RETI                     (0138)     reti
                                        (0139) 
                                        (0140)     org   18h                      ;VC3 Interrupt Vector
                                        (0141)     // call	void_handler
0018: 7E       RETI                     (0142)     reti
                                        (0143) 
                                        (0144)     org   1Ch                      ;GPIO Interrupt Vector
                                        (0145)     // call	void_handler
001C: 7E       RETI                     (0146)     reti
                                        (0147) 
                                        (0148)     org   20h                      ;PSoC Block DBB00 Interrupt Vector
0020: 7D 02 FD LJMP  _Timer8_ISR        (0149)     ljmp	_Timer8_ISR
0023: 7E       RETI                     (0150)     reti
                                        (0151) 
                                        (0152)     org   24h                      ;PSoC Block DBB01 Interrupt Vector
                                        (0153)     // call	void_handler
0024: 7E       RETI                     (0154)     reti
                                        (0155) 
                                        (0156)     org   28h                      ;PSoC Block DCB02 Interrupt Vector
                                        (0157)     // call	void_handler
0028: 7E       RETI                     (0158)     reti
                                        (0159) 
                                        (0160)     org   2Ch                      ;PSoC Block DCB03 Interrupt Vector
                                        (0161)     // call	void_handler
002C: 7E       RETI                     (0162)     reti
                                        (0163) 
                                        (0164)     org   30h                      ;PSoC Block DBB10 Interrupt Vector
                                        (0165)     // call	void_handler
0030: 7E       RETI                     (0166)     reti
                                        (0167) 
                                        (0168)     org   34h                      ;PSoC Block DBB11 Interrupt Vector
                                        (0169)     // call	void_handler
0034: 7E       RETI                     (0170)     reti
                                        (0171) 
                                        (0172)     org   38h                      ;PSoC Block DCB12 Interrupt Vector
                                        (0173)     // call	void_handler
0038: 7E       RETI                     (0174)     reti
                                        (0175) 
                                        (0176)     org   3Ch                      ;PSoC Block DCB13 Interrupt Vector
                                        (0177)     // call	void_handler
003C: 7E       RETI                     (0178)     reti
                                        (0179) 
                                        (0180)     org   60h                      ;PSoC I2C Interrupt Vector
0060: 7D 05 EB LJMP  _I2C_ISR           (0181)     ljmp	_I2C_ISR
0063: 7E       RETI                     (0182)     reti
                                        (0183) 
                                        (0184)     org   64h                      ;Sleep Timer Interrupt Vector
0064: 7D 07 4D LJMP  _CYFISNP_SLEEP_ISR (0185)     ljmp	_CYFISNP_SLEEP_ISR
0067: 7E       RETI                     (0186)     reti
0068: 71 10    OR    F,0x10             
                                        (0187)     ;---------------------------------------------------
                                        (0188)     ; Insert your custom code above this banner
                                        (0189)     ;---------------------------------------------------
                                        (0190)     ;@PSoC_BOOT_ISR_UserCode_END@
                                        (0191) 
                                        (0192) ;-----------------------------------------------------------------------------
                                        (0193) ;  Start of Execution.
                                        (0194) ;-----------------------------------------------------------------------------
                                        (0195) ;  The Supervisory ROM SWBootReset function has already completed the
                                        (0196) ;  calibrate1 process, loading trim values for 5 volt operation.
                                        (0197) ;
                                        (0198) 
                                        (0199) IF	(TOOLCHAIN & HITECH)
                                        (0200)  	AREA PD_startup(CODE, REL, CON)
                                        (0201) ELSE
                                        (0202)     org 68h
                                        (0203) ENDIF
                                        (0204) __Start:
                                        (0205) 
                                        (0206)     ; initialize SMP values for voltage stabilization, if required,
                                        (0207)     ; leaving power-on reset (POR) level at the default (low) level, at
                                        (0208)     ; least for now. 
                                        (0209)     ;
                                        (0210)     M8C_SetBank1
006A: 62 E3 80 MOV   REG[0xE3],0x80     (0211)     mov   reg[VLT_CR], SWITCH_MODE_PUMP_JUST | LVD_TBEN_JUST | TRIP_VOLTAGE_JUST
006D: 70 EF    AND   F,0xEF             
006F: 62 E3 38 MOV   REG[0xE3],0x38     
                                        (0212)     M8C_SetBank0
                                        (0213) 
                                        (0214) M8C_ClearWDTAndSleep			   ; Clear WDT before enabling it.
                                        (0215) IF ( WATCHDOG_ENABLE )             ; WDT selected in Global Params
                                        (0216)     M8C_EnableWatchDog
                                        (0217) ENDIF
                                        (0218) 
                                        (0219) IF ( SELECT_32K )
                                        (0220)     or   reg[CPU_SCR1],  CPU_SCR1_ECO_ALLOWED  ; ECO will be used in this project
                                        (0221) ELSE
0072: 41 FE FB AND   REG[0xFE],0xFB     (0222)     and  reg[CPU_SCR1], ~CPU_SCR1_ECO_ALLOWED  ; Prevent ECO from being enabled
                                        (0223) ENDIF
                                        (0224) 
                                        (0225) IF	(TOOLCHAIN & HITECH) 
                                        (0226)     ;---------------------------
                                        (0227)     ; Set up the Temporary stack
                                        (0228)     ;---------------------------
                                        (0229)     ; A temporary stack is set up for the SSC instructions.
                                        (0230)     ; The real stack start will be assigned later.
                                        (0231)     ;
                                        (0232) 	global		__Lstackps
                                        (0233) 	mov     a,low __Lstackps
                                        (0234) 	swap    a,sp
                                        (0235) ELSE
                                        (0236)     ;------------------
                                        (0237)     ; Set up the stack
                                        (0238)     ;------------------
0075: 50 83    MOV   A,0x83             (0239)     mov   A, __ramareas_end        ; Set top of stack to end of used RAM
0077: 4E       SWAP  SP,A               (0240)     swap  SP, A                    ; This is only temporary if going to LMM
0078: 62 E3 38 MOV   REG[0xE3],0x38     
007B: 55 FA 01 MOV   [_ramareas_end+119],0x1
007E: 4F       MOV   X,SP               
007F: 5B       MOV   A,X                
0080: 01 03    ADD   A,0x3              
0082: 53 F9    MOV   [_ramareas_end+118],A
0084: 55 F8 3A MOV   [_ramareas_end+117],0x3A
0087: 50 06    MOV   A,0x6              
0089: 00       SWI                      
008A: 71 10    OR    F,0x10             
008C: 51 F9    MOV   A,[_ramareas_end+118]
008E: 60 E8    MOV   REG[0xE8],A        
0090: 51 F8    MOV   A,[_ramareas_end+117]
0092: 60 EA    MOV   REG[0xEA],A        
0094: 70 EF    AND   F,0xEF             
                                        (0241) ENDIF
                                        (0242) 
                                        (0243)     ;-----------------------------------------------
                                        (0244)     ; Set Power-related Trim & the AGND Bypass bit.
                                        (0245)     ;-----------------------------------------------
                                        (0246) M8C_ClearWDTAndSleep ; Clear WDT before enabling it.
                                        (0247) IF ( SUPPLY_VOLTAGE )         ; 1 means 5.0V
                                        (0248)  IF ( AGND_BYPASS )
                                        (0249)     ;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                        (0250)     ; The 5V trim has already been set, but we need to update the AGNDBYP
                                        (0251)     ; bit in the write-only BDG_TR register. Recalculate the register
                                        (0252)     ; value using the proper trim values.
                                        (0253)     ;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                        (0254)     M8SSC_SetTableVoltageTrim 1, SSCTBL1_TRIM_BGR_5V, AGND_BYPASS_JUST
                                        (0255)  ENDIF
                                        (0256) ELSE    ; 3.3 V Operation, not 5.0V
                                        (0257)     M8SSC_SetTableTrims  1, SSCTBL1_TRIM_IMO_3V_24MHZ, SSCTBL1_TRIM_BGR_3V, AGND_BYPASS_JUST
                                        (0258) ENDIF ;(SUPPLY_VOLTAGE)
                                        (0259) 
0096: 55 F8 00 MOV   [_ramareas_end+117],0x0(0260)     mov  [bSSC_KEY1],  0           ; Lock out Flash and Supervisiory operations
0099: 55 F9 00 MOV   [_ramareas_end+118],0x0(0261)     mov  [bSSC_KEYSP], 0
009C: 71 10    OR    F,0x10             
                                        (0262) 
                                        (0263)     ;---------------------------------------
                                        (0264)     ; Initialize Crystal Oscillator and PLL
                                        (0265)     ;---------------------------------------
                                        (0266) 
                                        (0267) IF ( SELECT_32K & WAIT_FOR_32K )
                                        (0268)     ; If the user has requested the External Crystal Oscillator (ECO) then turn it
                                        (0269)     ; on and wait for it to stabilize and the system to switch over to it. The PLL
                                        (0270)     ; is left off. Set the SleepTimer period is set to 1 sec to time the wait for
                                        (0271)     ; the ECO to stabilize.
                                        (0272)     ;
                                        (0273)     M8C_SetBank1
                                        (0274)     mov   reg[OSC_CR0], (SELECT_32K_JUST | OSC_CR0_SLEEP_1Hz | OSC_CR0_CPU_12MHz)
                                        (0275)     M8C_SetBank0
                                        (0276)     M8C_ClearWDTAndSleep                  ; Reset the sleep timer to get a full second
                                        (0277)     or    reg[INT_MSK0], INT_MSK0_SLEEP   ; Enable latching of SleepTimer interrupt
                                        (0278)     mov   reg[INT_VC],   0                ; Clear all pending interrupts
                                        (0279) .WaitFor1s:
                                        (0280)     tst   reg[INT_CLR0], INT_MSK0_SLEEP   ; Test the SleepTimer Interrupt Status
                                        (0281)     jz   .WaitFor1s                       ; Interrupt will latch but will not dispatch
                                        (0282)                                           ;   since interrupts are not globally enabled
                                        (0283) ELSE ; !( SELECT_32K & WAIT_FOR_32K )
                                        (0284)     ; Either no ECO, or waiting for stable clock is to be done in main
                                        (0285)     M8C_SetBank1
009E: 62 E0 0A MOV   REG[0xE0],0xA      (0286)     mov   reg[OSC_CR0], (SELECT_32K_JUST | PLL_MODE_JUST | SLEEP_TIMER_JUST | OSC_CR0_CPU_12MHz)
00A1: 70 EF    AND   F,0xEF             
00A3: 62 E3 38 MOV   REG[0xE3],0x38     
                                        (0287)     M8C_SetBank0
                                        (0288)     M8C_ClearWDTAndSleep           ; Reset the watch dog
                                        (0289) 
                                        (0290) ENDIF ;( SELECT_32K & WAIT_FOR_32K )
                                        (0291) 
                                        (0292) IF ( PLL_MODE )
                                        (0293)     ; Crystal is now fully operational (assuming WAIT_FOR_32K was enabled).
                                        (0294)     ; Now start up PLL if selected, and wait 16 msec for it to stabilize.
                                        (0295)     ;
                                        (0296)     M8C_SetBank1
                                        (0297)     mov   reg[OSC_CR0], (SELECT_32K_JUST | PLL_MODE_JUST | OSC_CR0_SLEEP_64Hz | OSC_CR0_CPU_3MHz)
                                        (0298)     M8C_SetBank0
                                        (0299)     M8C_ClearWDTAndSleep                  ; Reset the sleep timer to get full period
                                        (0300)     mov   reg[INT_VC], 0                  ; Clear all pending interrupts
                                        (0301) 
                                        (0302) .WaitFor16ms:
                                        (0303)     tst   reg[INT_CLR0],INT_MSK0_SLEEP    ; Test the SleepTimer Interrupt Status
                                        (0304)     jz   .WaitFor16ms
                                        (0305)     M8C_SetBank1                          ; continue boot at CPU Speed of SYSCLK/2
                                        (0306)     mov   reg[OSC_CR0], (SELECT_32K_JUST | PLL_MODE_JUST | OSC_CR0_SLEEP_64Hz | OSC_CR0_CPU_12MHz)
                                        (0307)     M8C_SetBank0
                                        (0308) 
                                        (0309) IF      ( WAIT_FOR_32K )
                                        (0310) ELSE ; !( WAIT_FOR_32K )
                                        (0311)     ; Option settings (PLL-Yes, ECO-No) are incompatible - force a syntax error
                                        (0312)     ERROR_PSoC Disabling WAIT_FOR_32K requires that the PLL_Lock must be enabled in user code.
                                        (0313) ENDIF ;(WAIT_FOR_32K)
                                        (0314) ENDIF ;(PLL_MODE)
                                        (0315) 
                                        (0316) 	;-------------------------------------------------------
                                        (0317)     ; Initialize Proper Drive Mode for External Clock Pin
                                        (0318)     ;-------------------------------------------------------
                                        (0319) 
                                        (0320)     ; Change EXTCLK pin from Hi-Z Analog (110b) drive mode to Hi-Z (010b) drive mode
                                        (0321) 
                                        (0322) IF (SYSCLK_SOURCE)
                                        (0323)     and reg[PRT1DM2],  ~0x10        ; Clear bit 4 of EXTCLK pin's DM2 register 
                                        (0324) ENDIF
                                        (0325)     ; EXTCLK pin is now in proper drive mode to input the external clock signal
                                        (0326) 
                                        (0327)     ;------------------------
                                        (0328)     ; Close CT leakage path.
                                        (0329)     ;------------------------
00A6: 62 71 05 MOV   REG[0x71],0x5      (0330)     mov   reg[ACB00CR0], 05h
00A9: 62 75 05 MOV   REG[0x75],0x5      (0331)     mov   reg[ACB01CR0], 05h
00AC: 62 79 05 MOV   REG[0x79],0x5      (0332)     mov   reg[ACB02CR0], 05h
00AF: 62 7D 05 MOV   REG[0x7D],0x5      (0333)     mov   reg[ACB03CR0], 05h
                                        (0334) 
                                        (0335)     ;@PSoC_BOOT_LOADCFG_UserCode_START@
                                        (0336)     ;---------------------------------------------------
                                        (0337)     ; Insert your custom code below this banner
                                        (0338)     ;---------------------------------------------------
                                        (0339) 
                                        (0340)     ;---------------------------------------------------
                                        (0341)     ; Insert your custom code above this banner
                                        (0342)     ;---------------------------------------------------
                                        (0343)     ;@PSoC_BOOT_LOADCFG_UserCode_END@ 
                                        (0344) 
                                        (0345)     ;-------------------------
                                        (0346)     ; Load Base Configuration
                                        (0347)     ;-------------------------
                                        (0348)     ; Load global parameter settings and load the user modules in the
                                        (0349)     ; base configuration. Exceptions: (1) Leave CPU Speed fast as possible
                                        (0350)     ; to minimize start up time; (2) We may still need to play with the
                                        (0351)     ; Sleep Timer.
                                        (0352)     ;
00B2: 7C 02 9C LCALL 0x029C             (0353)     lcall LoadConfigInit
                                        (0354) 
                                        (0355)     ;-----------------------------------
                                        (0356)     ; Initialize C Run-Time Environment
                                        (0357)     ;-----------------------------------
                                        (0358) IF ( C_LANGUAGE_SUPPORT )
00B5: 50 00    MOV   A,0x0              (0359)     mov  A,0                           ; clear the 'bss' segment to zero
00B7: 55 0F 2A MOV   [__r0],0x2A        (0360)     mov  [__r0],<__bss_start
                                        (0361) BssLoop:
00BA: 3C 0F 83 CMP   [__r0],0x83        (0362)     cmp  [__r0],<__bss_end
00BD: A0 05    JZ    0x00C3             (0363)     jz   BssDone
00BF: 3F 0F    MVI   [__r0],A           (0364)     mvi  [__r0],A
00C1: 8F F8    JMP   0x00BA             (0365)     jmp  BssLoop
                                        (0366) BssDone:
00C3: 50 01    MOV   A,0x1              (0367)     mov  A,>__idata_start              ; copy idata to data segment
00C5: 57 CE    MOV   X,0xCE             (0368)     mov  X,<__idata_start
00C7: 55 0F 00 MOV   [__r0],0x0         (0369)     mov  [__r0],<__data_start
                                        (0370) IDataLoop:
00CA: 3C 0F 09 CMP   [__r0],0x9         (0371)     cmp  [__r0],<__data_end
00CD: A0 0B    JZ    0x00D9             (0372)     jz   C_RTE_Done
00CF: 08       PUSH  A                  (0373)     push A
00D0: 28       ROMX                     (0374)     romx
00D1: 3F 0F    MVI   [__r0],A           (0375)     mvi  [__r0],A
00D3: 18       POP   A                  (0376)     pop  A
00D4: 75       INC   X                  (0377)     inc  X
00D5: 09 00    ADC   A,0x0              (0378)     adc  A,0
00D7: 8F F2    JMP   0x00CA             (0379)     jmp  IDataLoop
00D9: 71 10    OR    F,0x10             
00DB: 70 EF    AND   F,0xEF             
                                        (0380) 
                                        (0381) C_RTE_Done:
                                        (0382) 
                                        (0383) ENDIF ; C_LANGUAGE_SUPPORT
                                        (0384) 
                                        (0385)     ;-------------------------------
                                        (0386)     ; Voltage Stabilization for SMP
                                        (0387)     ;-------------------------------
                                        (0388) 
                                        (0389) IF ( SUPPLY_VOLTAGE )                  ; 1 Means 5 Volts
                                        (0390) IF ( SWITCH_MODE_PUMP ^ 1 )            ; SMP is operational
                                        (0391)     ;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                        (0392)     ; When using the SMP at 5V, we must wait for Vdd to slew from 3.1V to
                                        (0393)     ; 5V before enabling the Precision Power-On Reset (PPOR).
                                        (0394)     ;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                        (0395)     or   reg[INT_MSK0],INT_MSK0_SLEEP
                                        (0396)     M8C_SetBank1
                                        (0397)     and   reg[OSC_CR0], ~OSC_CR0_SLEEP
                                        (0398)     or    reg[OSC_CR0],  OSC_CR0_SLEEP_512Hz
                                        (0399)     M8C_SetBank0
                                        (0400)     M8C_ClearWDTAndSleep                   ; Restart the sleep timer
                                        (0401)     mov   reg[INT_VC], 0                   ; Clear all pending interrupts
                                        (0402) .WaitFor2ms:
                                        (0403)     tst   reg[INT_CLR0], INT_MSK0_SLEEP    ; Test the SleepTimer Interrupt Status
                                        (0404)     jz   .WaitFor2ms                       ; Branch fails when 2 msec has passed
                                        (0405) ENDIF ; ( SWITCH_MODE_PUMP ^ 1 )
                                        (0406) ENDIF ; ( SUPPLY_VOLTAGE )
                                        (0407) 
                                        (0408)     ;-------------------------------
                                        (0409)     ; Set Power-On Reset (POR) Level
                                        (0410)     ;-------------------------------
                                        (0411)     ;  The writes to the VLT_CR register below include setting the POR to VLT_CR_POR_HIGH, 
                                        (0412)     ;  VLT_CR_POR_MID or VLT_CR_POR_LOW. Correctly setting this value is critical to the proper 
                                        (0413)     ;  operation of the PSoC. The POR protects the M8C from mis-executing when Vdd falls low. 
                                        (0414)     ;  These values should not be changed from the settings here. See Section "POR and LVD" of 
                                        (0415)     ;  Technical Reference Manual #001-14463 for more information.
                                        (0416) 
                                        (0417)     M8C_SetBank1
                                        (0418) 
                                        (0419) IF ( SUPPLY_VOLTAGE )                       ; 1 Means 5 Volts
                                        (0420)  IF ( CPU_CLOCK_JUST ^ OSC_CR0_CPU_24MHz )  ;    Also 24MHz?
                                        (0421)                                             ;       no, set 4.5V POR in user code, if desired
                                        (0422)  ELSE ; 24HMz                               ;
                                        (0423)     or    reg[VLT_CR],  VLT_CR_POR_HIGH     ;      yes, highest POR trip point required
                                        (0424)  ENDIF ; OSC_CRO_CPU_24MHz
                                        (0425) ENDIF ; 5V
                                        (0426) 
                                        (0427)     M8C_SetBank0
                                        (0428) 
                                        (0429)     ;----------------------------
                                        (0430)     ; Wrap up and invoke "main"
                                        (0431)     ;----------------------------
                                        (0432) 
                                        (0433)     ; Disable the Sleep interrupt that was used for timing above.  In fact,
                                        (0434)     ; no interrupts should be enabled now, so may as well clear the register.
                                        (0435)     ;
00DD: 62 E0 00 MOV   REG[0xE0],0x0      (0436)     mov  reg[INT_MSK0],0
00E0: 71 10    OR    F,0x10             
                                        (0437) 
                                        (0438)     ; Everything has started OK. Now select requested CPU & sleep frequency.
                                        (0439)     ;
                                        (0440)     M8C_SetBank1
00E2: 62 E0 0A MOV   REG[0xE0],0xA      (0441)     mov  reg[OSC_CR0],(SELECT_32K_JUST | PLL_MODE_JUST | SLEEP_TIMER_JUST | CPU_CLOCK_JUST)
00E5: 70 EF    AND   F,0xEF             
                                        (0442)     M8C_SetBank0
                                        (0443) 
                                        (0444)     ; Global Interrupt are NOT enabled, this should be done in main().
                                        (0445)     ; LVD is set but will not occur unless Global Interrupts are enabled.
                                        (0446)     ; Global Interrupts should be enabled as soon as possible in main().
                                        (0447)     ;
00E7: 62 E2 00 MOV   REG[0xE2],0x0      (0448)     mov  reg[INT_VC],0             ; Clear any pending interrupts which may
                                        (0449)                                    ; have been set during the boot process.
                                        (0450) IF	(TOOLCHAIN & HITECH)
                                        (0451) 	ljmp  startup                  ; Jump to C compiler startup code
                                        (0452) ELSE
                                        (0453) IF ENABLE_LJMP_TO_MAIN
                                        (0454)     ljmp  _main                    ; goto main (no return)
                                        (0455) ELSE
00EA: 7C 0E 07 LCALL __UserModules_end|_main|__text_start|_main(0456)     lcall _main                    ; call main
                                        (0457) .Exit:
00ED: 8F FF    JMP   0x00ED             (0458)     jmp  .Exit                     ; Wait here after return till power-off or reset
                                        (0459) ENDIF
                                        (0460) ENDIF ; TOOLCHAIN
                                        (0461) 
                                        (0462)     ;---------------------------------
                                        (0463)     ; Library Access to Global Parms
                                        (0464)     ;---------------------------------
                                        (0465)     ;
                                        (0466)  bGetPowerSetting:
                                        (0467) _bGetPowerSetting:
                                        (0468)     ; Synthesize the "power setting" value used by chips with SlowIMO mode.
                                        (0469)     ; Returns value of POWER_SETTING in the A register.
                                        (0470)     ; No inputs. No Side Effects.
                                        (0471)     ;
                                        (0472) IF ( SUPPLY_VOLTAGE )            ; 1 means 5.0V
                                        (0473)     mov   A, POWER_SET_5V0_24MHZ   ; Supply & Internal Main Oscillator speed
                                        (0474) ELSE        
00EF: 50 08    MOV   A,0x8              (0475)     mov   A, POWER_SET_3V3_24MHZ   ; Supply & Internal Main Oscillator speed
                                        (0476) ENDIF
00F1: 7F       RET                      (0477)     ret
                                        (0478) 
                                        (0479) IF	(TOOLCHAIN & HITECH)
                                        (0480) ELSE
                                        (0481)     ;---------------------------------
                                        (0482)     ; Order Critical RAM & ROM AREAs
                                        (0483)     ;---------------------------------
                                        (0484)     ;  'TOP' is all that has been defined so far...
                                        (0485) 
                                        (0486)     ;  ROM AREAs for C CONST, static & global items
                                        (0487)     ;
                                        (0488)     AREA lit               (ROM, REL, CON, LIT)   ; 'const' definitions
                                        (0489)     AREA idata             (ROM, REL, CON, LIT)   ; Constants for initializing RAM
                                        (0490) __idata_start:
                                        (0491) 
                                        (0492)     AREA func_lit          (ROM, REL, CON, proclab)   ; Function Pointers
                                        (0493) __func_lit_start:
                                        (0494) 
                                        (0495)     AREA psoc_config       (ROM, REL, CON)   ; Configuration Load & Unload
                                        (0496)     AREA UserModules       (ROM, REL, CON)   ; User Module APIs
                                        (0497) 
                                        (0498)     ; CODE segment for general use
                                        (0499)     ;
                                        (0500)     AREA text (ROM, REL, CON)
                                        (0501) __text_start:
                                        (0502) 
                                        (0503)     ; RAM area usage
                                        (0504)     ;
                                        (0505)     AREA data              (RAM, REL, CON)   ; initialized RAM
                                        (0506) __data_start:
                                        (0507) 
                                        (0508)     AREA virtual_registers (RAM, REL, CON)   ; Temp vars of C compiler
                                        (0509)     AREA InterruptRAM      (RAM, REL, CON)   ; Interrupts, on Page 0
                                        (0510)     AREA bss               (RAM, REL, CON)   ; general use
                                        (0511) __bss_start:
                                        (0512) 
                                        (0513) ENDIF ; TOOLCHAIN
                                        (0514) 
                                        (0515) ; end of file boot.asm
_FlashReadBlock:
    0DE5: 52 02    MOV   A,[X+2]
    0DE7: 53 FB    MOV   [_ramareas_end+120],A
    0DE9: 52 03    MOV   A,[X+3]
    0DEB: 53 FD    MOV   [_ramareas_end+122],A
    0DED: 52 00    MOV   A,[X+0]
    0DEF: 6D       RRC   A
    0DF0: 6D       RRC   A
    0DF1: 6D       RRC   A
    0DF2: 21 C0    AND   A,0xC0
    0DF4: 08       PUSH  A
    0DF5: 52 00    MOV   A,[X+0]
    0DF7: 67       ASR   A
    0DF8: 67       ASR   A
    0DF9: 21 3F    AND   A,0x3F
    0DFB: 20       POP   X
    0DFC: 08       PUSH  A
    0DFD: 28       ROMX  
    0DFE: 3F FB    MVI   [_ramareas_end+120],A
    0E00: 18       POP   A
    0E01: 75       INC   X
    0E02: 7A FD    DEC   [_ramareas_end+122]
    0E04: BF F7    JNZ   0x0DFC
    0E06: 7F       RET   
FILE: D:\Studia\PSOC\RF_I2C_BRIDGE\RF_I2C_BRIDGE\main.c
(0001) //----------------------------------------------------------------------------
(0002) //
(0003) // Main.c - FirstTouch I2C Bridge
(0004) //
(0005) //--------------------------------------------------------------------------
(0006) //
(0007) //--------------------------------------------------------------------------
(0008) //
(0009) // Copyright 2008, Cypress Semiconductor Corporation.
(0010) //
(0011) // This software is owned by Cypress Semiconductor Corporation (Cypress)
(0012) // and is protected by and subject to worldwide patent protection (United
(0013) // States and foreign), United States copyright laws and international
(0014) // treaty provisions. Cypress hereby grants to licensee a personal,
(0015) // non-exclusive, non-transferable license to copy, use, modify, create
(0016) // derivative works of, and compile the Cypress Source Code and derivative
(0017) // works for the sole purpose of creating custom software in support of
(0018) // licensee product to be used only in conjunction with a Cypress integrated
(0019) // circuit as specified in the applicable agreement. Any reproduction,
(0020) // modification, translation, compilation, or representation of this
(0021) // software except as specified above is prohibited without the express
(0022) // written permission of Cypress.
(0023) //
(0024) // Disclaimer: CYPRESS MAKES NO WARRANTY OF ANY KIND,EXPRESS OR IMPLIED,
(0025) // WITH REGARD TO THIS MATERIAL, INCLUDING, BUT NOT LIMITED TO, THE IMPLIED
(0026) // WARRANTIES OF MERCHANTABILITY AND FITNESS FOR A PARTICULAR PURPOSE.
(0027) // Cypress reserves the right to make changes without further notice to the
(0028) // materials described herein. Cypress does not assume any liability arising
(0029) // out of the application or use of any product or circuit described herein.
(0030) // Cypress does not authorize its products for use as critical components in
(0031) // life-support systems where a malfunction or failure may reasonably be
(0032) // expected to result in significant injury to the user. The inclusion of
(0033) // Cypress' product in a life-support systems application implies that the
(0034) // manufacturer assumes all risk of such use and in doing so indemnifies
(0035) // Cypress against all charges.
(0036) //
(0037) // Use may be limited by and subject to the applicable Cypress software
(0038) // license agreement.
(0039) //
(0040) //--------------------------------------------------------------------------
(0041) 
(0042) 
(0043) #include "main.h"
(0044) 
(0045) static void sendNewTxMsg    (void);
(0046) static void loadTxData      (void);
(0047) static void GetI2CData      (void);
(0048) static BOOL CheckBindButton (void);
(0049) static BOOL CheckWakeButton (void);
(0050) static void Calibrate_ILO   (void);
(0051) static void blinkRedLed     (WORD delayCount);
(0052) 
(0053) 
(0054) // ---------------------------------------------------------------------------
(0055) //
(0056) // main() - Powerup entry
(0057) //
(0058) // ---------------------------------------------------------------------------
(0059) void main(void)
(0060) {
__UserModules_end|_main|__text_start|_main:
  pRxApiPkt            --> X+1
  eProtStateOld        --> X+0
    0E07: 10       PUSH  X
    0E08: 4F       MOV   X,SP
    0E09: 38 03    ADD   SP,0x3
(0061)     CYFISNP_PROT_STATE eProtStateOld;
(0062) 
(0063)     LED_RED_OFF;
    0E0B: 41 04 FB AND   REG[0x4],0xFB
(0064)     LED_GRN_ON;
    0E0E: 43 04 08 OR    REG[0x4],0x8
(0065) 
(0066)     M8C_EnableGInt;
    0E11: 71 01    OR    F,0x1
(0067) 
(0068) #if (defined DEBUG) || (defined CYFISNP_DEBUG)
(0069)     TX8_Start(TX8_PARITY_NONE);
(0070) #endif
(0071) 
(0072)     CYFISNP_Start();
    0E13: 10       PUSH  X
    0E14: 7C 12 5E LCALL _CYFISNP_Start
(0073)     // --------------------------------------------------------
(0074)     // Disable SNP_Radio Power Management Unit (saves about 32uA)
(0075)     // --------------------------------------------------------
(0076)     CYFISNP_Write(CYFISNP_PWR_CTRL_ADR,
    0E17: 50 0B    MOV   A,0xB
    0E19: 7C 0A 09 LCALL _CYFISNP_Read
    0E1C: 20       POP   X
    0E1D: 21 7F    AND   A,0x7F
    0E1F: 29 20    OR    A,0x20
    0E21: 10       PUSH  X
    0E22: 08       PUSH  A
    0E23: 50 0B    MOV   A,0xB
    0E25: 20       POP   X
    0E26: 7C 0A 07 LCALL _CYFISNP_Write
    0E29: 20       POP   X
(0077)                   (CYFISNP_Read(CYFISNP_PWR_CTRL_ADR) & ~CYFISNP_PMU_EN) | CYFISNP_PMU_MODE_FORCE);
(0078) 
(0079)     LED_GRN_OFF;
    0E2A: 41 04 F7 AND   REG[0x4],0xF7
(0080) 
(0081)     CYFISNP_TimeSet(&oneSecTimer, sleepTicksPerSec);
    0E2D: 51 06    MOV   A,[sleepTicksPerSec]
    0E2F: 08       PUSH  A
    0E30: 51 07    MOV   A,[sleepTicksPerSec+1]
    0E32: 08       PUSH  A
    0E33: 50 00    MOV   A,0x0
    0E35: 08       PUSH  A
    0E36: 50 32    MOV   A,0x32
    0E38: 08       PUSH  A
    0E39: 7C 11 C7 LCALL _CYFISNP_TimeSet
    0E3C: 38 FC    ADD   SP,0xFC
(0082) 
(0083)     I2C_Start();
    0E3E: 10       PUSH  X
    0E3F: 7C 03 43 LCALL _I2C_Start
(0084)     I2C_EnableMstr();
    0E42: 7C 03 51 LCALL _I2C_EnableMstr
(0085)     I2C_EnableInt();
    0E45: 7C 03 46 LCALL _I2C_EnableInt
    0E48: 20       POP   X
(0086) 
(0087)     // -----------------------------------------------------------------------
(0088)     // POLLING LOOP
(0089)     // -----------------------------------------------------------------------
(0090)     for (;;)
(0091)     {
(0092)         // -------------------------------------------------------------------
(0093)         // Watch Start Binding Button activity
(0094)         // -------------------------------------------------------------------
(0095)         if (CheckBindButton())
    0E49: 92 12    CALL  main.c:CheckBindButton
    0E4B: 39 00    CMP   A,0x0
    0E4D: A0 0C    JZ    0x0E5A
(0096)         {
(0097)             CYFISNP_BindStart(ON_THE_FLY_DEV_ID);
    0E4F: 50 00    MOV   A,0x0
    0E51: 08       PUSH  A
    0E52: 7C 13 3A LCALL _CYFISNP_BindStart
    0E55: 38 FF    ADD   SP,0xFF
(0098)             LED_GRN_ON;
    0E57: 43 04 08 OR    REG[0x4],0x8
(0099)         }
(0100) 
(0101)         // -------------------------------------------------------------------
(0102)         // Watch "Force New Report" button
(0103)         // -------------------------------------------------------------------
(0104)         if (CheckWakeButton())
    0E5A: 92 E2    CALL  main.c:CheckWakeButton
    0E5C: 39 00    CMP   A,0x0
    0E5E: A0 03    JZ    0x0E62
(0105)         {
(0106)             sendNewTxMsg();
    0E60: 90 FF    CALL  main.c:sendNewTxMsg
(0107)         }
(0108) 
(0109)         // -------------------------------------------------------------------
(0110)         // Run SNP less frequently to save energy
(0111)         // -------------------------------------------------------------------
(0112)         if (--snpRunScaler == 0)
    0E62: 16 46 01 SUB   [main.h:snpRunScaler],0x1
    0E65: 3C 46 00 CMP   [main.h:snpRunScaler],0x0
    0E68: B0 07    JNZ   0x0E70
(0113)         {
(0114)             snpRunScaler = SNP_RUN_SCALER;
    0E6A: 55 46 02 MOV   [main.h:snpRunScaler],0x2
(0115)             CYFISNP_Run();          // Poll SNP machine
    0E6D: 7C 12 E2 LCALL _CYFISNP_Run
(0116)         }
(0117) 
(0118)         // -------------------------------------------------------------------
(0119)         // Process received SNP data packets
(0120)         //  (only supports update report rate for now)
(0121)         // -------------------------------------------------------------------
(0122)         if (CYFISNP_RxDataPend() == TRUE)
    0E70: 7C 1A 3B LCALL _CYFISNP_RxDataPend
    0E73: 39 01    CMP   A,0x1
    0E75: B0 1C    JNZ   0x0E92
(0123)         {
(0124)             CYFISNP_API_PKT *pRxApiPkt;
(0125)             pRxApiPkt = CYFISNP_RxDataGet();
    0E77: 7C 1A 3E LCALL _CYFISNP_RxDataGet
    0E7A: 51 0E    MOV   A,[__r1]
    0E7C: 54 02    MOV   [X+2],A
    0E7E: 51 0F    MOV   A,[__r0]
    0E80: 54 01    MOV   [X+1],A
(0126)             reportTimeSec = pRxApiPkt->payload[0];    // Update report rate
    0E82: 52 02    MOV   A,[X+2]
    0E84: 01 04    ADD   A,0x4
    0E86: 53 0E    MOV   [__r1],A
    0E88: 3E 0E    MVI   A,[__r1]
    0E8A: 53 03    MOV   [reportTimeSec+1],A
    0E8C: 55 02 00 MOV   [reportTimeSec],0x0
(0127)             CYFISNP_RxDataRelease();
    0E8F: 7C 1A 45 LCALL _CYFISNP_RxDataRelease
(0128)         }
(0129) 
(0130)         // -------------------------------------------------------------------
(0131)         // Periodic 1 sec events
(0132)         // -------------------------------------------------------------------
(0133)         if (CYFISNP_TimeExpired(&oneSecTimer) == TRUE)
    0E92: 50 00    MOV   A,0x0
    0E94: 08       PUSH  A
    0E95: 50 32    MOV   A,0x32
    0E97: 08       PUSH  A
    0E98: 7C 11 F5 LCALL _CYFISNP_TimeExpired
    0E9B: 38 FE    ADD   SP,0xFE
    0E9D: 39 01    CMP   A,0x1
    0E9F: B0 66    JNZ   0x0F06
(0134)         {
(0135)             CYFISNP_TimeSet(&oneSecTimer, sleepTicksPerSec);
    0EA1: 51 06    MOV   A,[sleepTicksPerSec]
    0EA3: 08       PUSH  A
    0EA4: 51 07    MOV   A,[sleepTicksPerSec+1]
    0EA6: 08       PUSH  A
    0EA7: 50 00    MOV   A,0x0
    0EA9: 08       PUSH  A
    0EAA: 50 32    MOV   A,0x32
    0EAC: 08       PUSH  A
    0EAD: 7C 11 C7 LCALL _CYFISNP_TimeSet
    0EB0: 38 FC    ADD   SP,0xFC
(0136) 
(0137)             // ---------------------------------------------------------------
(0138)             // Blink Heartbeat LED
(0139)             // ---------------------------------------------------------------
(0140)             if (--ledHeartbeatSec == 0)
    0EB2: 51 01    MOV   A,[ledHeartbeatSec+1]
    0EB4: 11 01    SUB   A,0x1
    0EB6: 53 0E    MOV   [__r1],A
    0EB8: 51 00    MOV   A,[ledHeartbeatSec]
    0EBA: 19 00    SBB   A,0x0
    0EBC: 5F 01 0E MOV   [ledHeartbeatSec+1],[__r1]
    0EBF: 53 00    MOV   [ledHeartbeatSec],A
    0EC1: 3C 00 00 CMP   [ledHeartbeatSec],0x0
    0EC4: B0 18    JNZ   0x0EDD
    0EC6: 3C 0E 00 CMP   [__r1],0x0
    0EC9: B0 13    JNZ   0x0EDD
(0141)             {
(0142)                 ledHeartbeatSec = LED_HEARTBEAT_SEC;
    0ECB: 55 01 05 MOV   [ledHeartbeatSec+1],0x5
    0ECE: 55 00 00 MOV   [ledHeartbeatSec],0x0
(0143)                 blinkRedLed(50);           // *100 uS ON
    0ED1: 50 00    MOV   A,0x0
    0ED3: 08       PUSH  A
    0ED4: 50 32    MOV   A,0x32
    0ED6: 08       PUSH  A
    0ED7: 90 42    CALL  main.c:blinkRedLed
    0ED9: 38 FE    ADD   SP,0xFE
(0144)                 Calibrate_ILO();        // Calibrate ILO against IMO
    0EDB: 91 01    CALL  main.c:Calibrate_ILO
(0145)             }
(0146) 
(0147)             // ---------------------------------------------------------------
(0148)             // If SNP reconnect timeout, then try to reconnect.
(0149)             //    (If very power sensitive, may want to defer for 5 minutes)
(0150)             // ---------------------------------------------------------------
(0151)             if (CYFISNP_eProtState == CYFISNP_CON_MODE_TIMEOUT)
    0EDD: 3C 82 21 CMP   [CYFISNP_eProtState],0x21
    0EE0: B0 04    JNZ   0x0EE5
(0152)             {
(0153)                 CYFISNP_Jog();
    0EE2: 7C 12 C2 LCALL _CYFISNP_Jog
(0154)             }
(0155) 
(0156)             // ---------------------------------------------------------------
(0157)             // Periodic weather station report
(0158)             // ---------------------------------------------------------------
(0159)             if (--reportTimerSec == 0)
    0EE5: 51 05    MOV   A,[reportTimerSec+1]
    0EE7: 11 01    SUB   A,0x1
    0EE9: 53 0E    MOV   [__r1],A
    0EEB: 51 04    MOV   A,[reportTimerSec]
    0EED: 19 00    SBB   A,0x0
    0EEF: 5F 05 0E MOV   [reportTimerSec+1],[__r1]
    0EF2: 53 04    MOV   [reportTimerSec],A
    0EF4: 3C 04 00 CMP   [reportTimerSec],0x0
    0EF7: B0 0E    JNZ   0x0F06
    0EF9: 3C 0E 00 CMP   [__r1],0x0
    0EFC: B0 09    JNZ   0x0F06
(0160)             {
(0161)                 reportTimerSec = reportTimeSec;
    0EFE: 5F 05 03 MOV   [reportTimerSec+1],[reportTimeSec+1]
    0F01: 5F 04 02 MOV   [reportTimerSec],[reportTimeSec]
(0162)                 sendNewTxMsg();
    0F04: 90 5B    CALL  main.c:sendNewTxMsg
(0163)             }
(0164)         }
(0165) 
(0166)         // -------------------------------------------------------------------
(0167)         // Sleep PSoC until next Sleep Timer interrupt to conserve energy
(0168)         // -------------------------------------------------------------------
(0169) #if LOW_POWER_TEST
(0170)         M8C_Sleep;
    0F06: 43 FF 08 OR    REG[0xFF],0x8
(0171) #endif
(0172) 
(0173)         // -------------------------------------------------------------------
(0174)         // Turn OFF Green LED when not in Bind Mode
(0175)         // -------------------------------------------------------------------
(0176)         if (CYFISNP_eProtState != CYFISNP_BIND_MODE)
    0F09: 3C 82 10 CMP   [CYFISNP_eProtState],0x10
    0F0C: A0 04    JZ    0x0F11
(0177)         {
(0178)             LED_GRN_OFF;
    0F0E: 41 04 F7 AND   REG[0x4],0xF7
(0179)         }
(0180)         LED_RED_OFF;        // RED LED always goes OFF
    0F11: 41 04 FB AND   REG[0x4],0xFB
(0181)     }
    0F14: 8F 34    JMP   0x0E49
    0F16: 38 FD    ADD   SP,0xFD
    0F18: 20       POP   X
    0F19: 8F FF    JMP   0x0F19
(0182) }
(0183) 
(0184) static void blinkRedLed(WORD delayCount)
(0185) {
main.c:blinkRedLed:
  delayCount           --> X-5
    0F1B: 10       PUSH  X
    0F1C: 4F       MOV   X,SP
(0186)     LED_RED_ON;
    0F1D: 43 04 04 OR    REG[0x4],0x4
    0F20: 80 0B    JMP   0x0F2C
(0187)     while (delayCount != 0)
(0188)     {
(0189)         CYFISNP_Delay100uS();       // Get good short delays
    0F22: 10       PUSH  X
    0F23: 7C 07 55 LCALL _CYFISNP_Delay100uS
    0F26: 20       POP   X
(0190)         --delayCount;
    0F27: 7B FC    DEC   [X-4]
    0F29: 1F FB 00 SBB   [X-5],0x0
(0191)     }
    0F2C: 3D FB 00 CMP   [X-5],0x0
    0F2F: BF F2    JNZ   0x0F22
    0F31: 3D FC 00 CMP   [X-4],0x0
    0F34: BF ED    JNZ   0x0F22
(0192)     LED_RED_OFF;
    0F36: 41 04 FB AND   REG[0x4],0xFB
    0F39: 20       POP   X
    0F3A: 7F       RET   
(0193) }
(0194) 
(0195) 
(0196) // ---------------------------------------------------------------------------
(0197) //
(0198) // loadTxData()
(0199) //
(0200) // ---------------------------------------------------------------------------
(0201) static void loadTxData(void)
(0202) {
main.c:loadTxData:
  ivar                 --> X+0
    0F3B: 10       PUSH  X
    0F3C: 4F       MOV   X,SP
    0F3D: 10       PUSH  X
(0203)     char ivar;
(0204) 
(0205)     for (ivar=0; ivar < I2C_PAYLOAD_MAX; ++ivar)
    0F3E: 56 00 00 MOV   [X+0],0x0
    0F41: 80 17    JMP   0x0F59
(0206)     {
(0207)         txApiPkt.payload[ivar] = rxBuffer[ivar];
    0F43: 52 00    MOV   A,[X+0]
    0F45: 01 2A    ADD   A,0x2A
    0F47: 53 0E    MOV   [__r1],A
    0F49: 3E 0E    MVI   A,[__r1]
    0F4B: 53 0F    MOV   [__r0],A
    0F4D: 52 00    MOV   A,[X+0]
    0F4F: 01 38    ADD   A,0x38
    0F51: 53 0C    MOV   [__r3],A
    0F53: 51 0F    MOV   A,[__r0]
    0F55: 3F 0C    MVI   [__r3],A
(0208)     }
    0F57: 77 00    INC   [X+0]
    0F59: 3D 00 08 CMP   [X+0],0x8
    0F5C: CF E6    JC    0x0F43
    0F5E: 20       POP   X
    0F5F: 20       POP   X
    0F60: 7F       RET   
(0209) }
(0210) 
(0211) // ---------------------------------------------------------------------------
(0212) //
(0213) // sendNewTxMsg() - Send a weather station report to the HUB
(0214) //
(0215) // ---------------------------------------------------------------------------
(0216) #define TX_PACKET_LENGTH    8
(0217) #define TX_PACKET_TYPE      CYFISNP_API_TYPE_CONF
(0218) static void sendNewTxMsg(void)
(0219) {
(0220)     if (CYFISNP_eProtState == CYFISNP_DATA_MODE
main.c:sendNewTxMsg:
    0F61: 3C 82 40 CMP   [CYFISNP_eProtState],0x40
    0F64: B0 20    JNZ   0x0F85
    0F66: 7C 16 C4 LCALL _CYFISNP_TxDataPend
    0F69: 39 00    CMP   A,0x0
    0F6B: B0 19    JNZ   0x0F85
(0221)         && CYFISNP_TxDataPend() == FALSE)
(0222)     {
(0223)         GetI2CData();
    0F6D: 90 17    CALL  main.c:GetI2CData
(0224) 
(0225)         loadTxData();
    0F6F: 9F CA    CALL  main.c:loadTxData
(0226)         txApiPkt.length = TX_PACKET_LENGTH;
    0F71: 55 34 08 MOV   [main.h:txApiPkt],0x8
(0227)         txApiPkt.type   = TX_PACKET_TYPE;
    0F74: 55 36 10 MOV   [main.h:txApiPkt+2],0x10
(0228)         CYFISNP_TxDataPut(&txApiPkt);
    0F77: 50 00    MOV   A,0x0
    0F79: 08       PUSH  A
    0F7A: 50 34    MOV   A,0x34
    0F7C: 08       PUSH  A
    0F7D: 7C 16 D0 LCALL _CYFISNP_TxDataPut
    0F80: 38 FE    ADD   SP,0xFE
(0229)         LED_GRN_ON;
    0F82: 43 04 08 OR    REG[0x4],0x8
(0230)     }
    0F85: 7F       RET   
(0231) }
(0232) 
(0233) 
(0234) 
(0235) // ---------------------------------------------------------------------------
(0236) //
(0237) // GetI2CData() - Get data from I2C device on P1 (weather station board)
(0238) //
(0239) // ---------------------------------------------------------------------------
(0240) static void GetI2CData(void)
(0241) {
main.c:GetI2CData:
  dataDelay            --> X+0
    0F86: 10       PUSH  X
    0F87: 4F       MOV   X,SP
    0F88: 38 02    ADD   SP,0x2
(0242)     WORD dataDelay;
(0243) 
(0244)     // Delay (with timeout), for weather station to be ready.
(0245)     ChipSelect_ON;
    0F8A: 43 00 04 OR    REG[0x0],0x4
(0246)     CYFISNP_TimeSet(&dataDelay, DATA_READY_TIME);
    0F8D: 50 00    MOV   A,0x0
    0F8F: 08       PUSH  A
    0F90: 50 12    MOV   A,0x12
    0F92: 08       PUSH  A
    0F93: 51 0F    MOV   A,[__r0]
    0F95: 08       PUSH  A
    0F96: 10       PUSH  X
    0F97: 7C 11 C7 LCALL _CYFISNP_TimeSet
    0F9A: 38 FC    ADD   SP,0xFC
(0247)     while (!CYFISNP_TimeExpired(&dataDelay) && !IS_DataReady_ON);
    0F9C: 51 0F    MOV   A,[__r0]
    0F9E: 08       PUSH  A
    0F9F: 10       PUSH  X
    0FA0: 7C 11 F5 LCALL _CYFISNP_TimeExpired
    0FA3: 38 FE    ADD   SP,0xFE
    0FA5: 53 0F    MOV   [__r0],A
    0FA7: 39 00    CMP   A,0x0
    0FA9: B0 06    JNZ   0x0FB0
    0FAB: 49 00 08 TST   REG[0x0],0x8
    0FAE: AF ED    JZ    0x0F9C
(0248) 
(0249)     // Start the I2C read
(0250)     I2C_fReadBytes(SLAVE_ADDRESS, rxBuffer, 8, I2C_CompleteXfer);
    0FB0: 10       PUSH  X
    0FB1: 50 00    MOV   A,0x0
    0FB3: 08       PUSH  A
    0FB4: 50 08    MOV   A,0x8
    0FB6: 08       PUSH  A
    0FB7: 50 00    MOV   A,0x0
    0FB9: 08       PUSH  A
    0FBA: 50 2A    MOV   A,0x2A
    0FBC: 08       PUSH  A
    0FBD: 50 05    MOV   A,0x5
    0FBF: 08       PUSH  A
    0FC0: 7C 03 63 LCALL _I2C_fReadBytes
    0FC3: 38 FB    ADD   SP,0xFB
    0FC5: 20       POP   X
(0251) 
(0252)     // Wait for I2C to complete
(0253)     while ((I2C_bReadI2CStatus()&I2CHW_RD_COMPLETE) == FALSE)
(0254)         ;
    0FC6: 10       PUSH  X
    0FC7: 7C 07 35 LCALL _I2C_bReadI2CStatus
    0FCA: 20       POP   X
    0FCB: 53 0F    MOV   [__r0],A
    0FCD: 47 0F 04 TST   [__r0],0x4
    0FD0: AF F5    JZ    0x0FC6
(0255) 
(0256)     I2C_ClrRdStatus();
    0FD2: 10       PUSH  X
    0FD3: 7C 07 38 LCALL _I2C_ClrRdStatus
    0FD6: 20       POP   X
(0257) 
(0258)     ChipSelect_OFF;
    0FD7: 41 00 FB AND   REG[0x0],0xFB
    0FDA: 38 FE    ADD   SP,0xFE
    0FDC: 20       POP   X
    0FDD: 7F       RET   
(0259) }
(0260) 
(0261) 
(0262) // ---------------------------------------------------------------------------
(0263) //
(0264) // Calibrate_ILO() - Calibrate Int Low Freq Osc against the Int Main Osc
(0265) //
(0266) // ---------------------------------------------------------------------------
(0267) static void Calibrate_ILO(void)
(0268) {
main.c:Calibrate_ILO:
  bCount               --> X+0
    0FDE: 10       PUSH  X
    0FDF: 4F       MOV   X,SP
    0FE0: 38 02    ADD   SP,0x2
(0269)     WORD bCount;
(0270) 
(0271)     // -----------------------------------------------------------------------
(0272)     // Get number of ILO ticks in 1 mS (as measured by IMO)
(0273)     // -----------------------------------------------------------------------
(0274)     Timer8_WritePeriod(255);
    0FE2: 10       PUSH  X
    0FE3: 50 FF    MOV   A,0xFF
    0FE5: 7C 03 0E LCALL _Timer8_WritePeriod
    0FE8: 20       POP   X
(0275)     M8C_DisableGInt;
    0FE9: 70 FE    AND   F,0xFE
(0276)     Timer8_Start();
    0FEB: 10       PUSH  X
    0FEC: 7C 03 06 LCALL _Timer8_Start
    0FEF: 20       POP   X
(0277)     for (bCount=0; bCount != 10; ++bCount)
    0FF0: 56 01 00 MOV   [X+1],0x0
    0FF3: 56 00 00 MOV   [X+0],0x0
    0FF6: 80 0B    JMP   0x1002
(0278)     {
(0279)         CYFISNP_Delay100uS();
    0FF8: 10       PUSH  X
    0FF9: 7C 07 55 LCALL _CYFISNP_Delay100uS
    0FFC: 20       POP   X
(0280)     }
    0FFD: 77 01    INC   [X+1]
    0FFF: 0F 00 00 ADC   [X+0],0x0
    1002: 3D 00 00 CMP   [X+0],0x0
    1005: BF F2    JNZ   0x0FF8
    1007: 3D 01 0A CMP   [X+1],0xA
    100A: BF ED    JNZ   0x0FF8
(0281)     bCount = Timer8_bReadTimer();
    100C: 10       PUSH  X
    100D: 7C 03 3E LCALL _bTimer8_CaptureCounter|_bTimer8_ReadTimer|_Timer8_bReadTimer|Timer8_bReadTimer|bTimer8_ReadTimer
    1010: 20       POP   X
    1011: 54 01    MOV   [X+1],A
    1013: 56 00 00 MOV   [X+0],0x0
(0282)     bCount = 255 - bCount;
    1016: 50 FF    MOV   A,0xFF
    1018: 13 01    SUB   A,[X+1]
    101A: 54 01    MOV   [X+1],A
    101C: 50 00    MOV   A,0x0
    101E: 1B 00    SBB   A,[X+0]
    1020: 54 00    MOV   [X+0],A
(0283)     Timer8_Stop();
    1022: 10       PUSH  X
    1023: 7C 03 0A LCALL _Timer8_Stop
    1026: 20       POP   X
(0284)     M8C_EnableGInt;
    1027: 71 01    OR    F,0x1
(0285) 
(0286)     sleepTicksPerSec = bCount<<1;   // Start by assuming ILO(wake) = ILO(sleep)
    1029: 52 01    MOV   A,[X+1]
    102B: 53 0E    MOV   [__r1],A
    102D: 52 00    MOV   A,[X+0]
    102F: 53 0F    MOV   [__r0],A
    1031: 65 0E    ASL   [__r1]
    1033: 6B 0F    RLC   [__r0]
    1035: 5F 07 0E MOV   [sleepTicksPerSec+1],[__r1]
    1038: 5F 06 0F MOV   [sleepTicksPerSec],[__r0]
(0287) 
(0288)     // -----------------------------------------------------------------------
(0289)     // Without ILO in HighBias mode (See ILO_TR register in TRM), the ILO
(0290)     //  operates FASTER awake than asleep.
(0291)     // Therefore approximate ILO(sleep) as 25% lower than ILO(wake).
(0292)     // -----------------------------------------------------------------------
(0293)     sleepTicksPerSec -= bCount>>1;  // Decrease by 25% to estimate ILO(sleep)
    103B: 52 01    MOV   A,[X+1]
    103D: 53 0E    MOV   [__r1],A
    103F: 52 00    MOV   A,[X+0]
    1041: 53 0F    MOV   [__r0],A
    1043: 70 FB    AND   F,0xFB
    1045: 6E 0F    RRC   [__r0]
    1047: 6E 0E    RRC   [__r1]
    1049: 51 0E    MOV   A,[__r1]
    104B: 14 07    SUB   [sleepTicksPerSec+1],A
    104D: 51 0F    MOV   A,[__r0]
    104F: 1C 06    SBB   [sleepTicksPerSec],A
    1051: 38 FE    ADD   SP,0xFE
    1053: 20       POP   X
    1054: 7F       RET   
(0294) }
(0295) 
(0296) 
(0297) 
(0298) // ---------------------------------------------------------------------------
(0299) //
(0300) // bindButtonIsOn()
(0301) //
(0302) // ---------------------------------------------------------------------------
(0303) static BOOL bindButtonIsOn(void)
(0304) {
(0305)     SW1_Data_ADDR &= ~SW1_MASK;                  // Ensure GPIO pulldown active
main.c:bindButtonIsOn:
    1055: 41 04 BF AND   REG[0x4],0xBF
(0306)     return(SW1_Data_ADDR & SW1_MASK);
    1058: 5D 04    MOV   A,REG[0x4]
    105A: 21 40    AND   A,0x40
    105C: 7F       RET   
(0307) }
(0308) 
(0309) // ---------------------------------------------------------------------------
(0310) //
(0311) // CheckBindButton()
(0312) //
(0313) // ---------------------------------------------------------------------------
(0314) static BOOL CheckBindButton(void)
(0315) {
main.c:CheckBindButton:
  lvDelay              --> X+0
    105D: 10       PUSH  X
    105E: 4F       MOV   X,SP
    105F: 38 02    ADD   SP,0x2
(0316)     WORD lvDelay;
(0317)     if (bindButtonIsOn())
    1061: 9F F2    CALL  main.c:bindButtonIsOn
    1063: 53 0F    MOV   [__r0],A
    1065: 39 00    CMP   A,0x0
    1067: A0 37    JZ    0x109F
(0318)     {
(0319)         CYFISNP_TimeSet(&lvDelay, DEBOUNCE_TIME);       // Debouncing, delay
    1069: 50 00    MOV   A,0x0
    106B: 08       PUSH  A
    106C: 50 02    MOV   A,0x2
    106E: 08       PUSH  A
    106F: 51 0F    MOV   A,[__r0]
    1071: 08       PUSH  A
    1072: 10       PUSH  X
    1073: 7C 11 C7 LCALL _CYFISNP_TimeSet
    1076: 38 FC    ADD   SP,0xFC
(0320)         while (CYFISNP_TimeExpired(&lvDelay) == 0) ;    // WAIT
    1078: 51 0F    MOV   A,[__r0]
    107A: 08       PUSH  A
    107B: 10       PUSH  X
    107C: 7C 11 F5 LCALL _CYFISNP_TimeExpired
    107F: 38 FE    ADD   SP,0xFE
    1081: 39 00    CMP   A,0x0
    1083: AF F4    JZ    0x1078
(0321)         if (bindButtonIsOn())           // If button still ON
    1085: 9F CE    CALL  main.c:bindButtonIsOn
    1087: 53 0F    MOV   [__r0],A
    1089: 39 00    CMP   A,0x0
    108B: A0 13    JZ    0x109F
(0322)         {
(0323)             while (bindButtonIsOn())    // Wait for button release
    108D: 80 07    JMP   0x1095
(0324)             {
(0325)                 M8C_ClearWDTAndSleep;
    108F: 62 E3 38 MOV   REG[0xE3],0x38
(0326) #if LOW_POWER_TEST
(0327)                 M8C_Sleep;
    1092: 43 FF 08 OR    REG[0xFF],0x8
(0328) #endif
(0329)             }
    1095: 9F BE    CALL  main.c:bindButtonIsOn
    1097: 39 00    CMP   A,0x0
    1099: BF F5    JNZ   0x108F
(0330)             return(TRUE);
    109B: 50 01    MOV   A,0x1
    109D: 80 03    JMP   0x10A1
(0331)         }
(0332)     }
(0333)     return(FALSE);
    109F: 50 00    MOV   A,0x0
    10A1: 38 FE    ADD   SP,0xFE
    10A3: 20       POP   X
    10A4: 7F       RET   
(0334) }
(0335) 
(0336) 
(0337) // ---------------------------------------------------------------------------
(0338) //
(0339) // buttonIncReportTime() - Manually step report interval
(0340) //
(0341) // ---------------------------------------------------------------------------
(0342) static const WORD reportTimes[] = {1, 5, 30, 60, 300};  // in Seconds
(0343) static char       reportTimesIdx = 1;                   // Start at 5 sec
(0344) #define REPORT_TIMES_MAX   (sizeof(reportTimes)/2)      // # entries
(0345) 
(0346) static void buttonIncReportTime(void)
(0347) {
(0348)     if (++reportTimesIdx >= REPORT_TIMES_MAX)
main.c:buttonIncReportTime:
    10A5: 06 08 01 ADD   [main.c:reportTimesIdx],0x1
    10A8: 3C 08 05 CMP   [main.c:reportTimesIdx],0x5
    10AB: C0 04    JC    0x10B0
(0349)     {
(0350)         reportTimesIdx = 0;
    10AD: 55 08 00 MOV   [main.c:reportTimesIdx],0x0
(0351)     }
(0352)     reportTimeSec = reportTimes[reportTimesIdx];
    10B0: 5F 0E 08 MOV   [__r1],[main.c:reportTimesIdx]
    10B3: 55 0F 00 MOV   [__r0],0x0
    10B6: 65 0E    ASL   [__r1]
    10B8: 6B 0F    RLC   [__r0]
    10BA: 06 0E 50 ADD   [__r1],0x50
    10BD: 0E 0F 01 ADC   [__r0],0x1
    10C0: 51 0F    MOV   A,[__r0]
    10C2: 10       PUSH  X
    10C3: 58 0E    MOV   X,[__r1]
    10C5: 7C 20 55 LCALL __lpmw
    10C8: 53 03    MOV   [reportTimeSec+1],A
    10CA: 5F 02 0B MOV   [reportTimeSec],[__rX]
    10CD: 20       POP   X
(0353)     reportTimerSec = reportTimeSec;
    10CE: 5F 05 03 MOV   [reportTimerSec+1],[reportTimeSec+1]
    10D1: 5F 04 02 MOV   [reportTimerSec],[reportTimeSec]
    10D4: 7F       RET   
(0354) }
(0355) 
(0356) // ---------------------------------------------------------------------------
(0357) //
(0358) //  showReportDelay() - Pulse LED to show INDEX of new report delay
(0359) //
(0360) // ---------------------------------------------------------------------------
(0361) static void showReportDelay(void)
(0362) {
main.c:showReportDelay:
  pulseCt              --> X+1
  wait                 --> X+0
    10D5: 10       PUSH  X
    10D6: 4F       MOV   X,SP
    10D7: 38 02    ADD   SP,0x2
(0363) #define HI_LO_PULSE   10    // Hi or Lo pulse width (in Sleep intervals)
(0364)     char pulseCt = reportTimesIdx + 1;  // 1st entry [0] gives 1 pulse
    10D9: 51 08    MOV   A,[main.c:reportTimesIdx]
    10DB: 01 01    ADD   A,0x1
    10DD: 54 01    MOV   [X+1],A
(0365)     char wait;
(0366) 
(0367)     LED_RED_OFF;
    10DF: 41 04 FB AND   REG[0x4],0xFB
(0368)     for (wait=HI_LO_PULSE; wait != 0; --wait)
    10E2: 56 00 0A MOV   [X+0],0xA
    10E5: 80 06    JMP   0x10EC
(0369)     {
(0370) #if LOW_POWER_TEST
(0371)         M8C_Sleep;
    10E7: 43 FF 08 OR    REG[0xFF],0x8
(0372) #endif
(0373)     }
    10EA: 7B 00    DEC   [X+0]
    10EC: 3D 00 00 CMP   [X+0],0x0
    10EF: BF F7    JNZ   0x10E7
    10F1: 80 25    JMP   0x1117
(0374) 
(0375)     while (pulseCt-- != 0)
(0376)     {
(0377)         LED_RED_ON;
    10F3: 43 04 04 OR    REG[0x4],0x4
(0378)         for (wait=HI_LO_PULSE; wait != 0; --wait)
    10F6: 56 00 0A MOV   [X+0],0xA
    10F9: 80 06    JMP   0x1100
(0379)         {
(0380) #if LOW_POWER_TEST
(0381)             M8C_Sleep;
    10FB: 43 FF 08 OR    REG[0xFF],0x8
(0382) #endif
(0383)         }
    10FE: 7B 00    DEC   [X+0]
    1100: 3D 00 00 CMP   [X+0],0x0
    1103: BF F7    JNZ   0x10FB
(0384)         LED_RED_OFF;
    1105: 41 04 FB AND   REG[0x4],0xFB
(0385)         for (wait=HI_LO_PULSE; wait != 0; --wait)
    1108: 56 00 0A MOV   [X+0],0xA
    110B: 80 06    JMP   0x1112
(0386)         {
(0387) #if LOW_POWER_TEST
(0388)             M8C_Sleep;
    110D: 43 FF 08 OR    REG[0xFF],0x8
(0389) #endif
(0390)         }
    1110: 7B 00    DEC   [X+0]
    1112: 3D 00 00 CMP   [X+0],0x0
    1115: BF F7    JNZ   0x110D
(0391)     }
    1117: 52 01    MOV   A,[X+1]
    1119: 53 0E    MOV   [__r1],A
    111B: 55 0F 00 MOV   [__r0],0x0
    111E: 11 01    SUB   A,0x1
    1120: 54 01    MOV   [X+1],A
    1122: 3C 0F 00 CMP   [__r0],0x0
    1125: BF CD    JNZ   0x10F3
    1127: 3C 0E 00 CMP   [__r1],0x0
    112A: BF C8    JNZ   0x10F3
(0392)     ledHeartbeatSec = LED_HEARTBEAT_SEC;    // Suppress next heartbeat pulse
    112C: 55 01 05 MOV   [ledHeartbeatSec+1],0x5
    112F: 55 00 00 MOV   [ledHeartbeatSec],0x0
    1132: 38 FE    ADD   SP,0xFE
    1134: 20       POP   X
    1135: 7F       RET   
(0393) }
(0394) 
(0395) 
(0396) // ---------------------------------------------------------------------------
(0397) //
(0398) // wakeButtonIsOn()
(0399) //
(0400) // ---------------------------------------------------------------------------
(0401) static BOOL wakeButtonIsOn(void)
(0402) {
(0403)     SW2_Data_ADDR &= ~SW2_MASK;              // Ensure GPIO pulldown active
main.c:wakeButtonIsOn:
    1136: 41 04 EF AND   REG[0x4],0xEF
(0404)     return(SW2_Data_ADDR & SW2_MASK);
    1139: 5D 04    MOV   A,REG[0x4]
    113B: 21 10    AND   A,0x10
    113D: 7F       RET   
(0405) }
(0406) // ---------------------------------------------------------------------------
(0407) //
(0408) // CheckWakeButton() - Also cyclic steps report rate if is button held.
(0409) //
(0410) // ---------------------------------------------------------------------------
(0411) 
(0412) #define BUTTON_HOLD_TIME_TO_INC_REPORT_DELAY   (1500/CYFISNP_TIMER_UNITS)
(0413) 
(0414) static BOOL CheckWakeButton(void)
(0415) {
main.c:CheckWakeButton:
  reportDly            --> X+3
  reportDlySet         --> X+2
  lvDelay              --> X+0
    113E: 10       PUSH  X
    113F: 4F       MOV   X,SP
    1140: 38 05    ADD   SP,0x5
(0416)     WORD lvDelay;
(0417)     WORD reportDly;
(0418) 
(0419)     BOOL reportDlySet;
(0420) 
(0421)     if (wakeButtonIsOn())
    1142: 9F F2    CALL  main.c:wakeButtonIsOn
    1144: 53 0F    MOV   [__r0],A
    1146: 39 00    CMP   A,0x0
    1148: A0 78    JZ    0x11C1
(0422)     {
(0423)         CYFISNP_TimeSet(&lvDelay, DEBOUNCE_TIME);       // Debouncing, delay
    114A: 50 00    MOV   A,0x0
    114C: 08       PUSH  A
    114D: 50 02    MOV   A,0x2
    114F: 08       PUSH  A
    1150: 51 0F    MOV   A,[__r0]
    1152: 08       PUSH  A
    1153: 10       PUSH  X
    1154: 7C 11 C7 LCALL _CYFISNP_TimeSet
    1157: 38 FC    ADD   SP,0xFC
(0424)         while (CYFISNP_TimeExpired(&lvDelay) == 0) ;    // WAIT
    1159: 51 0F    MOV   A,[__r0]
    115B: 08       PUSH  A
    115C: 10       PUSH  X
    115D: 7C 11 F5 LCALL _CYFISNP_TimeExpired
    1160: 38 FE    ADD   SP,0xFE
    1162: 39 00    CMP   A,0x0
    1164: AF F4    JZ    0x1159
(0425)         if (wakeButtonIsOn())           // If button still ON
    1166: 9F CE    CALL  main.c:wakeButtonIsOn
    1168: 53 0F    MOV   [__r0],A
    116A: 39 00    CMP   A,0x0
    116C: A0 54    JZ    0x11C1
(0426)         {
(0427)             CYFISNP_TimeSet(&reportDly, BUTTON_HOLD_TIME_TO_INC_REPORT_DELAY);
    116E: 50 00    MOV   A,0x0
    1170: 08       PUSH  A
    1171: 50 5D    MOV   A,0x5D
    1173: 08       PUSH  A
    1174: 5A 0E    MOV   [__r1],X
    1176: 06 0E 03 ADD   [__r1],0x3
    1179: 51 0F    MOV   A,[__r0]
    117B: 08       PUSH  A
    117C: 51 0E    MOV   A,[__r1]
    117E: 08       PUSH  A
    117F: 7C 11 C7 LCALL _CYFISNP_TimeSet
    1182: 38 FC    ADD   SP,0xFC
(0428)             reportDlySet = TRUE;
    1184: 56 02 01 MOV   [X+2],0x1
    1187: 80 28    JMP   0x11B0
(0429)             while (wakeButtonIsOn())    // Wait for button release
(0430)             {
(0431)                 if (CYFISNP_TimeExpired(&reportDly) == TRUE
    1189: 5A 0E    MOV   [__r1],X
    118B: 06 0E 03 ADD   [__r1],0x3
    118E: 51 0F    MOV   A,[__r0]
    1190: 08       PUSH  A
    1191: 51 0E    MOV   A,[__r1]
    1193: 08       PUSH  A
    1194: 7C 11 F5 LCALL _CYFISNP_TimeExpired
    1197: 38 FE    ADD   SP,0xFE
    1199: 39 01    CMP   A,0x1
    119B: B0 0E    JNZ   0x11AA
    119D: 3D 02 01 CMP   [X+2],0x1
    11A0: B0 09    JNZ   0x11AA
(0432)                     && reportDlySet == TRUE)
(0433)                 {
(0434)                     reportDlySet = FALSE;
    11A2: 56 02 00 MOV   [X+2],0x0
(0435)                     buttonIncReportTime();
    11A5: 9E FE    CALL  main.c:buttonIncReportTime
(0436)                     LED_RED_ON;             // Keep LED ON while switch held
    11A7: 43 04 04 OR    REG[0x4],0x4
(0437)                 }
(0438)                 M8C_ClearWDTAndSleep;
    11AA: 62 E3 38 MOV   REG[0xE3],0x38
(0439) #if LOW_POWER_TEST
(0440)                 M8C_Sleep;
    11AD: 43 FF 08 OR    REG[0xFF],0x8
(0441) #endif
(0442) 
(0443)             }
    11B0: 9F 84    CALL  main.c:wakeButtonIsOn
    11B2: 39 00    CMP   A,0x0
    11B4: BF D4    JNZ   0x1189
(0444)             if (reportDlySet == FALSE)
    11B6: 3D 02 00 CMP   [X+2],0x0
    11B9: B0 03    JNZ   0x11BD
(0445)             {
(0446)                 showReportDelay();
    11BB: 9F 18    CALL  main.c:showReportDelay
(0447)             }
(0448)             return(TRUE);
    11BD: 50 01    MOV   A,0x1
    11BF: 80 03    JMP   0x11C3
(0449)         }
(0450)     }
(0451)     return(FALSE);
    11C1: 50 00    MOV   A,0x0
(0452) }
    11C3: 38 FB    ADD   SP,0xFB
    11C5: 20       POP   X
    11C6: 7F       RET   
_CYFISNP_TimeSet:
    11C7: 10       PUSH  X
    11C8: 4F       MOV   X,SP
    11C9: 38 02    ADD   SP,0x2
    11CB: 41 E0 BF AND   REG[0xE0],0xBF
    11CE: 51 19    MOV   A,[0x19]
    11D0: 54 01    MOV   [X+1],A
    11D2: 51 18    MOV   A,[0x18]
    11D4: 54 00    MOV   [X+0],A
    11D6: 43 E0 40 OR    REG[0xE0],0x40
    11D9: 52 01    MOV   A,[X+1]
    11DB: 03 FA    ADD   A,[X-6]
    11DD: 53 0E    MOV   [__r1],A
    11DF: 52 00    MOV   A,[X+0]
    11E1: 0B F9    ADC   A,[X-7]
    11E3: 53 0F    MOV   [__r0],A
    11E5: 52 FC    MOV   A,[X-4]
    11E7: 53 0C    MOV   [__r3],A
    11E9: 51 0F    MOV   A,[__r0]
    11EB: 3F 0C    MVI   [__r3],A
    11ED: 51 0E    MOV   A,[__r1]
    11EF: 3F 0C    MVI   [__r3],A
    11F1: 38 FE    ADD   SP,0xFE
    11F3: 20       POP   X
    11F4: 7F       RET   
_CYFISNP_TimeExpired:
    11F5: 10       PUSH  X
    11F6: 4F       MOV   X,SP
    11F7: 38 02    ADD   SP,0x2
    11F9: 41 E0 BF AND   REG[0xE0],0xBF
    11FC: 51 19    MOV   A,[0x19]
    11FE: 54 01    MOV   [X+1],A
    1200: 51 18    MOV   A,[0x18]
    1202: 54 00    MOV   [X+0],A
    1204: 43 E0 40 OR    REG[0xE0],0x40
    1207: 52 FC    MOV   A,[X-4]
    1209: 53 0E    MOV   [__r1],A
    120B: 3E 0E    MVI   A,[__r1]
    120D: 53 0F    MOV   [__r0],A
    120F: 3E 0E    MVI   A,[__r1]
    1211: 13 01    SUB   A,[X+1]
    1213: 54 01    MOV   [X+1],A
    1215: 51 0F    MOV   A,[__r0]
    1217: 1B 00    SBB   A,[X+0]
    1219: 54 00    MOV   [X+0],A
    121B: 52 00    MOV   A,[X+0]
    121D: 53 0F    MOV   [__r0],A
    121F: 47 0F 80 TST   [__r0],0x80
    1222: B0 05    JNZ   0x1228
    1224: 50 00    MOV   A,0x0
    1226: 80 03    JMP   0x122A
    1228: 50 01    MOV   A,0x1
    122A: 38 FE    ADD   SP,0xFE
    122C: 20       POP   X
    122D: 7F       RET   
    122E: 50 3F    MOV   A,0x3F
    1230: 10       PUSH  X
    1231: 57 C7    MOV   X,0xC7
    1233: 28       ROMX  
    1234: 20       POP   X
    1235: 53 0F    MOV   [__r0],A
    1237: 50 3F    MOV   A,0x3F
    1239: 10       PUSH  X
    123A: 57 C6    MOV   X,0xC6
    123C: 28       ROMX  
    123D: 08       PUSH  A
    123E: 51 0F    MOV   A,[__r0]
    1240: 20       POP   X
    1241: 7C 09 49 LCALL _CYFISNP_SetCrcSeed
    1244: 20       POP   X
    1245: 7F       RET   
    1246: 50 3F    MOV   A,0x3F
    1248: 10       PUSH  X
    1249: 57 C4    MOV   X,0xC4
    124B: 28       ROMX  
    124C: 20       POP   X
    124D: 53 0F    MOV   [__r0],A
    124F: 50 3F    MOV   A,0x3F
    1251: 10       PUSH  X
    1252: 57 C3    MOV   X,0xC3
    1254: 28       ROMX  
    1255: 08       PUSH  A
    1256: 51 0F    MOV   A,[__r0]
    1258: 20       POP   X
    1259: 7C 09 49 LCALL _CYFISNP_SetCrcSeed
    125C: 20       POP   X
    125D: 7F       RET   
_CYFISNP_Start:
    125E: 3C 82 00 CMP   [CYFISNP_eProtState],0x0
    1261: A0 0A    JZ    0x126C
    1263: 3C 82 50 CMP   [CYFISNP_eProtState],0x50
    1266: A0 05    JZ    0x126C
    1268: 50 00    MOV   A,0x0
    126A: 80 4A    JMP   0x12B5
    126C: 10       PUSH  X
    126D: 7C 07 40 LCALL _CYFISNP_SleepTimer_Set64Hz
    1270: 20       POP   X
    1271: 43 E0 40 OR    REG[0xE0],0x40
    1274: 10       PUSH  X
    1275: 7C 08 4A LCALL _CYFISNP_PhyStart
    1278: 20       POP   X
    1279: 39 00    CMP   A,0x0
    127B: B0 05    JNZ   0x1281
    127D: 50 00    MOV   A,0x0
    127F: 80 35    JMP   0x12B5
    1281: 10       PUSH  X
    1282: 57 C0    MOV   X,0xC0
    1284: 50 0C    MOV   A,0xC
    1286: 7C 0A 07 LCALL _CYFISNP_Write
    1289: 50 02    MOV   A,0x2
    128B: 7C 09 0B LCALL _CYFISNP_SetPreambleCount
    128E: 50 00    MOV   A,0x0
    1290: 7C 0C 27 LCALL _CYFISNP_ForceState
    1293: 50 00    MOV   A,0x0
    1295: 57 7A    MOV   X,0x7A
    1297: 7C 0A 45 LCALL _CYFISNP_SetPtr
    129A: 50 07    MOV   A,0x7
    129C: 7C 0A 48 LCALL _CYFISNP_SetLength
    129F: 20       POP   X
    12A0: 50 00    MOV   A,0x0
    12A2: 08       PUSH  A
    12A3: 7C 1F 6E LCALL 0x1F6E
    12A6: 38 FF    ADD   SP,0xFF
    12A8: 90 7E    CALL  0x1328
    12AA: 7C 1E DC LCALL _CYFISNP_spiSleep
    12AD: 55 5F 00 MOV   [main.h:snpRunScaler+25],0x0
    12B0: 55 5C 00 MOV   [main.h:snpRunScaler+22],0x0
    12B3: 50 01    MOV   A,0x1
    12B5: 7F       RET   
_CYFISNP_Stop:
    12B6: 10       PUSH  X
    12B7: 7C 08 6A LCALL _CYFISNP_PhyStop
    12BA: 20       POP   X
    12BB: 41 E0 BF AND   REG[0xE0],0xBF
    12BE: 55 82 50 MOV   [CYFISNP_eProtState],0x50
    12C1: 7F       RET   
_CYFISNP_Jog:
    12C2: 10       PUSH  X
    12C3: 4F       MOV   X,SP
    12C4: 10       PUSH  X
    12C5: 7C 1F 2D LCALL _CYFISNP_spiWake
    12C8: 3C 82 21 CMP   [CYFISNP_eProtState],0x21
    12CB: A0 0D    JZ    0x12D9
    12CD: 3C 82 21 CMP   [CYFISNP_eProtState],0x21
    12D0: C0 0E    JC    0x12DF
    12D2: 3C 82 31 CMP   [CYFISNP_eProtState],0x31
    12D5: A0 07    JZ    0x12DD
    12D7: 80 07    JMP   0x12DF
    12D9: 92 35    CALL  0x1510
    12DB: 80 03    JMP   0x12DF
    12DD: 97 6A    CALL  0x1A49
    12DF: 20       POP   X
    12E0: 20       POP   X
    12E1: 7F       RET   
_CYFISNP_Run:
    12E2: 10       PUSH  X
    12E3: 4F       MOV   X,SP
    12E4: 10       PUSH  X
    12E5: 3C 82 20 CMP   [CYFISNP_eProtState],0x20
    12E8: A0 26    JZ    0x130F
    12EA: 50 20    MOV   A,0x20
    12EC: 3A 82    CMP   A,[CYFISNP_eProtState]
    12EE: C0 08    JC    0x12F7
    12F0: 3C 82 10 CMP   [CYFISNP_eProtState],0x10
    12F3: A0 14    JZ    0x1308
    12F5: 80 2F    JMP   0x1325
    12F7: 3C 82 30 CMP   [CYFISNP_eProtState],0x30
    12FA: A0 25    JZ    0x1320
    12FC: 3C 82 30 CMP   [CYFISNP_eProtState],0x30
    12FF: C0 25    JC    0x1325
    1301: 3C 82 40 CMP   [CYFISNP_eProtState],0x40
    1304: A0 11    JZ    0x1316
    1306: 80 1E    JMP   0x1325
    1308: 7C 1F 2D LCALL _CYFISNP_spiWake
    130B: 90 7F    CALL  0x138C
    130D: 80 17    JMP   0x1325
    130F: 7C 1F 2D LCALL _CYFISNP_spiWake
    1312: 92 3A    CALL  0x154E
    1314: 80 10    JMP   0x1325
    1316: 7C 1F 2D LCALL _CYFISNP_spiWake
    1319: 94 D9    CALL  0x17F4
    131B: 7C 1E DC LCALL _CYFISNP_spiSleep
    131E: 80 06    JMP   0x1325
    1320: 7C 1F 2D LCALL _CYFISNP_spiWake
    1323: 97 4B    CALL  0x1A70
    1325: 20       POP   X
    1326: 20       POP   X
    1327: 7F       RET   
    1328: 7C 1F 5C LCALL 0x1F5C
    132B: 39 00    CMP   A,0x0
    132D: A0 05    JZ    0x1333
    132F: 91 CC    CALL  0x14FD
    1331: 80 03    JMP   0x1335
    1333: 90 01    CALL  0x1336
    1335: 7F       RET   
    1336: 55 82 11 MOV   [CYFISNP_eProtState],0x11
    1339: 7F       RET   
_CYFISNP_BindStart:
    133A: 10       PUSH  X
    133B: 4F       MOV   X,SP
    133C: 7C 1F 2D LCALL _CYFISNP_spiWake
    133F: 55 53 00 MOV   [main.h:snpRunScaler+13],0x0
    1342: 5F 0E 53 MOV   [__r1],[main.h:snpRunScaler+13]
    1345: 55 0F 00 MOV   [__r0],0x0
    1348: 06 0E C8 ADD   [__r1],0xC8
    134B: 0E 0F 01 ADC   [__r0],0x1
    134E: 51 0F    MOV   A,[__r0]
    1350: 10       PUSH  X
    1351: 58 0E    MOV   X,[__r1]
    1353: 28       ROMX  
    1354: 20       POP   X
    1355: 53 81    MOV   [CYFISNP_bCurrentChannel],A
    1357: 10       PUSH  X
    1358: 51 81    MOV   A,[CYFISNP_bCurrentChannel]
    135A: 7C 08 C9 LCALL _CYFISNP_SetChannel
    135D: 50 00    MOV   A,0x0
    135F: 7C 09 A9 LCALL _CYFISNP_SetSopPnCode
    1362: 20       POP   X
    1363: 55 7A 00 MOV   [CYFISNP_radioTxConfig+14],0x0
    1366: 52 FC    MOV   A,[X-4]
    1368: 53 7B    MOV   [CYFISNP_radioTxConfig+15],A
    136A: 7C 1B B5 LCALL 0x1BB5
    136D: 55 80 1C MOV   [CYFISNP_radioTxConfig+20],0x1C
    1370: 55 82 10 MOV   [CYFISNP_eProtState],0x10
    1373: 55 52 F4 MOV   [main.h:snpRunScaler+12],0xF4
    1376: 55 51 01 MOV   [main.h:snpRunScaler+11],0x1
    1379: 50 00    MOV   A,0x0
    137B: 08       PUSH  A
    137C: 50 01    MOV   A,0x1
    137E: 08       PUSH  A
    137F: 50 00    MOV   A,0x0
    1381: 08       PUSH  A
    1382: 50 4F    MOV   A,0x4F
    1384: 08       PUSH  A
    1385: 7C 11 C7 LCALL _CYFISNP_TimeSet
    1388: 38 FC    ADD   SP,0xFC
    138A: 20       POP   X
    138B: 7F       RET   
    138C: 10       PUSH  X
    138D: 4F       MOV   X,SP
    138E: 38 04    ADD   SP,0x4
    1390: 50 00    MOV   A,0x0
    1392: 08       PUSH  A
    1393: 50 4F    MOV   A,0x4F
    1395: 08       PUSH  A
    1396: 7C 11 F5 LCALL _CYFISNP_TimeExpired
    1399: 38 FE    ADD   SP,0xFE
    139B: 39 01    CMP   A,0x1
    139D: B1 53    JNZ   0x14F1
    139F: 50 00    MOV   A,0x0
    13A1: 08       PUSH  A
    13A2: 50 01    MOV   A,0x1
    13A4: 08       PUSH  A
    13A5: 50 00    MOV   A,0x0
    13A7: 08       PUSH  A
    13A8: 50 4F    MOV   A,0x4F
    13AA: 08       PUSH  A
    13AB: 7C 11 C7 LCALL _CYFISNP_TimeSet
    13AE: 38 FC    ADD   SP,0xFC
    13B0: 06 53 01 ADD   [main.h:snpRunScaler+13],0x1
    13B3: 3C 53 06 CMP   [main.h:snpRunScaler+13],0x6
    13B6: C0 04    JC    0x13BB
    13B8: 55 53 00 MOV   [main.h:snpRunScaler+13],0x0
    13BB: 5F 0E 53 MOV   [__r1],[main.h:snpRunScaler+13]
    13BE: 55 0F 00 MOV   [__r0],0x0
    13C1: 06 0E C8 ADD   [__r1],0xC8
    13C4: 0E 0F 01 ADC   [__r0],0x1
    13C7: 51 0F    MOV   A,[__r0]
    13C9: 10       PUSH  X
    13CA: 58 0E    MOV   X,[__r1]
    13CC: 28       ROMX  
    13CD: 20       POP   X
    13CE: 53 81    MOV   [CYFISNP_bCurrentChannel],A
    13D0: 10       PUSH  X
    13D1: 51 81    MOV   A,[CYFISNP_bCurrentChannel]
    13D3: 7C 08 C9 LCALL _CYFISNP_SetChannel
    13D6: 20       POP   X
    13D7: 7C 1E 8B LCALL 0x1E8B
    13DA: 50 01    MOV   A,0x1
    13DC: 08       PUSH  A
    13DD: 7C 1F 6E LCALL 0x1F6E
    13E0: 38 FF    ADD   SP,0xFF
    13E2: 10       PUSH  X
    13E3: 50 00    MOV   A,0x0
    13E5: 57 00    MOV   X,0x0
    13E7: 7C 09 49 LCALL _CYFISNP_SetCrcSeed
    13EA: 50 91    MOV   A,0x91
    13EC: 7C 08 E7 LCALL _CYFISNP_SetXactConfig
    13EF: 50 00    MOV   A,0x0
    13F1: 57 7A    MOV   X,0x7A
    13F3: 7C 0A 45 LCALL _CYFISNP_SetPtr
    13F6: 57 07    MOV   X,0x7
    13F8: 50 00    MOV   A,0x0
    13FA: 7C 0A 7E LCALL _CYFISNP_StartTransmit
    13FD: 20       POP   X
    13FE: 80 06    JMP   0x1405
    1400: 10       PUSH  X
    1401: 7C 0A B8 LCALL _CYFISNP_GetTransmitState
    1404: 20       POP   X
    1405: 47 21 02 TST   [0x21],0x2
    1408: AF F7    JZ    0x1400
    140A: 51 21    MOV   A,[0x21]
    140C: 54 00    MOV   [X+0],A
    140E: 10       PUSH  X
    140F: 7C 0B 1F LCALL _CYFISNP_EndTransmit
    1412: 20       POP   X
    1413: 50 00    MOV   A,0x0
    1415: 08       PUSH  A
    1416: 7C 1F 6E LCALL 0x1F6E
    1419: 38 FF    ADD   SP,0xFF
    141B: 5F 0E 7D MOV   [__r1],[CYFISNP_radioTxConfig+17]
    141E: 55 0F 00 MOV   [__r0],0x0
    1421: 5F 0D 7C MOV   [__r2],[CYFISNP_radioTxConfig+16]
    1424: 50 00    MOV   A,0x0
    1426: 2A 0E    OR    A,[__r1]
    1428: 53 0E    MOV   [__r1],A
    142A: 51 0D    MOV   A,[__r2]
    142C: 2A 0F    OR    A,[__r0]
    142E: 10       PUSH  X
    142F: 08       PUSH  A
    1430: 51 0E    MOV   A,[__r1]
    1432: 20       POP   X
    1433: 7C 09 49 LCALL _CYFISNP_SetCrcSeed
    1436: 20       POP   X
    1437: 48 00 01 TST   [X+0],0x1
    143A: A0 0A    JZ    0x1445
    143C: 10       PUSH  X
    143D: 50 00    MOV   A,0x0
    143F: 7C 0C 27 LCALL _CYFISNP_ForceState
    1442: 20       POP   X
    1443: 80 92    JMP   0x14D6
    1445: 56 02 1E MOV   [X+2],0x1E
    1448: 56 01 00 MOV   [X+1],0x0
    144B: 7C 1E 83 LCALL 0x1E83
    144E: 10       PUSH  X
    144F: 50 00    MOV   A,0x0
    1451: 57 70    MOV   X,0x70
    1453: 7C 0A 45 LCALL _CYFISNP_SetPtr
    1456: 50 0A    MOV   A,0xA
    1458: 7C 0A 48 LCALL _CYFISNP_SetLength
    145B: 50 85    MOV   A,0x85
    145D: 7C 08 E7 LCALL _CYFISNP_SetXactConfig
    1460: 7C 0B 2D LCALL _CYFISNP_StartReceive
    1463: 20       POP   X
    1464: 56 03 00 MOV   [X+3],0x0
    1467: 10       PUSH  X
    1468: 7C 0B 60 LCALL _CYFISNP_GetReceiveState
    146B: 20       POP   X
    146C: 54 00    MOV   [X+0],A
    146E: 10       PUSH  X
    146F: 7C 07 55 LCALL _CYFISNP_Delay100uS
    1472: 20       POP   X
    1473: 52 02    MOV   A,[X+2]
    1475: 11 01    SUB   A,0x1
    1477: 53 0E    MOV   [__r1],A
    1479: 52 01    MOV   A,[X+1]
    147B: 19 00    SBB   A,0x0
    147D: 53 0F    MOV   [__r0],A
    147F: 51 0E    MOV   A,[__r1]
    1481: 54 02    MOV   [X+2],A
    1483: 51 0F    MOV   A,[__r0]
    1485: 54 01    MOV   [X+1],A
    1487: 3C 0F 00 CMP   [__r0],0x0
    148A: B0 1B    JNZ   0x14A6
    148C: 3C 0E 00 CMP   [__r1],0x0
    148F: B0 16    JNZ   0x14A6
    1491: 10       PUSH  X
    1492: 7C 0B E5 LCALL _CYFISNP_Abort
    1495: 20       POP   X
    1496: 54 03    MOV   [X+3],A
    1498: 3D 03 FF CMP   [X+3],0xFF
    149B: B0 0A    JNZ   0x14A6
    149D: 10       PUSH  X
    149E: 50 00    MOV   A,0x0
    14A0: 7C 0C 27 LCALL _CYFISNP_ForceState
    14A3: 20       POP   X
    14A4: 80 31    JMP   0x14D6
    14A6: 48 00 02 TST   [X+0],0x2
    14A9: AF BA    JZ    0x1464
    14AB: 10       PUSH  X
    14AC: 7C 0B A6 LCALL _CYFISNP_EndReceive
    14AF: 20       POP   X
    14B0: 54 03    MOV   [X+3],A
    14B2: 10       PUSH  X
    14B3: 50 00    MOV   A,0x0
    14B5: 7C 0C 27 LCALL _CYFISNP_ForceState
    14B8: 20       POP   X
    14B9: 48 00 01 TST   [X+0],0x1
    14BC: B0 19    JNZ   0x14D6
    14BE: 3C 70 10 CMP   [CYFISNP_radioTxConfig+4],0x10
    14C1: BF A2    JNZ   0x1464
    14C3: 3D 03 0A CMP   [X+3],0xA
    14C6: BF 9D    JNZ   0x1464
    14C8: 50 00    MOV   A,0x0
    14CA: 08       PUSH  A
    14CB: 50 70    MOV   A,0x70
    14CD: 08       PUSH  A
    14CE: 96 F7    CALL  0x1BC7
    14D0: 38 FE    ADD   SP,0xFE
    14D2: 90 29    CALL  0x14FD
    14D4: 80 1C    JMP   0x14F1
    14D6: 51 52    MOV   A,[main.h:snpRunScaler+12]
    14D8: 11 01    SUB   A,0x1
    14DA: 53 0E    MOV   [__r1],A
    14DC: 51 51    MOV   A,[main.h:snpRunScaler+11]
    14DE: 19 00    SBB   A,0x0
    14E0: 5F 52 0E MOV   [main.h:snpRunScaler+12],[__r1]
    14E3: 53 51    MOV   [main.h:snpRunScaler+11],A
    14E5: 3C 51 00 CMP   [main.h:snpRunScaler+11],0x0
    14E8: B0 08    JNZ   0x14F1
    14EA: 3C 0E 00 CMP   [__r1],0x0
    14ED: B0 03    JNZ   0x14F1
    14EF: 9E 37    CALL  0x1328
    14F1: 38 FC    ADD   SP,0xFC
    14F3: 20       POP   X
    14F4: 7F       RET   
_CYFISNP_GetNodeID:
    14F5: 50 3F    MOV   A,0x3F
    14F7: 10       PUSH  X
    14F8: 57 C5    MOV   X,0xC5
    14FA: 28       ROMX  
    14FB: 20       POP   X
    14FC: 7F       RET   
    14FD: 50 3F    MOV   A,0x3F
    14FF: 10       PUSH  X
    1500: 57 C1    MOV   X,0xC1
    1502: 28       ROMX  
    1503: 20       POP   X
    1504: 53 81    MOV   [CYFISNP_bCurrentChannel],A
    1506: 50 00    MOV   A,0x0
    1508: 08       PUSH  A
    1509: 92 A3    CALL  0x17AE
    150B: 38 FF    ADD   SP,0xFF
    150D: 90 01    CALL  0x1510
    150F: 7F       RET   
    1510: 7C 1E 83 LCALL 0x1E83
    1513: 10       PUSH  X
    1514: 51 81    MOV   A,[CYFISNP_bCurrentChannel]
    1516: 7C 08 C9 LCALL _CYFISNP_SetChannel
    1519: 20       POP   X
    151A: 50 3F    MOV   A,0x3F
    151C: 10       PUSH  X
    151D: 57 C0    MOV   X,0xC0
    151F: 28       ROMX  
    1520: 7C 09 A9 LCALL _CYFISNP_SetSopPnCode
    1523: 20       POP   X
    1524: 55 82 20 MOV   [CYFISNP_eProtState],0x20
    1527: 55 59 01 MOV   [main.h:snpRunScaler+19],0x1
    152A: 55 57 C8 MOV   [main.h:snpRunScaler+17],0xC8
    152D: 55 56 00 MOV   [main.h:snpRunScaler+16],0x0
    1530: 50 00    MOV   A,0x0
    1532: 08       PUSH  A
    1533: 08       PUSH  A
    1534: 50 00    MOV   A,0x0
    1536: 08       PUSH  A
    1537: 50 54    MOV   A,0x54
    1539: 08       PUSH  A
    153A: 7C 11 C7 LCALL _CYFISNP_TimeSet
    153D: 38 FC    ADD   SP,0xFC
    153F: 55 7A 00 MOV   [CYFISNP_radioTxConfig+14],0x0
    1542: 50 3F    MOV   A,0x3F
    1544: 10       PUSH  X
    1545: 57 C5    MOV   X,0xC5
    1547: 28       ROMX  
    1548: 20       POP   X
    1549: 53 7B    MOV   [CYFISNP_radioTxConfig+15],A
    154B: 96 68    CALL  0x1BB5
    154D: 7F       RET   
    154E: 10       PUSH  X
    154F: 4F       MOV   X,SP
    1550: 10       PUSH  X
    1551: 50 00    MOV   A,0x0
    1553: 08       PUSH  A
    1554: 50 54    MOV   A,0x54
    1556: 08       PUSH  A
    1557: 7C 11 F5 LCALL _CYFISNP_TimeExpired
    155A: 38 FE    ADD   SP,0xFE
    155C: 39 00    CMP   A,0x0
    155E: A1 62    JZ    0x16C1
    1560: 50 64    MOV   A,0x64
    1562: 12 57    SUB   A,[main.h:snpRunScaler+17]
    1564: 50 00    MOV   A,0x0
    1566: 1A 56    SBB   A,[main.h:snpRunScaler+16]
    1568: D0 12    JNC   0x157B
    156A: 50 00    MOV   A,0x0
    156C: 08       PUSH  A
    156D: 08       PUSH  A
    156E: 50 00    MOV   A,0x0
    1570: 08       PUSH  A
    1571: 50 54    MOV   A,0x54
    1573: 08       PUSH  A
    1574: 7C 11 C7 LCALL _CYFISNP_TimeSet
    1577: 38 FC    ADD   SP,0xFC
    1579: 80 12    JMP   0x158C
    157B: 50 00    MOV   A,0x0
    157D: 08       PUSH  A
    157E: 50 0C    MOV   A,0xC
    1580: 08       PUSH  A
    1581: 50 00    MOV   A,0x0
    1583: 08       PUSH  A
    1584: 50 54    MOV   A,0x54
    1586: 08       PUSH  A
    1587: 7C 11 C7 LCALL _CYFISNP_TimeSet
    158A: 38 FC    ADD   SP,0xFC
    158C: 5F 0E 57 MOV   [__r1],[main.h:snpRunScaler+17]
    158F: 5F 0F 56 MOV   [__r0],[main.h:snpRunScaler+16]
    1592: 51 0E    MOV   A,[__r1]
    1594: 11 01    SUB   A,0x1
    1596: 53 57    MOV   [main.h:snpRunScaler+17],A
    1598: 51 0F    MOV   A,[__r0]
    159A: 19 00    SBB   A,0x0
    159C: 53 56    MOV   [main.h:snpRunScaler+16],A
    159E: 3C 0F 00 CMP   [__r0],0x0
    15A1: B0 0C    JNZ   0x15AE
    15A3: 3C 0E 00 CMP   [__r1],0x0
    15A6: B0 07    JNZ   0x15AE
    15A8: 55 82 21 MOV   [CYFISNP_eProtState],0x21
    15AB: 7C 1E DC LCALL _CYFISNP_spiSleep
    15AE: 5F 0E 59 MOV   [__r1],[main.h:snpRunScaler+19]
    15B1: 51 59    MOV   A,[main.h:snpRunScaler+19]
    15B3: 11 01    SUB   A,0x1
    15B5: 53 0C    MOV   [__r3],A
    15B7: 50 00    MOV   A,0x0
    15B9: 5F 59 0C MOV   [main.h:snpRunScaler+19],[__r3]
    15BC: 12 0E    SUB   A,[__r1]
    15BE: 50 00    MOV   A,0x0
    15C0: 31 80    XOR   A,0x80
    15C2: 53 0B    MOV   [__rX],A
    15C4: 50 80    MOV   A,0x80
    15C6: 1A 0B    SBB   A,[__rX]
    15C8: C0 10    JC    0x15D9
    15CA: 55 59 01 MOV   [main.h:snpRunScaler+19],0x1
    15CD: 55 58 00 MOV   [main.h:snpRunScaler+18],0x0
    15D0: 95 3C    CALL  0x1B0E
    15D2: 10       PUSH  X
    15D3: 51 81    MOV   A,[CYFISNP_bCurrentChannel]
    15D5: 7C 08 C9 LCALL _CYFISNP_SetChannel
    15D8: 20       POP   X
    15D9: 9C 6B    CALL  0x1246
    15DB: 10       PUSH  X
    15DC: 50 0C    MOV   A,0xC
    15DE: 7C 0C 27 LCALL _CYFISNP_ForceState
    15E1: 50 00    MOV   A,0x0
    15E3: 57 7A    MOV   X,0x7A
    15E5: 7C 0A 45 LCALL _CYFISNP_SetPtr
    15E8: 57 06    MOV   X,0x6
    15EA: 50 00    MOV   A,0x0
    15EC: 7C 0A 7E LCALL _CYFISNP_StartTransmit
    15EF: 20       POP   X
    15F0: 80 06    JMP   0x15F7
    15F2: 10       PUSH  X
    15F3: 7C 0A B8 LCALL _CYFISNP_GetTransmitState
    15F6: 20       POP   X
    15F7: 47 21 02 TST   [0x21],0x2
    15FA: AF F7    JZ    0x15F2
    15FC: 5F 62 21 MOV   [main.h:snpRunScaler+28],[0x21]
    15FF: 10       PUSH  X
    1600: 7C 0B 1F LCALL _CYFISNP_EndTransmit
    1603: 20       POP   X
    1604: 47 62 01 TST   [main.h:snpRunScaler+28],0x1
    1607: A0 11    JZ    0x1619
    1609: 10       PUSH  X
    160A: 50 00    MOV   A,0x0
    160C: 7C 0C 27 LCALL _CYFISNP_ForceState
    160F: 20       POP   X
    1610: 50 00    MOV   A,0x0
    1612: 08       PUSH  A
    1613: 96 C5    CALL  0x1CDA
    1615: 38 FF    ADD   SP,0xFF
    1617: 80 A9    JMP   0x16C1
    1619: 50 08    MOV   A,0x8
    161B: 08       PUSH  A
    161C: 96 BC    CALL  0x1CDA
    161E: 38 FF    ADD   SP,0xFF
    1620: 55 65 00 MOV   [main.h:snpRunScaler+31],0x0
    1623: 3C 58 00 CMP   [main.h:snpRunScaler+18],0x0
    1626: B0 07    JNZ   0x162E
    1628: 55 58 01 MOV   [main.h:snpRunScaler+18],0x1
    162B: 55 59 09 MOV   [main.h:snpRunScaler+19],0x9
    162E: 50 00    MOV   A,0x0
    1630: 08       PUSH  A
    1631: 50 03    MOV   A,0x3
    1633: 08       PUSH  A
    1634: 50 00    MOV   A,0x0
    1636: 08       PUSH  A
    1637: 50 5A    MOV   A,0x5A
    1639: 08       PUSH  A
    163A: 7C 11 C7 LCALL _CYFISNP_TimeSet
    163D: 38 FC    ADD   SP,0xFC
    163F: 10       PUSH  X
    1640: 50 85    MOV   A,0x85
    1642: 7C 08 E7 LCALL _CYFISNP_SetXactConfig
    1645: 20       POP   X
    1646: 91 50    CALL  0x1798
    1648: 56 00 00 MOV   [X+0],0x0
    164B: 10       PUSH  X
    164C: 7C 0B 60 LCALL _CYFISNP_GetReceiveState
    164F: 20       POP   X
    1650: 53 62    MOV   [main.h:snpRunScaler+28],A
    1652: 50 00    MOV   A,0x0
    1654: 08       PUSH  A
    1655: 50 5A    MOV   A,0x5A
    1657: 08       PUSH  A
    1658: 7C 11 F5 LCALL _CYFISNP_TimeExpired
    165B: 38 FE    ADD   SP,0xFE
    165D: 39 00    CMP   A,0x0
    165F: A0 16    JZ    0x1676
    1661: 10       PUSH  X
    1662: 7C 0B E5 LCALL _CYFISNP_Abort
    1665: 20       POP   X
    1666: 54 00    MOV   [X+0],A
    1668: 3D 00 FF CMP   [X+0],0xFF
    166B: B0 0A    JNZ   0x1676
    166D: 10       PUSH  X
    166E: 50 00    MOV   A,0x0
    1670: 7C 0C 27 LCALL _CYFISNP_ForceState
    1673: 20       POP   X
    1674: 80 4C    JMP   0x16C1
    1676: 47 62 01 TST   [main.h:snpRunScaler+28],0x1
    1679: A0 0D    JZ    0x1687
    167B: 10       PUSH  X
    167C: 7C 0B A6 LCALL _CYFISNP_EndReceive
    167F: 50 00    MOV   A,0x0
    1681: 7C 0C 27 LCALL _CYFISNP_ForceState
    1684: 20       POP   X
    1685: 80 3B    JMP   0x16C1
    1687: 47 62 02 TST   [main.h:snpRunScaler+28],0x2
    168A: AF BD    JZ    0x1648
    168C: 10       PUSH  X
    168D: 7C 0B A6 LCALL _CYFISNP_EndReceive
    1690: 20       POP   X
    1691: 54 00    MOV   [X+0],A
    1693: 10       PUSH  X
    1694: 50 00    MOV   A,0x0
    1696: 7C 0C 27 LCALL _CYFISNP_ForceState
    1699: 20       POP   X
    169A: 3C 70 10 CMP   [CYFISNP_radioTxConfig+4],0x10
    169D: BF AA    JNZ   0x1648
    169F: 3D 00 06 CMP   [X+0],0x6
    16A2: BF A5    JNZ   0x1648
    16A4: 50 00    MOV   A,0x0
    16A6: 08       PUSH  A
    16A7: 50 72    MOV   A,0x72
    16A9: 08       PUSH  A
    16AA: 94 A5    CALL  0x1B51
    16AC: 38 FE    ADD   SP,0xFE
    16AE: 39 01    CMP   A,0x1
    16B0: BF 97    JNZ   0x1648
    16B2: 3C 71 00 CMP   [CYFISNP_radioTxConfig+5],0x0
    16B5: A0 05    JZ    0x16BB
    16B7: 90 AC    CALL  0x1765
    16B9: 80 07    JMP   0x16C1
    16BB: 95 7F    CALL  _CYFISNP_Unbind
    16BD: 9C 77    CALL  0x1336
    16BF: 8F 88    JMP   0x1648
    16C1: 20       POP   X
    16C2: 20       POP   X
    16C3: 7F       RET   
_CYFISNP_TxDataPend:
    16C4: 3C 5C 00 CMP   [main.h:snpRunScaler+22],0x0
    16C7: B0 05    JNZ   0x16CD
    16C9: 50 00    MOV   A,0x0
    16CB: 80 03    JMP   0x16CF
    16CD: 50 01    MOV   A,0x1
    16CF: 7F       RET   
_CYFISNP_TxDataPut:
    16D0: 10       PUSH  X
    16D1: 4F       MOV   X,SP
    16D2: 38 03    ADD   SP,0x3
    16D4: 56 00 20 MOV   [X+0],0x20
    16D7: 52 FC    MOV   A,[X-4]
    16D9: 01 02    ADD   A,0x2
    16DB: 53 0E    MOV   [__r1],A
    16DD: 3E 0E    MVI   A,[__r1]
    16DF: 54 02    MOV   [X+2],A
    16E1: 56 01 00 MOV   [X+1],0x0
    16E4: 52 02    MOV   A,[X+2]
    16E6: 11 20    SUB   A,0x20
    16E8: 53 0A    MOV   [__rY],A
    16EA: 52 01    MOV   A,[X+1]
    16EC: 31 80    XOR   A,0x80
    16EE: 19 80    SBB   A,0x80
    16F0: 2A 0A    OR    A,[__rY]
    16F2: A0 2D    JZ    0x1720
    16F4: D0 0D    JNC   0x1702
    16F6: 3D 01 00 CMP   [X+1],0x0
    16F9: B0 06    JNZ   0x1700
    16FB: 3D 02 10 CMP   [X+2],0x10
    16FE: A0 24    JZ    0x1723
    1700: 80 36    JMP   0x1737
    1702: 52 02    MOV   A,[X+2]
    1704: 11 30    SUB   A,0x30
    1706: 53 0A    MOV   [__rY],A
    1708: 52 01    MOV   A,[X+1]
    170A: 31 80    XOR   A,0x80
    170C: 19 80    SBB   A,0x80
    170E: C0 28    JC    0x1737
    1710: 2A 0A    OR    A,[__rY]
    1712: A0 1C    JZ    0x172F
    1714: 3D 01 00 CMP   [X+1],0x0
    1717: B0 06    JNZ   0x171E
    1719: 3D 02 40 CMP   [X+2],0x40
    171C: A0 0F    JZ    0x172C
    171E: 80 18    JMP   0x1737
    1720: 2F 00 04 OR    [X+0],0x4
    1723: 51 65    MOV   A,[main.h:snpRunScaler+31]
    1725: 2D 00    OR    [X+0],A
    1727: 55 5F 0A MOV   [main.h:snpRunScaler+25],0xA
    172A: 80 10    JMP   0x173B
    172C: 2F 00 04 OR    [X+0],0x4
    172F: 2F 00 02 OR    [X+0],0x2
    1732: 55 5F 0A MOV   [main.h:snpRunScaler+25],0xA
    1735: 80 05    JMP   0x173B
    1737: 50 00    MOV   A,0x0
    1739: 80 27    JMP   0x1761
    173B: 52 FC    MOV   A,[X-4]
    173D: 01 02    ADD   A,0x2
    173F: 53 0E    MOV   [__r1],A
    1741: 52 00    MOV   A,[X+0]
    1743: 3F 0E    MVI   [__r1],A
    1745: 50 3F    MOV   A,0x3F
    1747: 10       PUSH  X
    1748: 57 C5    MOV   X,0xC5
    174A: 28       ROMX  
    174B: 20       POP   X
    174C: 53 0F    MOV   [__r0],A
    174E: 52 FC    MOV   A,[X-4]
    1750: 01 03    ADD   A,0x3
    1752: 53 0C    MOV   [__r3],A
    1754: 51 0F    MOV   A,[__r0]
    1756: 3F 0C    MVI   [__r3],A
    1758: 52 FC    MOV   A,[X-4]
    175A: 53 5E    MOV   [main.h:snpRunScaler+24],A
    175C: 55 5C 01 MOV   [main.h:snpRunScaler+22],0x1
    175F: 50 01    MOV   A,0x1
    1761: 38 FD    ADD   SP,0xFD
    1763: 20       POP   X
    1764: 7F       RET   
    1765: 97 1C    CALL  0x1E83
    1767: 55 82 40 MOV   [CYFISNP_eProtState],0x40
    176A: 9F 58    CALL  _CYFISNP_TxDataPend
    176C: 39 01    CMP   A,0x1
    176E: B0 06    JNZ   0x1775
    1770: 55 5F 0A MOV   [main.h:snpRunScaler+25],0xA
    1773: 9B 4D    CALL  _CYFISNP_Jog
    1775: 3C 60 00 CMP   [main.h:snpRunScaler+26],0x0
    1778: A0 1E    JZ    0x1797
    177A: 10       PUSH  X
    177B: 50 04    MOV   A,0x4
    177D: 7C 0C 27 LCALL _CYFISNP_ForceState
    1780: 20       POP   X
    1781: 90 15    CALL  0x1798
    1783: 55 4C 01 MOV   [main.h:snpRunScaler+6],0x1
    1786: 50 00    MOV   A,0x0
    1788: 08       PUSH  A
    1789: 50 BB    MOV   A,0xBB
    178B: 08       PUSH  A
    178C: 50 00    MOV   A,0x0
    178E: 08       PUSH  A
    178F: 50 4D    MOV   A,0x4D
    1791: 08       PUSH  A
    1792: 7C 11 C7 LCALL _CYFISNP_TimeSet
    1795: 38 FC    ADD   SP,0xFC
    1797: 7F       RET   
    1798: 10       PUSH  X
    1799: 50 00    MOV   A,0x0
    179B: 57 70    MOV   X,0x70
    179D: 7C 0A 45 LCALL _CYFISNP_SetPtr
    17A0: 50 0A    MOV   A,0xA
    17A2: 7C 0A 48 LCALL _CYFISNP_SetLength
    17A5: 20       POP   X
    17A6: 9A 86    CALL  0x122E
    17A8: 10       PUSH  X
    17A9: 7C 0B 2D LCALL _CYFISNP_StartReceive
    17AC: 20       POP   X
    17AD: 7F       RET   
    17AE: 10       PUSH  X
    17AF: 4F       MOV   X,SP
    17B0: 51 60    MOV   A,[main.h:snpRunScaler+26]
    17B2: 3B FC    CMP   A,[X-4]
    17B4: A0 3D    JZ    0x17F2
    17B6: 52 FC    MOV   A,[X-4]
    17B8: 53 60    MOV   [main.h:snpRunScaler+26],A
    17BA: 3D FC 00 CMP   [X-4],0x0
    17BD: B0 12    JNZ   0x17D0
    17BF: 10       PUSH  X
    17C0: 7C 0B E5 LCALL _CYFISNP_Abort
    17C3: 20       POP   X
    17C4: 53 61    MOV   [main.h:snpRunScaler+27],A
    17C6: 10       PUSH  X
    17C7: 50 00    MOV   A,0x0
    17C9: 7C 0C 27 LCALL _CYFISNP_ForceState
    17CC: 20       POP   X
    17CD: 55 4C 00 MOV   [main.h:snpRunScaler+6],0x0
    17D0: 3D FC 01 CMP   [X-4],0x1
    17D3: B0 1E    JNZ   0x17F2
    17D5: 10       PUSH  X
    17D6: 50 04    MOV   A,0x4
    17D8: 7C 0C 27 LCALL _CYFISNP_ForceState
    17DB: 20       POP   X
    17DC: 9F BA    CALL  0x1798
    17DE: 55 4C 01 MOV   [main.h:snpRunScaler+6],0x1
    17E1: 50 00    MOV   A,0x0
    17E3: 08       PUSH  A
    17E4: 50 BB    MOV   A,0xBB
    17E6: 08       PUSH  A
    17E7: 50 00    MOV   A,0x0
    17E9: 08       PUSH  A
    17EA: 50 4D    MOV   A,0x4D
    17EC: 08       PUSH  A
    17ED: 7C 11 C7 LCALL _CYFISNP_TimeSet
    17F0: 38 FC    ADD   SP,0xFC
    17F2: 20       POP   X
    17F3: 7F       RET   
    17F4: 10       PUSH  X
    17F5: 4F       MOV   X,SP
    17F6: 10       PUSH  X
    17F7: 55 61 FF MOV   [main.h:snpRunScaler+27],0xFF
    17FA: 3C 5F 00 CMP   [main.h:snpRunScaler+25],0x0
    17FD: A0 1D    JZ    0x181B
    17FF: 3C 4C 01 CMP   [main.h:snpRunScaler+6],0x1
    1802: B0 0B    JNZ   0x180E
    1804: 10       PUSH  X
    1805: 7C 0B E5 LCALL _CYFISNP_Abort
    1808: 20       POP   X
    1809: 53 61    MOV   [main.h:snpRunScaler+27],A
    180B: 55 4C 00 MOV   [main.h:snpRunScaler+6],0x0
    180E: 3C 61 FF CMP   [main.h:snpRunScaler+27],0xFF
    1811: B0 05    JNZ   0x1817
    1813: 90 F2    CALL  0x1907
    1815: 80 83    JMP   0x1899
    1817: 90 83    CALL  0x189C
    1819: 80 7F    JMP   0x1899
    181B: 3C 60 00 CMP   [main.h:snpRunScaler+26],0x0
    181E: A0 7A    JZ    0x1899
    1820: 50 00    MOV   A,0x0
    1822: 08       PUSH  A
    1823: 50 4D    MOV   A,0x4D
    1825: 08       PUSH  A
    1826: 7C 11 F5 LCALL _CYFISNP_TimeExpired
    1829: 38 FE    ADD   SP,0xFE
    182B: 39 00    CMP   A,0x0
    182D: A0 29    JZ    0x1857
    182F: 10       PUSH  X
    1830: 7C 0B E5 LCALL _CYFISNP_Abort
    1833: 20       POP   X
    1834: 53 61    MOV   [main.h:snpRunScaler+27],A
    1836: 55 4C 00 MOV   [main.h:snpRunScaler+6],0x0
    1839: 3C 61 FF CMP   [main.h:snpRunScaler+27],0xFF
    183C: B0 05    JNZ   0x1842
    183E: 92 09    CALL  0x1A49
    1840: 80 58    JMP   0x1899
    1842: 50 00    MOV   A,0x0
    1844: 08       PUSH  A
    1845: 50 BB    MOV   A,0xBB
    1847: 08       PUSH  A
    1848: 50 00    MOV   A,0x0
    184A: 08       PUSH  A
    184B: 50 4D    MOV   A,0x4D
    184D: 08       PUSH  A
    184E: 7C 11 C7 LCALL _CYFISNP_TimeSet
    1851: 38 FC    ADD   SP,0xFC
    1853: 90 47    CALL  0x189C
    1855: 80 43    JMP   0x1899
    1857: 3C 4C 00 CMP   [main.h:snpRunScaler+6],0x0
    185A: B0 0D    JNZ   0x1868
    185C: 10       PUSH  X
    185D: 50 0C    MOV   A,0xC
    185F: 7C 0C 27 LCALL _CYFISNP_ForceState
    1862: 20       POP   X
    1863: 9F 33    CALL  0x1798
    1865: 55 4C 01 MOV   [main.h:snpRunScaler+6],0x1
    1868: 10       PUSH  X
    1869: 7C 0B 60 LCALL _CYFISNP_GetReceiveState
    186C: 20       POP   X
    186D: 53 62    MOV   [main.h:snpRunScaler+28],A
    186F: 47 62 02 TST   [main.h:snpRunScaler+28],0x2
    1872: A0 26    JZ    0x1899
    1874: 10       PUSH  X
    1875: 7C 0B A6 LCALL _CYFISNP_EndReceive
    1878: 20       POP   X
    1879: 53 61    MOV   [main.h:snpRunScaler+27],A
    187B: 47 62 01 TST   [main.h:snpRunScaler+28],0x1
    187E: A0 16    JZ    0x1895
    1880: 10       PUSH  X
    1881: 50 08    MOV   A,0x8
    1883: 7C 0A 09 LCALL _CYFISNP_Read
    1886: 20       POP   X
    1887: 54 00    MOV   [X+0],A
    1889: 27 00 70 AND   [X+0],0x70
    188C: 3D 00 10 CMP   [X+0],0x10
    188F: B0 07    JNZ   0x1897
    1891: 90 62    CALL  0x18F5
    1893: 80 03    JMP   0x1897
    1895: 90 05    CALL  0x189C
    1897: 9E FF    CALL  0x1798
    1899: 20       POP   X
    189A: 20       POP   X
    189B: 7F       RET   
    189C: 10       PUSH  X
    189D: 4F       MOV   X,SP
    189E: 38 03    ADD   SP,0x3
    18A0: 51 70    MOV   A,[CYFISNP_radioTxConfig+4]
    18A2: 54 00    MOV   [X+0],A
    18A4: 3C 61 02 CMP   [main.h:snpRunScaler+27],0x2
    18A7: B0 0A    JNZ   0x18B2
    18A9: 3D 00 10 CMP   [X+0],0x10
    18AC: B0 05    JNZ   0x18B2
    18AE: 93 8C    CALL  _CYFISNP_Unbind
    18B0: 80 40    JMP   0x18F1
    18B2: 3C 61 00 CMP   [main.h:snpRunScaler+27],0x0
    18B5: A0 3B    JZ    0x18F1
    18B7: 52 00    MOV   A,[X+0]
    18B9: 21 FC    AND   A,0xFC
    18BB: 39 30    CMP   A,0x30
    18BD: B0 33    JNZ   0x18F1
    18BF: 51 61    MOV   A,[main.h:snpRunScaler+27]
    18C1: 11 01    SUB   A,0x1
    18C3: 53 6D    MOV   [CYFISNP_radioTxConfig+1],A
    18C5: 10       PUSH  X
    18C6: 7C 0C 73 LCALL _CYFISNP_GetRssi
    18C9: 20       POP   X
    18CA: 21 1F    AND   A,0x1F
    18CC: 53 6E    MOV   [CYFISNP_radioTxConfig+2],A
    18CE: 3D 00 32 CMP   [X+0],0x32
    18D1: B0 09    JNZ   0x18DB
    18D3: 56 02 30 MOV   [X+2],0x30
    18D6: 56 01 00 MOV   [X+1],0x0
    18D9: 80 07    JMP   0x18E1
    18DB: 56 02 10 MOV   [X+2],0x10
    18DE: 56 01 00 MOV   [X+1],0x0
    18E1: 52 02    MOV   A,[X+2]
    18E3: 53 6F    MOV   [CYFISNP_radioTxConfig+3],A
    18E5: 50 3F    MOV   A,0x3F
    18E7: 10       PUSH  X
    18E8: 57 C5    MOV   X,0xC5
    18EA: 28       ROMX  
    18EB: 20       POP   X
    18EC: 53 70    MOV   [CYFISNP_radioTxConfig+4],A
    18EE: 55 63 01 MOV   [main.h:snpRunScaler+29],0x1
    18F1: 38 FD    ADD   SP,0xFD
    18F3: 20       POP   X
    18F4: 7F       RET   
    18F5: 50 00    MOV   A,0x0
    18F7: 08       PUSH  A
    18F8: 50 BB    MOV   A,0xBB
    18FA: 08       PUSH  A
    18FB: 50 00    MOV   A,0x0
    18FD: 08       PUSH  A
    18FE: 50 4D    MOV   A,0x4D
    1900: 08       PUSH  A
    1901: 7C 11 C7 LCALL _CYFISNP_TimeSet
    1904: 38 FC    ADD   SP,0xFC
    1906: 7F       RET   
    1907: 16 5F 01 SUB   [main.h:snpRunScaler+25],0x1
    190A: 3C 5F 00 CMP   [main.h:snpRunScaler+25],0x0
    190D: B0 03    JNZ   0x1911
    190F: 91 38    CALL  0x1A49
    1911: 99 33    CALL  0x1246
    1913: 93 F6    CALL  0x1D0B
    1915: 51 5E    MOV   A,[main.h:snpRunScaler+24]
    1917: 01 02    ADD   A,0x2
    1919: 53 0E    MOV   [__r1],A
    191B: 3E 0E    MVI   A,[__r1]
    191D: 53 0F    MOV   [__r0],A
    191F: 47 0F 04 TST   [__r0],0x4
    1922: B0 0F    JNZ   0x1932
    1924: 3C 60 00 CMP   [main.h:snpRunScaler+26],0x0
    1927: B0 0A    JNZ   0x1932
    1929: 10       PUSH  X
    192A: 50 04    MOV   A,0x4
    192C: 7C 0C 27 LCALL _CYFISNP_ForceState
    192F: 20       POP   X
    1930: 80 08    JMP   0x1939
    1932: 10       PUSH  X
    1933: 50 08    MOV   A,0x8
    1935: 7C 0C 27 LCALL _CYFISNP_ForceState
    1938: 20       POP   X
    1939: 51 5E    MOV   A,[main.h:snpRunScaler+24]
    193B: 01 02    ADD   A,0x2
    193D: 53 0E    MOV   [__r1],A
    193F: 51 5D    MOV   A,[main.h:snpRunScaler+23]
    1941: 09 00    ADC   A,0x0
    1943: 10       PUSH  X
    1944: 58 0E    MOV   X,[__r1]
    1946: 7C 0A 45 LCALL _CYFISNP_SetPtr
    1949: 20       POP   X
    194A: 5F 0E 5E MOV   [__r1],[main.h:snpRunScaler+24]
    194D: 3E 0E    MVI   A,[__r1]
    194F: 01 02    ADD   A,0x2
    1951: 10       PUSH  X
    1952: 08       PUSH  A
    1953: 50 00    MOV   A,0x0
    1955: 20       POP   X
    1956: 7C 0A 7E LCALL _CYFISNP_StartTransmit
    1959: 20       POP   X
    195A: 80 06    JMP   0x1961
    195C: 10       PUSH  X
    195D: 7C 0A B8 LCALL _CYFISNP_GetTransmitState
    1960: 20       POP   X
    1961: 47 21 02 TST   [0x21],0x2
    1964: AF F7    JZ    0x195C
    1966: 5F 62 21 MOV   [main.h:snpRunScaler+28],[0x21]
    1969: 10       PUSH  X
    196A: 7C 0B 1F LCALL _CYFISNP_EndTransmit
    196D: 20       POP   X
    196E: 47 62 01 TST   [main.h:snpRunScaler+28],0x1
    1971: A0 16    JZ    0x1988
    1973: 50 00    MOV   A,0x0
    1975: 08       PUSH  A
    1976: 93 62    CALL  0x1CDA
    1978: 38 FF    ADD   SP,0xFF
    197A: 3C 60 00 CMP   [main.h:snpRunScaler+26],0x0
    197D: B0 BC    JNZ   0x1A3A
    197F: 10       PUSH  X
    1980: 50 81    MOV   A,0x81
    1982: 7C 0C 27 LCALL _CYFISNP_ForceState
    1985: 20       POP   X
    1986: 80 B3    JMP   0x1A3A
    1988: 50 08    MOV   A,0x8
    198A: 08       PUSH  A
    198B: 93 4D    CALL  0x1CDA
    198D: 38 FF    ADD   SP,0xFF
    198F: 55 5F 00 MOV   [main.h:snpRunScaler+25],0x0
    1992: 55 5C 00 MOV   [main.h:snpRunScaler+22],0x0
    1995: 51 5E    MOV   A,[main.h:snpRunScaler+24]
    1997: 01 02    ADD   A,0x2
    1999: 53 0E    MOV   [__r1],A
    199B: 3E 0E    MVI   A,[__r1]
    199D: 21 03    AND   A,0x3
    199F: 39 02    CMP   A,0x2
    19A1: D0 04    JNC   0x19A6
    19A3: 36 65 01 XOR   [main.h:snpRunScaler+31],0x1
    19A6: 51 5E    MOV   A,[main.h:snpRunScaler+24]
    19A8: 01 02    ADD   A,0x2
    19AA: 53 0E    MOV   [__r1],A
    19AC: 3E 0E    MVI   A,[__r1]
    19AE: 53 0F    MOV   [__r0],A
    19B0: 47 0F 04 TST   [__r0],0x4
    19B3: B0 0F    JNZ   0x19C3
    19B5: 3C 60 00 CMP   [main.h:snpRunScaler+26],0x0
    19B8: B0 81    JNZ   0x1A3A
    19BA: 10       PUSH  X
    19BB: 50 00    MOV   A,0x0
    19BD: 7C 0C 27 LCALL _CYFISNP_ForceState
    19C0: 20       POP   X
    19C1: 80 78    JMP   0x1A3A
    19C3: 50 00    MOV   A,0x0
    19C5: 08       PUSH  A
    19C6: 50 03    MOV   A,0x3
    19C8: 08       PUSH  A
    19C9: 50 00    MOV   A,0x0
    19CB: 08       PUSH  A
    19CC: 50 5A    MOV   A,0x5A
    19CE: 08       PUSH  A
    19CF: 7C 11 C7 LCALL _CYFISNP_TimeSet
    19D2: 38 FC    ADD   SP,0xFC
    19D4: 9D C2    CALL  0x1798
    19D6: 10       PUSH  X
    19D7: 7C 0B 60 LCALL _CYFISNP_GetReceiveState
    19DA: 20       POP   X
    19DB: 53 62    MOV   [main.h:snpRunScaler+28],A
    19DD: 50 00    MOV   A,0x0
    19DF: 08       PUSH  A
    19E0: 50 5A    MOV   A,0x5A
    19E2: 08       PUSH  A
    19E3: 7C 11 F5 LCALL _CYFISNP_TimeExpired
    19E6: 38 FE    ADD   SP,0xFE
    19E8: 39 00    CMP   A,0x0
    19EA: A0 1B    JZ    0x1A06
    19EC: 10       PUSH  X
    19ED: 7C 0B E5 LCALL _CYFISNP_Abort
    19F0: 20       POP   X
    19F1: 53 61    MOV   [main.h:snpRunScaler+27],A
    19F3: 3C 61 FF CMP   [main.h:snpRunScaler+27],0xFF
    19F6: B0 0F    JNZ   0x1A06
    19F8: 3C 60 00 CMP   [main.h:snpRunScaler+26],0x0
    19FB: B0 3C    JNZ   0x1A38
    19FD: 10       PUSH  X
    19FE: 50 00    MOV   A,0x0
    1A00: 7C 0C 27 LCALL _CYFISNP_ForceState
    1A03: 20       POP   X
    1A04: 80 33    JMP   0x1A38
    1A06: 47 62 01 TST   [main.h:snpRunScaler+28],0x1
    1A09: A0 14    JZ    0x1A1E
    1A0B: 10       PUSH  X
    1A0C: 7C 0B A6 LCALL _CYFISNP_EndReceive
    1A0F: 20       POP   X
    1A10: 3C 60 00 CMP   [main.h:snpRunScaler+26],0x0
    1A13: B0 24    JNZ   0x1A38
    1A15: 10       PUSH  X
    1A16: 50 00    MOV   A,0x0
    1A18: 7C 0C 27 LCALL _CYFISNP_ForceState
    1A1B: 20       POP   X
    1A1C: 80 1B    JMP   0x1A38
    1A1E: 47 62 02 TST   [main.h:snpRunScaler+28],0x2
    1A21: AF B4    JZ    0x19D6
    1A23: 10       PUSH  X
    1A24: 7C 0B A6 LCALL _CYFISNP_EndReceive
    1A27: 20       POP   X
    1A28: 53 61    MOV   [main.h:snpRunScaler+27],A
    1A2A: 3C 60 00 CMP   [main.h:snpRunScaler+26],0x0
    1A2D: B0 08    JNZ   0x1A36
    1A2F: 10       PUSH  X
    1A30: 50 00    MOV   A,0x0
    1A32: 7C 0C 27 LCALL _CYFISNP_ForceState
    1A35: 20       POP   X
    1A36: 9E 64    CALL  0x189C
    1A38: 98 0C    CALL  0x1246
    1A3A: 7F       RET   
_CYFISNP_RxDataPend:
    1A3B: 51 63    MOV   A,[main.h:snpRunScaler+29]
    1A3D: 7F       RET   
_CYFISNP_RxDataGet:
    1A3E: 55 0E 6D MOV   [__r1],0x6D
    1A41: 55 0F 00 MOV   [__r0],0x0
    1A44: 7F       RET   
_CYFISNP_RxDataRelease:
    1A45: 55 63 00 MOV   [main.h:snpRunScaler+29],0x0
    1A48: 7F       RET   
    1A49: 94 38    CALL  0x1E83
    1A4B: 55 82 30 MOV   [CYFISNP_eProtState],0x30
    1A4E: 55 57 C8 MOV   [main.h:snpRunScaler+17],0xC8
    1A51: 55 56 00 MOV   [main.h:snpRunScaler+16],0x0
    1A54: 50 00    MOV   A,0x0
    1A56: 08       PUSH  A
    1A57: 08       PUSH  A
    1A58: 50 00    MOV   A,0x0
    1A5A: 08       PUSH  A
    1A5B: 50 54    MOV   A,0x54
    1A5D: 08       PUSH  A
    1A5E: 7C 11 C7 LCALL _CYFISNP_TimeSet
    1A61: 38 FC    ADD   SP,0xFC
    1A63: 55 7A 00 MOV   [CYFISNP_radioTxConfig+14],0x0
    1A66: 50 3F    MOV   A,0x3F
    1A68: 10       PUSH  X
    1A69: 57 C5    MOV   X,0xC5
    1A6B: 28       ROMX  
    1A6C: 20       POP   X
    1A6D: 53 7B    MOV   [CYFISNP_radioTxConfig+15],A
    1A6F: 7F       RET   
    1A70: 50 00    MOV   A,0x0
    1A72: 08       PUSH  A
    1A73: 50 54    MOV   A,0x54
    1A75: 08       PUSH  A
    1A76: 7C 11 F5 LCALL _CYFISNP_TimeExpired
    1A79: 38 FE    ADD   SP,0xFE
    1A7B: 39 00    CMP   A,0x0
    1A7D: A0 8F    JZ    0x1B0D
    1A7F: 50 64    MOV   A,0x64
    1A81: 12 57    SUB   A,[main.h:snpRunScaler+17]
    1A83: 50 00    MOV   A,0x0
    1A85: 1A 56    SBB   A,[main.h:snpRunScaler+16]
    1A87: D0 12    JNC   0x1A9A
    1A89: 50 00    MOV   A,0x0
    1A8B: 08       PUSH  A
    1A8C: 08       PUSH  A
    1A8D: 50 00    MOV   A,0x0
    1A8F: 08       PUSH  A
    1A90: 50 54    MOV   A,0x54
    1A92: 08       PUSH  A
    1A93: 7C 11 C7 LCALL _CYFISNP_TimeSet
    1A96: 38 FC    ADD   SP,0xFC
    1A98: 80 12    JMP   0x1AAB
    1A9A: 50 00    MOV   A,0x0
    1A9C: 08       PUSH  A
    1A9D: 50 0C    MOV   A,0xC
    1A9F: 08       PUSH  A
    1AA0: 50 00    MOV   A,0x0
    1AA2: 08       PUSH  A
    1AA3: 50 54    MOV   A,0x54
    1AA5: 08       PUSH  A
    1AA6: 7C 11 C7 LCALL _CYFISNP_TimeSet
    1AA9: 38 FC    ADD   SP,0xFC
    1AAB: 5F 0E 57 MOV   [__r1],[main.h:snpRunScaler+17]
    1AAE: 5F 0F 56 MOV   [__r0],[main.h:snpRunScaler+16]
    1AB1: 51 0E    MOV   A,[__r1]
    1AB3: 11 01    SUB   A,0x1
    1AB5: 53 57    MOV   [main.h:snpRunScaler+17],A
    1AB7: 51 0F    MOV   A,[__r0]
    1AB9: 19 00    SBB   A,0x0
    1ABB: 53 56    MOV   [main.h:snpRunScaler+16],A
    1ABD: 3C 0F 00 CMP   [__r0],0x0
    1AC0: B0 0D    JNZ   0x1ACE
    1AC2: 3C 0E 00 CMP   [__r1],0x0
    1AC5: B0 08    JNZ   0x1ACE
    1AC7: 55 82 21 MOV   [CYFISNP_eProtState],0x21
    1ACA: 94 10    CALL  _CYFISNP_spiSleep
    1ACC: 80 40    JMP   0x1B0D
    1ACE: 90 3E    CALL  0x1B0E
    1AD0: 10       PUSH  X
    1AD1: 51 81    MOV   A,[CYFISNP_bCurrentChannel]
    1AD3: 7C 08 C9 LCALL _CYFISNP_SetChannel
    1AD6: 20       POP   X
    1AD7: 7C 12 46 LCALL 0x1246
    1ADA: 10       PUSH  X
    1ADB: 50 85    MOV   A,0x85
    1ADD: 7C 08 E7 LCALL _CYFISNP_SetXactConfig
    1AE0: 50 00    MOV   A,0x0
    1AE2: 57 7A    MOV   X,0x7A
    1AE4: 7C 0A 45 LCALL _CYFISNP_SetPtr
    1AE7: 57 02    MOV   X,0x2
    1AE9: 50 00    MOV   A,0x0
    1AEB: 7C 0A 7E LCALL _CYFISNP_StartTransmit
    1AEE: 20       POP   X
    1AEF: 80 06    JMP   0x1AF6
    1AF1: 10       PUSH  X
    1AF2: 7C 0A B8 LCALL _CYFISNP_GetTransmitState
    1AF5: 20       POP   X
    1AF6: 47 21 02 TST   [0x21],0x2
    1AF9: AF F7    JZ    0x1AF1
    1AFB: 5F 62 21 MOV   [main.h:snpRunScaler+28],[0x21]
    1AFE: 10       PUSH  X
    1AFF: 7C 0B 1F LCALL _CYFISNP_EndTransmit
    1B02: 20       POP   X
    1B03: 47 62 01 TST   [main.h:snpRunScaler+28],0x1
    1B06: B0 06    JNZ   0x1B0D
    1B08: 7C 12 46 LCALL 0x1246
    1B0B: 9C 58    CALL  0x1765
    1B0D: 7F       RET   
    1B0E: 10       PUSH  X
    1B0F: 4F       MOV   X,SP
    1B10: 10       PUSH  X
    1B11: 50 3F    MOV   A,0x3F
    1B13: 10       PUSH  X
    1B14: 57 C2    MOV   X,0xC2
    1B16: 28       ROMX  
    1B17: 20       POP   X
    1B18: 01 01    ADD   A,0x1
    1B1A: 54 00    MOV   [X+0],A
    1B1C: 52 00    MOV   A,[X+0]
    1B1E: 64       ASL   A
    1B1F: 64       ASL   A
    1B20: 53 0F    MOV   [__r0],A
    1B22: 52 00    MOV   A,[X+0]
    1B24: 64       ASL   A
    1B25: 53 0D    MOV   [__r2],A
    1B27: 51 0F    MOV   A,[__r0]
    1B29: 02 0D    ADD   A,[__r2]
    1B2B: 54 00    MOV   [X+0],A
    1B2D: 52 00    MOV   A,[X+0]
    1B2F: 04 81    ADD   [CYFISNP_bCurrentChannel],A
    1B31: 50 3A    MOV   A,0x3A
    1B33: 3A 81    CMP   A,[CYFISNP_bCurrentChannel]
    1B35: D0 0A    JNC   0x1B40
    1B37: 16 81 4E SUB   [CYFISNP_bCurrentChannel],0x4E
    1B3A: 80 05    JMP   0x1B40
    1B3C: 52 00    MOV   A,[X+0]
    1B3E: 04 81    ADD   [CYFISNP_bCurrentChannel],A
    1B40: 50 0A    MOV   A,0xA
    1B42: 3A 81    CMP   A,[CYFISNP_bCurrentChannel]
    1B44: A0 09    JZ    0x1B4E
    1B46: 6D       RRC   A
    1B47: 32 81    XOR   A,[CYFISNP_bCurrentChannel]
    1B49: 31 0A    XOR   A,0xA
    1B4B: 6A       RLC   A
    1B4C: DF EF    JNC   0x1B3C
    1B4E: 20       POP   X
    1B4F: 20       POP   X
    1B50: 7F       RET   
    1B51: 10       PUSH  X
    1B52: 4F       MOV   X,SP
    1B53: 38 0B    ADD   SP,0xB
    1B55: 5A 0E    MOV   [__r1],X
    1B57: 06 0E 03 ADD   [__r1],0x3
    1B5A: 10       PUSH  X
    1B5B: 51 0F    MOV   A,[__r0]
    1B5D: 58 0E    MOV   X,[__r1]
    1B5F: 7C 0A 45 LCALL _CYFISNP_SetPtr
    1B62: 50 04    MOV   A,0x4
    1B64: 7C 0A 48 LCALL _CYFISNP_SetLength
    1B67: 7C 09 67 LCALL _CYFISNP_GetFuses
    1B6A: 20       POP   X
    1B6B: 5A 0F    MOV   [__r0],X
    1B6D: 06 0F 03 ADD   [__r0],0x3
    1B70: 51 0F    MOV   A,[__r0]
    1B72: 54 02    MOV   [X+2],A
    1B74: 56 00 04 MOV   [X+0],0x4
    1B77: 80 0D    JMP   0x1B85
    1B79: 77 02    INC   [X+2]
    1B7B: 0F 01 00 ADC   [X+1],0x0
    1B7E: 77 FC    INC   [X-4]
    1B80: 0F FB 00 ADC   [X-5],0x0
    1B83: 7B 00    DEC   [X+0]
    1B85: 52 FC    MOV   A,[X-4]
    1B87: 53 0E    MOV   [__r1],A
    1B89: 3E 0E    MVI   A,[__r1]
    1B8B: 53 0F    MOV   [__r0],A
    1B8D: 52 02    MOV   A,[X+2]
    1B8F: 53 0C    MOV   [__r3],A
    1B91: 3E 0C    MVI   A,[__r3]
    1B93: 3A 0F    CMP   A,[__r0]
    1B95: B0 06    JNZ   0x1B9C
    1B97: 3D 00 00 CMP   [X+0],0x0
    1B9A: BF DE    JNZ   0x1B79
    1B9C: 3D 00 00 CMP   [X+0],0x0
    1B9F: B0 09    JNZ   0x1BA9
    1BA1: 56 0A 01 MOV   [X+10],0x1
    1BA4: 56 09 00 MOV   [X+9],0x0
    1BA7: 80 07    JMP   0x1BAF
    1BA9: 56 0A 00 MOV   [X+10],0x0
    1BAC: 56 09 00 MOV   [X+9],0x0
    1BAF: 52 0A    MOV   A,[X+10]
    1BB1: 38 F5    ADD   SP,0xF5
    1BB3: 20       POP   X
    1BB4: 7F       RET   
    1BB5: 10       PUSH  X
    1BB6: 50 00    MOV   A,0x0
    1BB8: 57 7C    MOV   X,0x7C
    1BBA: 7C 0A 45 LCALL _CYFISNP_SetPtr
    1BBD: 50 04    MOV   A,0x4
    1BBF: 7C 0A 48 LCALL _CYFISNP_SetLength
    1BC2: 7C 09 67 LCALL _CYFISNP_GetFuses
    1BC5: 20       POP   X
    1BC6: 7F       RET   
    1BC7: 10       PUSH  X
    1BC8: 4F       MOV   X,SP
    1BC9: 38 08    ADD   SP,0x8
    1BCB: 52 FC    MOV   A,[X-4]
    1BCD: 01 01    ADD   A,0x1
    1BCF: 53 0E    MOV   [__r1],A
    1BD1: 3E 0E    MVI   A,[__r1]
    1BD3: 54 05    MOV   [X+5],A
    1BD5: 52 FC    MOV   A,[X-4]
    1BD7: 01 06    ADD   A,0x6
    1BD9: 53 0E    MOV   [__r1],A
    1BDB: 3E 0E    MVI   A,[__r1]
    1BDD: 54 03    MOV   [X+3],A
    1BDF: 52 FC    MOV   A,[X-4]
    1BE1: 01 07    ADD   A,0x7
    1BE3: 53 0E    MOV   [__r1],A
    1BE5: 3E 0E    MVI   A,[__r1]
    1BE7: 54 04    MOV   [X+4],A
    1BE9: 52 FC    MOV   A,[X-4]
    1BEB: 01 09    ADD   A,0x9
    1BED: 53 0E    MOV   [__r1],A
    1BEF: 3E 0E    MVI   A,[__r1]
    1BF1: 67       ASR   A
    1BF2: 67       ASR   A
    1BF3: 67       ASR   A
    1BF4: 21 1F    AND   A,0x1F
    1BF6: 54 00    MOV   [X+0],A
    1BF8: 52 FC    MOV   A,[X-4]
    1BFA: 01 09    ADD   A,0x9
    1BFC: 53 0E    MOV   [__r1],A
    1BFE: 3E 0E    MVI   A,[__r1]
    1C00: 21 07    AND   A,0x7
    1C02: 54 02    MOV   [X+2],A
    1C04: 52 FC    MOV   A,[X-4]
    1C06: 01 08    ADD   A,0x8
    1C08: 53 0E    MOV   [__r1],A
    1C0A: 3E 0E    MVI   A,[__r1]
    1C0C: 54 01    MOV   [X+1],A
    1C0E: 52 FC    MOV   A,[X-4]
    1C10: 01 06    ADD   A,0x6
    1C12: 53 0E    MOV   [__r1],A
    1C14: 3E 0E    MVI   A,[__r1]
    1C16: 54 06    MOV   [X+6],A
    1C18: 52 FC    MOV   A,[X-4]
    1C1A: 01 01    ADD   A,0x1
    1C1C: 53 0E    MOV   [__r1],A
    1C1E: 3E 0E    MVI   A,[__r1]
    1C20: 53 0F    MOV   [__r0],A
    1C22: 52 FC    MOV   A,[X-4]
    1C24: 01 07    ADD   A,0x7
    1C26: 53 0C    MOV   [__r3],A
    1C28: 3E 0C    MVI   A,[__r3]
    1C2A: 53 0D    MOV   [__r2],A
    1C2C: 51 0F    MOV   A,[__r0]
    1C2E: 32 0D    XOR   A,[__r2]
    1C30: 54 07    MOV   [X+7],A
    1C32: 08       PUSH  A
    1C33: 10       PUSH  X
    1C34: 90 34    CALL  0x1C6A
    1C36: 38 FE    ADD   SP,0xFE
    1C38: 38 F8    ADD   SP,0xF8
    1C3A: 20       POP   X
    1C3B: 7F       RET   
_CYFISNP_Unbind:
    1C3C: 10       PUSH  X
    1C3D: 4F       MOV   X,SP
    1C3E: 38 08    ADD   SP,0x8
    1C40: 56 05 00 MOV   [X+5],0x0
    1C43: 56 03 00 MOV   [X+3],0x0
    1C46: 56 04 00 MOV   [X+4],0x0
    1C49: 56 00 00 MOV   [X+0],0x0
    1C4C: 56 02 00 MOV   [X+2],0x0
    1C4F: 56 01 00 MOV   [X+1],0x0
    1C52: 56 06 00 MOV   [X+6],0x0
    1C55: 56 07 00 MOV   [X+7],0x0
    1C58: 51 0F    MOV   A,[__r0]
    1C5A: 08       PUSH  A
    1C5B: 10       PUSH  X
    1C5C: 90 0C    CALL  0x1C6A
    1C5E: 38 FE    ADD   SP,0xFE
    1C60: 7C 13 36 LCALL 0x1336
    1C63: 38 F8    ADD   SP,0xF8
    1C65: 20       POP   X
    1C66: 7F       RET   
_CYFISNP_GetDieTemp:
    1C67: 50 14    MOV   A,0x14
    1C69: 7F       RET   
    1C6A: 10       PUSH  X
    1C6B: 4F       MOV   X,SP
    1C6C: 38 07    ADD   SP,0x7
    1C6E: 52 FC    MOV   A,[X-4]
    1C70: 54 04    MOV   [X+4],A
    1C72: 56 02 C0 MOV   [X+2],0xC0
    1C75: 56 01 3F MOV   [X+1],0x3F
    1C78: 56 00 08 MOV   [X+0],0x8
    1C7B: 80 03    JMP   0x1C7F
    1C7D: 7B 00    DEC   [X+0]
    1C7F: 3D 00 00 CMP   [X+0],0x0
    1C82: A0 38    JZ    0x1CBB
    1C84: 52 04    MOV   A,[X+4]
    1C86: 53 0E    MOV   [__r1],A
    1C88: 52 03    MOV   A,[X+3]
    1C8A: 53 0F    MOV   [__r0],A
    1C8C: 51 0E    MOV   A,[__r1]
    1C8E: 01 01    ADD   A,0x1
    1C90: 54 04    MOV   [X+4],A
    1C92: 51 0F    MOV   A,[__r0]
    1C94: 09 00    ADC   A,0x0
    1C96: 54 03    MOV   [X+3],A
    1C98: 52 02    MOV   A,[X+2]
    1C9A: 53 0C    MOV   [__r3],A
    1C9C: 52 01    MOV   A,[X+1]
    1C9E: 53 0D    MOV   [__r2],A
    1CA0: 51 0C    MOV   A,[__r3]
    1CA2: 01 01    ADD   A,0x1
    1CA4: 54 02    MOV   [X+2],A
    1CA6: 51 0D    MOV   A,[__r2]
    1CA8: 09 00    ADC   A,0x0
    1CAA: 54 01    MOV   [X+1],A
    1CAC: 51 0D    MOV   A,[__r2]
    1CAE: 10       PUSH  X
    1CAF: 58 0C    MOV   X,[__r3]
    1CB1: 28       ROMX  
    1CB2: 20       POP   X
    1CB3: 53 0D    MOV   [__r2],A
    1CB5: 3E 0E    MVI   A,[__r1]
    1CB7: 3A 0D    CMP   A,[__r2]
    1CB9: AF C3    JZ    0x1C7D
    1CBB: 3D 00 00 CMP   [X+0],0x0
    1CBE: A0 17    JZ    0x1CD6
    1CC0: 56 00 FF MOV   [X+0],0xFF
    1CC3: 52 FC    MOV   A,[X-4]
    1CC5: 54 02    MOV   [X+2],A
    1CC7: 9F 9E    CALL  _CYFISNP_GetDieTemp
    1CC9: 54 03    MOV   [X+3],A
    1CCB: 10       PUSH  X
    1CCC: 7C 0C 7A LCALL _bFlashWriteBlock
    1CCF: 20       POP   X
    1CD0: 39 00    CMP   A,0x0
    1CD2: B0 03    JNZ   0x1CD6
    1CD4: 8F FF    JMP   0x1CD4
    1CD6: 38 F9    ADD   SP,0xF9
    1CD8: 20       POP   X
    1CD9: 7F       RET   
    1CDA: 10       PUSH  X
    1CDB: 4F       MOV   X,SP
    1CDC: 47 6C 18 TST   [CYFISNP_radioTxConfig],0x18
    1CDF: B0 16    JNZ   0x1CF6
    1CE1: 51 6A    MOV   A,[main.h:snpRunScaler+36]
    1CE3: 01 07    ADD   A,0x7
    1CE5: 67       ASR   A
    1CE6: 67       ASR   A
    1CE7: 67       ASR   A
    1CE8: 21 1F    AND   A,0x1F
    1CEA: 53 0F    MOV   [__r0],A
    1CEC: 51 6A    MOV   A,[main.h:snpRunScaler+36]
    1CEE: 03 FC    ADD   A,[X-4]
    1CF0: 12 0F    SUB   A,[__r0]
    1CF2: 53 6A    MOV   [main.h:snpRunScaler+36],A
    1CF4: 80 14    JMP   0x1D09
    1CF6: 51 69    MOV   A,[main.h:snpRunScaler+35]
    1CF8: 01 07    ADD   A,0x7
    1CFA: 67       ASR   A
    1CFB: 67       ASR   A
    1CFC: 67       ASR   A
    1CFD: 21 1F    AND   A,0x1F
    1CFF: 53 0F    MOV   [__r0],A
    1D01: 51 69    MOV   A,[main.h:snpRunScaler+35]
    1D03: 03 FC    ADD   A,[X-4]
    1D05: 12 0F    SUB   A,[__r0]
    1D07: 53 69    MOV   [main.h:snpRunScaler+35],A
    1D09: 20       POP   X
    1D0A: 7F       RET   
    1D0B: 10       PUSH  X
    1D0C: 4F       MOV   X,SP
    1D0D: 38 02    ADD   SP,0x2
    1D0F: 3C 6A 39 CMP   [main.h:snpRunScaler+36],0x39
    1D12: B0 21    JNZ   0x1D34
    1D14: 3C 68 08 CMP   [main.h:snpRunScaler+34],0x8
    1D17: D0 0F    JNC   0x1D27
    1D19: 51 68    MOV   A,[main.h:snpRunScaler+34]
    1D1B: 01 01    ADD   A,0x1
    1D1D: 54 01    MOV   [X+1],A
    1D1F: 50 00    MOV   A,0x0
    1D21: 09 00    ADC   A,0x0
    1D23: 54 00    MOV   [X+0],A
    1D25: 80 08    JMP   0x1D2E
    1D27: 51 68    MOV   A,[main.h:snpRunScaler+34]
    1D29: 54 01    MOV   [X+1],A
    1D2B: 56 00 00 MOV   [X+0],0x0
    1D2E: 52 01    MOV   A,[X+1]
    1D30: 53 68    MOV   [main.h:snpRunScaler+34],A
    1D32: 80 04    JMP   0x1D37
    1D34: 55 68 00 MOV   [main.h:snpRunScaler+34],0x0
    1D37: 3C 69 39 CMP   [main.h:snpRunScaler+35],0x39
    1D3A: B0 21    JNZ   0x1D5C
    1D3C: 3C 67 08 CMP   [main.h:snpRunScaler+33],0x8
    1D3F: D0 0F    JNC   0x1D4F
    1D41: 51 67    MOV   A,[main.h:snpRunScaler+33]
    1D43: 01 01    ADD   A,0x1
    1D45: 54 01    MOV   [X+1],A
    1D47: 50 00    MOV   A,0x0
    1D49: 09 00    ADC   A,0x0
    1D4B: 54 00    MOV   [X+0],A
    1D4D: 80 08    JMP   0x1D56
    1D4F: 51 67    MOV   A,[main.h:snpRunScaler+33]
    1D51: 54 01    MOV   [X+1],A
    1D53: 56 00 00 MOV   [X+0],0x0
    1D56: 52 01    MOV   A,[X+1]
    1D58: 53 67    MOV   [main.h:snpRunScaler+33],A
    1D5A: 80 04    JMP   0x1D5F
    1D5C: 55 67 00 MOV   [main.h:snpRunScaler+33],0x0
    1D5F: 3C 6A 39 CMP   [main.h:snpRunScaler+36],0x39
    1D62: B0 1A    JNZ   0x1D7D
    1D64: 3C 68 08 CMP   [main.h:snpRunScaler+34],0x8
    1D67: B0 15    JNZ   0x1D7D
    1D69: 3C 69 39 CMP   [main.h:snpRunScaler+35],0x39
    1D6C: B0 10    JNZ   0x1D7D
    1D6E: 3C 67 08 CMP   [main.h:snpRunScaler+33],0x8
    1D71: B0 0B    JNZ   0x1D7D
    1D73: 91 37    CALL  0x1EAC
    1D75: 55 67 00 MOV   [main.h:snpRunScaler+33],0x0
    1D78: 55 68 00 MOV   [main.h:snpRunScaler+34],0x0
    1D7B: 80 4B    JMP   0x1DC7
    1D7D: 50 42    MOV   A,0x42
    1D7F: 08       PUSH  A
    1D80: 50 1F    MOV   A,0x1F
    1D82: 08       PUSH  A
    1D83: 50 99    MOV   A,0x99
    1D85: 08       PUSH  A
    1D86: 50 9A    MOV   A,0x9A
    1D88: 08       PUSH  A
    1D89: 50 00    MOV   A,0x0
    1D8B: 08       PUSH  A
    1D8C: 08       PUSH  A
    1D8D: 08       PUSH  A
    1D8E: 51 6A    MOV   A,[main.h:snpRunScaler+36]
    1D90: 08       PUSH  A
    1D91: 7C 1F F7 LCALL 0x1FF7
    1D94: 7C 1F 91 LCALL 0x1F91
    1D97: 38 F8    ADD   SP,0xF8
    1D99: 39 00    CMP   A,0x0
    1D9B: A0 2B    JZ    0x1DC7
    1D9D: 39 01    CMP   A,0x1
    1D9F: A0 27    JZ    0x1DC7
    1DA1: 50 42    MOV   A,0x42
    1DA3: 08       PUSH  A
    1DA4: 50 1F    MOV   A,0x1F
    1DA6: 08       PUSH  A
    1DA7: 50 99    MOV   A,0x99
    1DA9: 08       PUSH  A
    1DAA: 50 9A    MOV   A,0x9A
    1DAC: 08       PUSH  A
    1DAD: 50 00    MOV   A,0x0
    1DAF: 08       PUSH  A
    1DB0: 08       PUSH  A
    1DB1: 08       PUSH  A
    1DB2: 51 69    MOV   A,[main.h:snpRunScaler+35]
    1DB4: 08       PUSH  A
    1DB5: 7C 1F F7 LCALL 0x1FF7
    1DB8: 7C 1F 91 LCALL 0x1F91
    1DBB: 38 F8    ADD   SP,0xF8
    1DBD: 39 00    CMP   A,0x0
    1DBF: A0 07    JZ    0x1DC7
    1DC1: 39 01    CMP   A,0x1
    1DC3: A0 03    JZ    0x1DC7
    1DC5: 90 BC    CALL  0x1E83
    1DC7: 16 66 01 SUB   [main.h:snpRunScaler+32],0x1
    1DCA: 3C 66 00 CMP   [main.h:snpRunScaler+32],0x0
    1DCD: B0 8C    JNZ   0x1E5A
    1DCF: 90 8D    CALL  0x1E5E
    1DD1: 50 42    MOV   A,0x42
    1DD3: 08       PUSH  A
    1DD4: 50 1F    MOV   A,0x1F
    1DD6: 08       PUSH  A
    1DD7: 50 99    MOV   A,0x99
    1DD9: 08       PUSH  A
    1DDA: 50 9A    MOV   A,0x9A
    1DDC: 08       PUSH  A
    1DDD: 50 00    MOV   A,0x0
    1DDF: 08       PUSH  A
    1DE0: 08       PUSH  A
    1DE1: 08       PUSH  A
    1DE2: 51 6A    MOV   A,[main.h:snpRunScaler+36]
    1DE4: 08       PUSH  A
    1DE5: 7C 1F F7 LCALL 0x1FF7
    1DE8: 7C 1F 91 LCALL 0x1F91
    1DEB: 38 F8    ADD   SP,0xF8
    1DED: 39 FF    CMP   A,0xFF
    1DEF: A0 1A    JZ    0x1E0A
    1DF1: 47 6C 18 TST   [CYFISNP_radioTxConfig],0x18
    1DF4: B0 09    JNZ   0x1DFE
    1DF6: 56 01 04 MOV   [X+1],0x4
    1DF9: 56 00 00 MOV   [X+0],0x0
    1DFC: 80 07    JMP   0x1E04
    1DFE: 56 01 01 MOV   [X+1],0x1
    1E01: 56 00 00 MOV   [X+0],0x0
    1E04: 52 01    MOV   A,[X+1]
    1E06: 53 66    MOV   [main.h:snpRunScaler+32],A
    1E08: 80 51    JMP   0x1E5A
    1E0A: 50 42    MOV   A,0x42
    1E0C: 08       PUSH  A
    1E0D: 50 1F    MOV   A,0x1F
    1E0F: 08       PUSH  A
    1E10: 50 99    MOV   A,0x99
    1E12: 08       PUSH  A
    1E13: 50 9A    MOV   A,0x9A
    1E15: 08       PUSH  A
    1E16: 50 00    MOV   A,0x0
    1E18: 08       PUSH  A
    1E19: 08       PUSH  A
    1E1A: 08       PUSH  A
    1E1B: 51 69    MOV   A,[main.h:snpRunScaler+35]
    1E1D: 08       PUSH  A
    1E1E: 7C 1F F7 LCALL 0x1FF7
    1E21: 7C 1F 91 LCALL 0x1F91
    1E24: 38 F8    ADD   SP,0xF8
    1E26: 39 FF    CMP   A,0xFF
    1E28: A0 1A    JZ    0x1E43
    1E2A: 47 6C 18 TST   [CYFISNP_radioTxConfig],0x18
    1E2D: B0 09    JNZ   0x1E37
    1E2F: 56 01 01 MOV   [X+1],0x1
    1E32: 56 00 00 MOV   [X+0],0x0
    1E35: 80 07    JMP   0x1E3D
    1E37: 56 01 04 MOV   [X+1],0x4
    1E3A: 56 00 00 MOV   [X+0],0x0
    1E3D: 52 01    MOV   A,[X+1]
    1E3F: 53 66    MOV   [main.h:snpRunScaler+32],A
    1E41: 80 18    JMP   0x1E5A
    1E43: 47 6C 18 TST   [CYFISNP_radioTxConfig],0x18
    1E46: B0 09    JNZ   0x1E50
    1E48: 56 01 01 MOV   [X+1],0x1
    1E4B: 56 00 00 MOV   [X+0],0x0
    1E4E: 80 07    JMP   0x1E56
    1E50: 56 01 01 MOV   [X+1],0x1
    1E53: 56 00 00 MOV   [X+0],0x0
    1E56: 52 01    MOV   A,[X+1]
    1E58: 53 66    MOV   [main.h:snpRunScaler+32],A
    1E5A: 38 FE    ADD   SP,0xFE
    1E5C: 20       POP   X
    1E5D: 7F       RET   
    1E5E: 47 6C 18 TST   [CYFISNP_radioTxConfig],0x18
    1E61: B0 12    JNZ   0x1E74
    1E63: 26 6C E7 AND   [CYFISNP_radioTxConfig],0xE7
    1E66: 2E 6C 08 OR    [CYFISNP_radioTxConfig],0x8
    1E69: 10       PUSH  X
    1E6A: 57 00    MOV   X,0x0
    1E6C: 50 39    MOV   A,0x39
    1E6E: 7C 0A 07 LCALL _CYFISNP_Write
    1E71: 20       POP   X
    1E72: 80 0D    JMP   0x1E80
    1E74: 26 6C E7 AND   [CYFISNP_radioTxConfig],0xE7
    1E77: 10       PUSH  X
    1E78: 57 01    MOV   X,0x1
    1E7A: 50 39    MOV   A,0x39
    1E7C: 7C 0A 07 LCALL _CYFISNP_Write
    1E7F: 20       POP   X
    1E80: 90 34    CALL  0x1EB6
    1E82: 7F       RET   
    1E83: 50 07    MOV   A,0x7
    1E85: 08       PUSH  A
    1E86: 90 0B    CALL  0x1E93
    1E88: 38 FF    ADD   SP,0xFF
    1E8A: 7F       RET   
    1E8B: 50 06    MOV   A,0x6
    1E8D: 08       PUSH  A
    1E8E: 90 03    CALL  0x1E93
    1E90: 38 FF    ADD   SP,0xFF
    1E92: 7F       RET   
    1E93: 10       PUSH  X
    1E94: 4F       MOV   X,SP
    1E95: 52 FC    MOV   A,[X-4]
    1E97: 53 6B    MOV   [CYFISNP_paLevel],A
    1E99: 90 1B    CALL  0x1EB6
    1E9B: 55 6A 39 MOV   [main.h:snpRunScaler+36],0x39
    1E9E: 55 69 39 MOV   [main.h:snpRunScaler+35],0x39
    1EA1: 55 68 00 MOV   [main.h:snpRunScaler+34],0x0
    1EA4: 55 67 00 MOV   [main.h:snpRunScaler+33],0x0
    1EA7: 55 66 01 MOV   [main.h:snpRunScaler+32],0x1
    1EAA: 20       POP   X
    1EAB: 7F       RET   
    1EAC: 3C 6B 00 CMP   [CYFISNP_paLevel],0x0
    1EAF: A0 05    JZ    0x1EB5
    1EB1: 7A 6B    DEC   [CYFISNP_paLevel]
    1EB3: 90 01    CALL  0x1EB6
    1EB5: 7F       RET   
    1EB6: 10       PUSH  X
    1EB7: 4F       MOV   X,SP
    1EB8: 10       PUSH  X
    1EB9: 5F 0E 6B MOV   [__r1],[CYFISNP_paLevel]
    1EBC: 55 0F 00 MOV   [__r0],0x0
    1EBF: 06 0E C0 ADD   [__r1],0xC0
    1EC2: 0E 0F 01 ADC   [__r0],0x1
    1EC5: 51 0F    MOV   A,[__r0]
    1EC7: 10       PUSH  X
    1EC8: 58 0E    MOV   X,[__r1]
    1ECA: 28       ROMX  
    1ECB: 20       POP   X
    1ECC: 21 07    AND   A,0x7
    1ECE: 54 00    MOV   [X+0],A
    1ED0: 51 6C    MOV   A,[CYFISNP_radioTxConfig]
    1ED2: 03 00    ADD   A,[X+0]
    1ED4: 10       PUSH  X
    1ED5: 7C 08 DF LCALL _CYFISNP_SetTxConfig
    1ED8: 20       POP   X
    1ED9: 20       POP   X
    1EDA: 20       POP   X
    1EDB: 7F       RET   
_CYFISNP_spiSleep:
    1EDC: 3C 47 01 CMP   [main.h:snpRunScaler+1],0x1
    1EDF: A0 4C    JZ    0x1F2C
    1EE1: 55 47 01 MOV   [main.h:snpRunScaler+1],0x1
    1EE4: 10       PUSH  X
    1EE5: 50 0C    MOV   A,0xC
    1EE7: 7C 0A 09 LCALL _CYFISNP_Read
    1EEA: 20       POP   X
    1EEB: 53 4B    MOV   [main.h:snpRunScaler+5],A
    1EED: 10       PUSH  X
    1EEE: 50 0D    MOV   A,0xD
    1EF0: 7C 0A 09 LCALL _CYFISNP_Read
    1EF3: 20       POP   X
    1EF4: 53 4A    MOV   [main.h:snpRunScaler+4],A
    1EF6: 10       PUSH  X
    1EF7: 7C 08 EF LCALL _CYFISNP_GetXactConfig
    1EFA: 20       POP   X
    1EFB: 53 48    MOV   [main.h:snpRunScaler+2],A
    1EFD: 10       PUSH  X
    1EFE: 50 0E    MOV   A,0xE
    1F00: 7C 0A 09 LCALL _CYFISNP_Read
    1F03: 20       POP   X
    1F04: 53 49    MOV   [main.h:snpRunScaler+3],A
    1F06: 47 48 1C TST   [main.h:snpRunScaler+2],0x1C
    1F09: A0 08    JZ    0x1F12
    1F0B: 10       PUSH  X
    1F0C: 50 00    MOV   A,0x0
    1F0E: 7C 0C 27 LCALL _CYFISNP_ForceState
    1F11: 20       POP   X
    1F12: 10       PUSH  X
    1F13: 57 C0    MOV   X,0xC0
    1F15: 50 0C    MOV   A,0xC
    1F17: 7C 0A 07 LCALL _CYFISNP_Write
    1F1A: 57 42    MOV   X,0x42
    1F1C: 50 0D    MOV   A,0xD
    1F1E: 7C 0A 07 LCALL _CYFISNP_Write
    1F21: 57 00    MOV   X,0x0
    1F23: 50 0E    MOV   A,0xE
    1F25: 7C 0A 07 LCALL _CYFISNP_Write
    1F28: 20       POP   X
    1F29: 41 08 7F AND   REG[0x8],0x7F
    1F2C: 7F       RET   
_CYFISNP_spiWake:
    1F2D: 3C 47 00 CMP   [main.h:snpRunScaler+1],0x0
    1F30: A0 2A    JZ    0x1F5B
    1F32: 55 47 00 MOV   [main.h:snpRunScaler+1],0x0
    1F35: 43 08 80 OR    REG[0x8],0x80
    1F38: 10       PUSH  X
    1F39: 58 4A    MOV   X,[main.h:snpRunScaler+4]
    1F3B: 50 0D    MOV   A,0xD
    1F3D: 7C 0A 07 LCALL _CYFISNP_Write
    1F40: 58 49    MOV   X,[main.h:snpRunScaler+3]
    1F42: 50 0E    MOV   A,0xE
    1F44: 7C 0A 07 LCALL _CYFISNP_Write
    1F47: 58 4B    MOV   X,[main.h:snpRunScaler+5]
    1F49: 50 0C    MOV   A,0xC
    1F4B: 7C 0A 07 LCALL _CYFISNP_Write
    1F4E: 20       POP   X
    1F4F: 47 48 1C TST   [main.h:snpRunScaler+2],0x1C
    1F52: A0 08    JZ    0x1F5B
    1F54: 10       PUSH  X
    1F55: 51 48    MOV   A,[main.h:snpRunScaler+2]
    1F57: 7C 0C 27 LCALL _CYFISNP_ForceState
    1F5A: 20       POP   X
    1F5B: 7F       RET   
    1F5C: 50 3F    MOV   A,0x3F
    1F5E: 10       PUSH  X
    1F5F: 57 C3    MOV   X,0xC3
    1F61: 28       ROMX  
    1F62: 20       POP   X
    1F63: 39 00    CMP   A,0x0
    1F65: A0 05    JZ    0x1F6B
    1F67: 50 01    MOV   A,0x1
    1F69: 80 03    JMP   0x1F6D
    1F6B: 50 00    MOV   A,0x0
    1F6D: 7F       RET   
    1F6E: 10       PUSH  X
    1F6F: 4F       MOV   X,SP
    1F70: 3D FC 01 CMP   [X-4],0x1
    1F73: B0 0C    JNZ   0x1F80
    1F75: 10       PUSH  X
    1F76: 57 00    MOV   X,0x0
    1F78: 50 1E    MOV   A,0x1E
    1F7A: 7C 0A 07 LCALL _CYFISNP_Write
    1F7D: 20       POP   X
    1F7E: 80 0A    JMP   0x1F89
    1F80: 10       PUSH  X
    1F81: 57 08    MOV   X,0x8
    1F83: 50 1E    MOV   A,0x1E
    1F85: 7C 0A 07 LCALL _CYFISNP_Write
    1F88: 20       POP   X
    1F89: 20       POP   X
    1F8A: 7F       RET   
_CYFISNP_GetQualGfsk:
    1F8B: 51 6A    MOV   A,[main.h:snpRunScaler+36]
    1F8D: 7F       RET   
_CYFISNP_GetQual8dr:
    1F8E: 51 69    MOV   A,[main.h:snpRunScaler+35]
    1F90: 7F       RET   
__lpmw:
    2055: 08       PUSH  A
    2056: 28       ROMX  
    2057: 53 0B    MOV   [__rX],A
    2059: 18       POP   A
    205A: 75       INC   X
    205B: 09 00    ADC   A,0x0
    205D: 28       ROMX  
    205E: 7F       RET   
