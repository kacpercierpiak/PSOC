FILE: .\boot.asm                        (0001) ;  Generated by PSoC Designer 5.4.3191
                                        (0002) ;
                                        (0003) ;@Id: boot.tpl#886 @
                                        (0004) ;=============================================================================
                                        (0005) ;  FILENAME:   boot.asm
                                        (0006) ;  Version:    4.21
                                        (0007) ;
                                        (0008) ;  DESCRIPTION:
                                        (0009) ;  M8C Boot Code for CY8C21x34 microcontroller devices.
                                        (0010) ;
                                        (0011) ;  Copyright (c) Cypress Semiconductor 2010. All Rights Reserved.
                                        (0012) ;
                                        (0013) ; NOTES:
                                        (0014) ; PSoC Designer's Device Editor uses a template file, BOOT.TPL, located in
                                        (0015) ; the project's root directory to create BOOT.ASM. Any changes made to
                                        (0016) ; BOOT.ASM will be  overwritten every time the project is generated; therefore
                                        (0017) ; changes should be made to BOOT.TPL not BOOT.ASM. Care must be taken when
                                        (0018) ; modifying BOOT.TPL so that replacement strings (such as @PROJECT_NAME)
                                        (0019) ; are not accidentally modified.
                                        (0020) ;
                                        (0021) ;=============================================================================
                                        (0022) 
                                        (0023) include ".\lib\GlobalParams.inc"	;File generated by PSoC Designer (Project dependent)
                                        (0024) include "m8c.inc"			;Part specific file
                                        (0025) include "m8ssc.inc"			;Part specific file
                                        (0026) include "memory.inc"			;File generated by PSoC Designer (Project dependent)
                                        (0027) 
                                        (0028) ;--------------------------------------
                                        (0029) ; Export Declarations
                                        (0030) ;--------------------------------------
                                        (0031) 
                                        (0032) export __Start
                                        (0033) IF	(TOOLCHAIN & HITECH)
                                        (0034) ELSE
                                        (0035) export __bss_start
                                        (0036) export __data_start
                                        (0037) export __idata_start
                                        (0038) export __func_lit_start
                                        (0039) export __text_start
                                        (0040) ENDIF
                                        (0041) export  _bGetPowerSetting
                                        (0042) export   bGetPowerSetting
                                        (0043) 
                                        (0044) 
                                        (0045) ;--------------------------------------
                                        (0046) ; Optimization flags
                                        (0047) ;--------------------------------------
                                        (0048) ;
                                        (0049) ; To change the value of these flags, modify the file boot.tpl, not
                                        (0050) ; boot.asm. See the notes in the banner comment at the beginning of
                                        (0051) ; this file.
                                        (0052) 
                                        (0053) ; Optimization for Assembly language (only) projects and C-language projects
                                        (0054) ; that do not depend on the C compiler to initialize the values of RAM variables.
                                        (0055) ;   Set to 1: Support for C Run-time Environment initialization
                                        (0056) ;   Set to 0: Support for C not included. Faster start up, smaller code space.
                                        (0057) ;
                                        (0058) IF	(TOOLCHAIN & HITECH)
                                        (0059) ; The C compiler will customize the startup code - it's not required here
                                        (0060) 
                                        (0061) C_LANGUAGE_SUPPORT:              equ 0
                                        (0062) ELSE
                                        (0063) C_LANGUAGE_SUPPORT:              equ 1
                                        (0064) ENDIF
                                        (0065) 
                                        (0066) 
                                        (0067) ; For historical reasons, by default the boot code uses an lcall instruction
                                        (0068) ; to invoke the user's _main code. If _main executes a return instruction,
                                        (0069) ; boot provides an infinite loop. By changing the following equate from zero
                                        (0070) ; to 1, boot's lcall will be replaced by a ljmp instruction, saving two
                                        (0071) ; bytes on the stack which are otherwise required for the return address. If
                                        (0072) ; this option is enabled, _main must not return. (Beginning with the 4.2
                                        (0073) ; release, the C compiler automatically places an infinite loop at the end
                                        (0074) ; of main, rather than a return instruction.)
                                        (0075) ;
                                        (0076) ENABLE_LJMP_TO_MAIN:             equ 0
                                        (0077) 
                                        (0078) 
                                        (0079) ;-----------------------------------------------------------------------------
                                        (0080) ; Interrupt Vector Table
                                        (0081) ;-----------------------------------------------------------------------------
                                        (0082) ;
                                        (0083) ; Interrupt vector table entries are 4 bytes long.  Each one contains
                                        (0084) ; a jump instruction to an ISR (Interrupt Service Routine), although
                                        (0085) ; very short ISRs could be encoded within the table itself. Normally,
                                        (0086) ; vector jump targets are modified automatically according to the user
                                        (0087) ; modules selected. This occurs when the 'Generate Application' opera-
                                        (0088) ; tion is run causing PSoC Designer to create boot.asm and the other
                                        (0089) ; configuration files. If you need to hard code a vector, update the
                                        (0090) ; file boot.tpl, not boot.asm. See the banner comment at the beginning
                                        (0091) ; of this file.
                                        (0092) ;-----------------------------------------------------------------------------
                                        (0093) 
                                        (0094)     AREA TOP (ROM, ABS, CON)
                                        (0095) 
                                        (0096)     org   0                        ;Reset Interrupt Vector
                                        (0097) IF	(TOOLCHAIN & HITECH)
                                        (0098) ;   jmp   __Start                  ;C compiler fills in this vector
                                        (0099) ELSE
0000: 80 67    JMP   0x0068             (0100)     jmp   __Start                  ;First instruction executed following a Reset
                                        (0101) ENDIF
                                        (0102) 
                                        (0103)     org   04h                      ;Low Voltage Detect (LVD) Interrupt Vector
0004: 30       HALT                     (0104)     halt                           ;Stop execution if power falls too low
                                        (0105) 
                                        (0106)     org   08h                      ;Analog Column 0 Interrupt Vector
                                        (0107)     // call	void_handler
0008: 7E       RETI                     (0108)     reti
                                        (0109) 
                                        (0110)     org   0Ch                      ;Analog Column 1 Interrupt Vector
000C: 7D 04 9E LJMP  _ADC10_ADC_ISR     (0111)     ljmp	_ADC10_ADC_ISR
000F: 7E       RETI                     (0112)     reti
                                        (0113) 
                                        (0114)     org   18h                      ;VC3 Interrupt Vector
                                        (0115)     // call	void_handler
0018: 7E       RETI                     (0116)     reti
                                        (0117) 
                                        (0118)     org   1Ch                      ;GPIO Interrupt Vector
                                        (0119)     // call	void_handler
001C: 7E       RETI                     (0120)     reti
                                        (0121) 
                                        (0122)     org   20h                      ;PSoC Block DBB00 Interrupt Vector
0020: 7D 04 D1 LJMP  _ADC10_CNT_ISR     (0123)     ljmp	_ADC10_CNT_ISR
0023: 7E       RETI                     (0124)     reti
                                        (0125) 
                                        (0126)     org   24h                      ;PSoC Block DBB01 Interrupt Vector
0024: 7D 03 22 LJMP  _LED_RED_Invert    (0127)     ljmp _LED_RED_Invert
0027: 7E       RETI                     (0128)     reti
                                        (0129) 
                                        (0130)     org   28h                      ;PSoC Block DCB02 Interrupt Vector
                                        (0131)     // call	void_handler
0028: 7E       RETI                     (0132)     reti
                                        (0133) 
                                        (0134)     org   2Ch                      ;PSoC Block DCB03 Interrupt Vector
                                        (0135)     // call	void_handler
002C: 7E       RETI                     (0136)     reti
                                        (0137) 
                                        (0138)     org   60h                      ;PSoC I2C Interrupt Vector
0060: 7D 03 BB LJMP  _EzI2Cs_ISR        (0139)     ljmp	_EzI2Cs_ISR
0063: 7E       RETI                     (0140)     reti
                                        (0141) 
                                        (0142)     org   64h                      ;Sleep Timer Interrupt Vector
                                        (0143)     // call	void_handler
0064: 7E       RETI                     (0144)     reti
0068: 71 10    OR    F,0x10             
                                        (0145) 
                                        (0146) ;-----------------------------------------------------------------------------
                                        (0147) ;  Start of Execution.
                                        (0148) ;-----------------------------------------------------------------------------
                                        (0149) ;  The Supervisory ROM SWBootReset function has already completed the
                                        (0150) ;  calibrate1 process, loading trim values for 5 volt operation.
                                        (0151) ;
                                        (0152) 
                                        (0153) IF	(TOOLCHAIN & HITECH)
                                        (0154)  	AREA PD_startup(CODE, REL, CON)
                                        (0155) ELSE
                                        (0156)     org 68h
                                        (0157) ENDIF
                                        (0158) __Start:
                                        (0159) 
                                        (0160)     ; initialize SMP values for voltage stabilization, if required,
                                        (0161)     ; leaving power-on reset (POR) level at the default (low) level, at
                                        (0162)     ; least for now. 
                                        (0163)     ;
                                        (0164)     M8C_SetBank1
006A: 62 E3 83 MOV   REG[0xE3],0x83     (0165)     mov   reg[VLT_CR], SWITCH_MODE_PUMP_JUST | LVD_TBEN_JUST | TRIP_VOLTAGE_JUST
006D: 70 EF    AND   F,0xEF             
006F: 62 E3 38 MOV   REG[0xE3],0x38     
                                        (0166)     M8C_SetBank0
                                        (0167) 
                                        (0168) M8C_ClearWDTAndSleep			   ; Clear WDT before enabling it.
                                        (0169) IF ( WATCHDOG_ENABLE )             ; WDT selected in Global Params
                                        (0170)     M8C_EnableWatchDog
                                        (0171) ENDIF
                                        (0172) 
0072: 41 FE FB AND   REG[0xFE],0xFB     (0173)     and  reg[CPU_SCR1], ~CPU_SCR1_ECO_ALLOWED  ; Prevent ECO from being enabled
                                        (0174) 
                                        (0175)     ;---------------------------
                                        (0176)     ; Set up the Temporary stack
                                        (0177)     ;---------------------------
                                        (0178)     ; A temporary stack is set up for the SSC instructions.
                                        (0179)     ; The real stack start will be assigned later.
                                        (0180)     ;
                                        (0181) _stack_start:          equ 80h
0075: 50 80    MOV   A,0x80             (0182)     mov   A, _stack_start          ; Set top of stack to end of used RAM
0077: 4E       SWAP  SP,A               (0183)     swap  SP, A                    ; This is only temporary if going to LMM
0078: 62 E3 38 MOV   REG[0xE3],0x38     
007B: 5D D0    MOV   A,REG[0xD0]        
007D: 08       PUSH  A                  
007E: 62 D0 00 MOV   REG[0xD0],0x0      
0081: 55 FA 01 MOV   [LEDControl_RT+218],0x1
0084: 4F       MOV   X,SP               
0085: 5B       MOV   A,X                
0086: 01 03    ADD   A,0x3              
0088: 53 F9    MOV   [LEDControl_RT+217],A
008A: 55 F8 3A MOV   [LEDControl_RT+216],0x3A
008D: 50 06    MOV   A,0x6              
008F: 00       SWI                      
0090: 71 10    OR    F,0x10             
0092: 51 F9    MOV   A,[LEDControl_RT+217]
0094: 60 E8    MOV   REG[0xE8],A        
0096: 51 F8    MOV   A,[LEDControl_RT+216]
0098: 60 EA    MOV   REG[0xEA],A        
009A: 70 EF    AND   F,0xEF             
009C: 18       POP   A                  
009D: 60 D0    MOV   REG[0xD0],A        
                                        (0184) 
                                        (0185)     ;------------------------
                                        (0186)     ; Set Power-related Trim 
                                        (0187)     ;------------------------
                                        (0188)     
                                        (0189) M8C_ClearWDTAndSleep
                                        (0190) 
                                        (0191) IF ( POWER_SETTING & POWER_SET_5V0)            ; *** 5.0 Volt operation   ***
                                        (0192)  IF ( POWER_SETTING & POWER_SET_SLOW_IMO)      ; *** 6MHZ Main Oscillator ***
                                        (0193)     or  reg[CPU_SCR1], CPU_SCR1_SLIMO
                                        (0194)     M8SSC_Set2TableTrims 2, SSCTBL2_TRIM_IMO_5V_6MHZ, 1, SSCTBL1_TRIM_BGR_5V
                                        (0195)  ENDIF
                                        (0196) ENDIF ; 5.0 V Operation
                                        (0197) 
                                        (0198) IF ( POWER_SETTING & POWER_SET_3V3)            ; *** 3.3 Volt operation   ***
                                        (0199)  IF ( POWER_SETTING & POWER_SET_SLOW_IMO)      ; *** 6MHZ Main Oscillator ***
                                        (0200)     or  reg[CPU_SCR1], CPU_SCR1_SLIMO
                                        (0201)     M8SSC_Set2TableTrims 2, SSCTBL2_TRIM_IMO_3V_6MHZ, 1, SSCTBL1_TRIM_BGR_3V
                                        (0202)  ELSE                                          ; *** 12MHZ Main Oscillator ***
                                        (0203)     M8SSC_SetTableTrims  1, SSCTBL1_TRIM_IMO_3V_24MHZ, SSCTBL1_TRIM_BGR_3V
                                        (0204)  ENDIF
                                        (0205) ENDIF ; 3.3 Volt Operation
                                        (0206) 
                                        (0207) IF ( POWER_SETTING & POWER_SET_2V7_12MHZ)      ; *** 2.7 Volts / 12MHZ operation ***
                                        (0208)     or  reg[CPU_SCR1], CPU_SCR1_SLIMO
                                        (0209)     M8SSC_SetTableTrims  2, SSCTBL2_TRIM_IMO_2V_12MHZ, SSCTBL2_TRIM_BGR_2V
                                        (0210) ENDIF ; *** 2.7 Volts / 12MHZ operation ***
                                        (0211) 
                                        (0212) IF ( POWER_SETTING & POWER_SET_2V7_6MHZ)       ; *** 2.7 Volts /  6MHZ operation ***
                                        (0213)     or  reg[CPU_SCR1], CPU_SCR1_SLIMO
                                        (0214)     M8SSC_SetTableTrims  2, SSCTBL2_TRIM_IMO_2V_6MHZ,  SSCTBL2_TRIM_BGR_2V
                                        (0215) ENDIF ; *** 2.7 Volts /  6MHZ operation ***
                                        (0216) 
009F: 55 F8 00 MOV   [LEDControl_RT+216],0x0(0217)     mov  [bSSC_KEY1],  0           ; Lock out Flash and Supervisiory operations
00A2: 55 F9 00 MOV   [LEDControl_RT+217],0x0(0218)     mov  [bSSC_KEYSP], 0
00A5: 71 10    OR    F,0x10             
                                        (0219) 
                                        (0220)     ;---------------------------------------
                                        (0221)     ; Initialize Crystal Oscillator and PLL
                                        (0222)     ;---------------------------------------
                                        (0223) IF ( POWER_SETTING & POWER_SET_2V7)       ; *** 2.7 Volts  ***
                                        (0224)     M8C_SetBank1
                                        (0225)     mov   reg[OSC_CR0], (SLEEP_TIMER_JUST | OSC_CR0_CPU_3MHz)
                                        (0226)     M8C_SetBank0
                                        (0227)     M8C_ClearWDTAndSleep           ; Reset the watch dog
                                        (0228) 
                                        (0229) ELSE 	 ;*** all other voltages OK for 12Mhz ***
                                        (0230)     M8C_SetBank1
00A7: 62 E0 02 MOV   REG[0xE0],0x2      (0231)     mov   reg[OSC_CR0], (SLEEP_TIMER_JUST | OSC_CR0_CPU_12MHz)
00AA: 70 EF    AND   F,0xEF             
00AC: 62 E3 38 MOV   REG[0xE3],0x38     
00AF: 62 D1 01 MOV   REG[0xD1],0x1      
                                        (0232)     M8C_SetBank0
                                        (0233)     M8C_ClearWDTAndSleep           ; Reset the watch dog
                                        (0234) 
                                        (0235) ENDIF
                                        (0236) 
                                        (0237) 	;-------------------------------------------------------
                                        (0238)     ; Initialize Proper Drive Mode for External Clock Pin
                                        (0239)     ;-------------------------------------------------------
                                        (0240) 
                                        (0241)     ; Change EXTCLK pin from Hi-Z Analog (110b) drive mode to Hi-Z (010b) drive mode
                                        (0242) 
                                        (0243) IF (SYSCLK_SOURCE)
                                        (0244)     and reg[PRT1DM2],  ~0x10        ; Clear bit 4 of EXTCLK pin's DM2 register 
                                        (0245) ENDIF
                                        (0246)     ; EXTCLK pin is now in proper drive mode to input the external clock signal
                                        (0247) 
                                        (0248) IF	(TOOLCHAIN & HITECH)
                                        (0249)     ;---------------------------------------------
                                        (0250)     ; HI-TECH initialization: Enter the Large Memory Model, if applicable
                                        (0251)     ;---------------------------------------------
                                        (0252) 	global		__Lstackps
                                        (0253) 	mov     a,low __Lstackps
                                        (0254) 	swap    a,sp
                                        (0255) 
                                        (0256) IF ( SYSTEM_LARGE_MEMORY_MODEL )
                                        (0257)     RAM_SETPAGE_STK SYSTEM_STACK_PAGE      ; relocate stack page ...
                                        (0258)     RAM_SETPAGE_IDX2STK            ; initialize other page pointers
                                        (0259)     RAM_SETPAGE_CUR 0
                                        (0260)     RAM_SETPAGE_MVW 0
                                        (0261)     RAM_SETPAGE_MVR 0
                                        (0262)     IF ( SYSTEM_IDXPG_TRACKS_STK_PP ); Now enable paging:
                                        (0263)       or    F, FLAG_PGMODE_11b       ; LMM w/ IndexPage<==>StackPage
                                        (0264)     ELSE
                                        (0265)       or    F, FLAG_PGMODE_10b       ; LMM w/ independent IndexPage
                                        (0266)     ENDIF ;  SYSTEM_IDXPG_TRACKS_STK_PP
                                        (0267) ENDIF ;  SYSTEM_LARGE_MEMORY_MODEL
                                        (0268) ELSE
                                        (0269)     ;---------------------------------------------
                                        (0270)     ; ImageCraft Enter the Large Memory Model, if applicable
                                        (0271)     ;---------------------------------------------
                                        (0272) IF ( SYSTEM_LARGE_MEMORY_MODEL )
                                        (0273)     RAM_SETPAGE_STK SYSTEM_STACK_PAGE      ; relocate stack page ...
00B2: 50 00    MOV   A,0x0              (0274)     mov   A, SYSTEM_STACK_BASE_ADDR        ;   and offset, if any
00B4: 4E       SWAP  SP,A               (0275)     swap  A, SP
00B5: 62 D3 01 MOV   REG[0xD3],0x1      
00B8: 62 D0 00 MOV   REG[0xD0],0x0      
00BB: 62 D5 00 MOV   REG[0xD5],0x0      
00BE: 62 D4 00 MOV   REG[0xD4],0x0      
                                        (0276)     RAM_SETPAGE_IDX2STK            ; initialize other page pointers
                                        (0277)     RAM_SETPAGE_CUR 0
                                        (0278)     RAM_SETPAGE_MVW 0
                                        (0279)     RAM_SETPAGE_MVR 0
                                        (0280) 
                                        (0281)   IF ( SYSTEM_IDXPG_TRACKS_STK_PP ); Now enable paging:
00C1: 71 C0    OR    F,0xC0             (0282)     or    F, FLAG_PGMODE_11b       ; LMM w/ IndexPage<==>StackPage
                                        (0283)   ELSE
                                        (0284)     or    F, FLAG_PGMODE_10b       ; LMM w/ independent IndexPage
                                        (0285)   ENDIF ;  SYSTEM_IDXPG_TRACKS_STK_PP
                                        (0286) ELSE
                                        (0287)     mov   A, __ramareas_end        ; Set top of stack to end of used RAM
                                        (0288)     swap  SP, A
                                        (0289) ENDIF ;  SYSTEM_LARGE_MEMORY_MODEL
                                        (0290) ENDIF ;	TOOLCHAIN
                                        (0291) 
                                        (0292)     ;-------------------------
                                        (0293)     ; Load Base Configuration
                                        (0294)     ;-------------------------
                                        (0295)     ; Load global parameter settings and load the user modules in the
                                        (0296)     ; base configuration. Exceptions: (1) Leave CPU Speed fast as possible
                                        (0297)     ; to minimize start up time; (2) We may still need to play with the
                                        (0298)     ; Sleep Timer.
                                        (0299)     ;
00C3: 7C 02 9F LCALL 0x029F             (0300)     lcall LoadConfigInit
                                        (0301) 
                                        (0302)     ;-----------------------------------
                                        (0303)     ; Initialize C Run-Time Environment
                                        (0304)     ;-----------------------------------
                                        (0305) IF ( C_LANGUAGE_SUPPORT )
                                        (0306) IF ( SYSTEM_SMALL_MEMORY_MODEL )
                                        (0307)     mov  A,0                           ; clear the 'bss' segment to zero
                                        (0308)     mov  [__r0],<__bss_start
                                        (0309) BssLoop:
                                        (0310)     cmp  [__r0],<__bss_end
                                        (0311)     jz   BssDone
                                        (0312)     mvi  [__r0],A
                                        (0313)     jmp  BssLoop
                                        (0314) BssDone:
                                        (0315)     mov  A,>__idata_start              ; copy idata to data segment
                                        (0316)     mov  X,<__idata_start
                                        (0317)     mov  [__r0],<__data_start
                                        (0318) IDataLoop:
                                        (0319)     cmp  [__r0],<__data_end
                                        (0320)     jz   C_RTE_Done
                                        (0321)     push A
                                        (0322)     romx
                                        (0323)     mvi  [__r0],A
                                        (0324)     pop  A
                                        (0325)     inc  X
                                        (0326)     adc  A,0
                                        (0327)     jmp  IDataLoop
                                        (0328) 
                                        (0329) ENDIF ; SYSTEM_SMALL_MEMORY_MODEL
                                        (0330) 
                                        (0331) IF ( SYSTEM_LARGE_MEMORY_MODEL )
00C6: 62 D0 00 MOV   REG[0xD0],0x0      (0332)     mov   reg[CUR_PP], >__r0           ; force direct addr mode instructions
                                        (0333)                                        ; to use the Virtual Register page.
                                        (0334) 
                                        (0335)     ; Dereference the constant (flash) pointer pXIData to access the start
                                        (0336)     ; of the extended idata area, "xidata." Xidata follows the end of the
                                        (0337)     ; text segment and may have been relocated by the Code Compressor.
                                        (0338)     ;
00C9: 50 02    MOV   A,0x2              (0339)     mov   A, >__pXIData                ; Get the address of the flash
00CB: 57 18    MOV   X,0x18             (0340)     mov   X, <__pXIData                ;   pointer to the xidata area.
00CD: 08       PUSH  A                  (0341)     push  A
00CE: 28       ROMX                     (0342)     romx                               ; get the MSB of xidata's address
00CF: 53 1B    MOV   [__r0],A           (0343)     mov   [__r0], A
00D1: 18       POP   A                  (0344)     pop   A
00D2: 75       INC   X                  (0345)     inc   X
00D3: 09 00    ADC   A,0x0              (0346)     adc   A, 0
00D5: 28       ROMX                     (0347)     romx                               ; get the LSB of xidata's address
00D6: 4B       SWAP  A,X                (0348)     swap  A, X
00D7: 51 1B    MOV   A,[__r0]           (0349)     mov   A, [__r0]                    ; pXIData (in [A,X]) points to the
                                        (0350)                                        ;   XIData structure list in flash
00D9: 80 04    JMP   0x00DE             (0351)     jmp   .AccessStruct
                                        (0352) 
                                        (0353)     ; Unpack one element in the xidata "structure list" that specifies the
                                        (0354)     ; values of C variables. Each structure contains 3 member elements.
                                        (0355)     ; The first is a pointer to a contiguous block of RAM to be initial-
                                        (0356)     ; ized. Blocks are always 255 bytes or less in length and never cross
                                        (0357)     ; RAM page boundaries. The list terminates when the MSB of the pointer
                                        (0358)     ; contains 0xFF. There are two formats for the struct depending on the
                                        (0359)     ; value in the second member element, an unsigned byte:
                                        (0360)     ; (1) If the value of the second element is non-zero, it represents
                                        (0361)     ; the 'size' of the block of RAM to be initialized. In this case, the
                                        (0362)     ; third member of the struct is an array of bytes of length 'size' and
                                        (0363)     ; the bytes are copied to the block of RAM.
                                        (0364)     ; (2) If the value of the second element is zero, the block of RAM is
                                        (0365)     ; to be cleared to zero. In this case, the third member of the struct
                                        (0366)     ; is an unsigned byte containing the number of bytes to clear.
                                        (0367) 
                                        (0368) .AccessNextStructLoop:
00DB: 75       INC   X                  (0369)     inc   X                            ; pXIData++
00DC: 09 00    ADC   A,0x0              (0370)     adc   A, 0
00DE: 62 E3 00 MOV   REG[0xE3],0x0      
                                        (0371) .AccessStruct:                         ; Entry point for first block
                                        (0372)     ;
                                        (0373)     ; Assert: pXIData in [A,X] points to the beginning of an XIData struct.
                                        (0374)     ;
                                        (0375)     M8C_ClearWDT                       ; Clear the watchdog for long inits
00E1: 08       PUSH  A                  (0376)     push  A
00E2: 28       ROMX                     (0377)     romx                               ; MSB of RAM addr (CPU.A <- *pXIData)
00E3: 60 D5    MOV   REG[0xD5],A        (0378)     mov   reg[MVW_PP], A               ;   for use with MVI write operations
00E5: 74       INC   A                  (0379)     inc   A                            ; End of Struct List? (MSB==0xFF?)
00E6: A0 4B    JZ    0x0132             (0380)     jz    .C_RTE_WrapUp                ;   Yes, C runtime environment complete
00E8: 18       POP   A                  (0381)     pop   A                            ; restore pXIData to [A,X]
00E9: 75       INC   X                  (0382)     inc   X                            ; pXIData++
00EA: 09 00    ADC   A,0x0              (0383)     adc   A, 0
00EC: 08       PUSH  A                  (0384)     push  A
00ED: 28       ROMX                     (0385)     romx                               ; LSB of RAM addr (CPU.A <- *pXIData)
00EE: 53 1B    MOV   [__r0],A           (0386)     mov   [__r0], A                    ; RAM Addr now in [reg[MVW_PP],[__r0]]
00F0: 18       POP   A                  (0387)     pop   A                            ; restore pXIData to [A,X]
00F1: 75       INC   X                  (0388)     inc   X                            ; pXIData++ (point to size)
00F2: 09 00    ADC   A,0x0              (0389)     adc   A, 0
00F4: 08       PUSH  A                  (0390)     push  A
00F5: 28       ROMX                     (0391)     romx                               ; Get the size (CPU.A <- *pXIData)
00F6: A0 1C    JZ    0x0113             (0392)     jz    .ClearRAMBlockToZero         ; If Size==0, then go clear RAM
00F8: 53 1A    MOV   [__r1],A           (0393)     mov   [__r1], A                    ;             else downcount in __r1
00FA: 18       POP   A                  (0394)     pop   A                            ; restore pXIData to [A,X]
                                        (0395) 
                                        (0396) .CopyNextByteLoop:
                                        (0397)     ; For each byte in the structure's array member, copy from flash to RAM.
                                        (0398)     ; Assert: pXIData in [A,X] points to previous byte of flash source;
                                        (0399)     ;         [reg[MVW_PP],[__r0]] points to next RAM destination;
                                        (0400)     ;         __r1 holds a non-zero count of the number of bytes remaining.
                                        (0401)     ;
00FB: 75       INC   X                  (0402)     inc   X                            ; pXIData++ (point to next data byte)
00FC: 09 00    ADC   A,0x0              (0403)     adc   A, 0
00FE: 08       PUSH  A                  (0404)     push  A
00FF: 28       ROMX                     (0405)     romx                               ; Get the data value (CPU.A <- *pXIData)
0100: 3F 1B    MVI   [__r0],A           (0406)     mvi   [__r0], A                    ; Transfer the data to RAM
0102: 47 1B FF TST   [__r0],0xFF        (0407)     tst   [__r0], 0xff                 ; Check for page crossing
0105: B0 06    JNZ   0x010C             (0408)     jnz   .CopyLoopTail                ;   No crossing, keep going
0107: 5D D5    MOV   A,REG[0xD5]        (0409)     mov   A, reg[ MVW_PP]              ;   If crossing, bump MVW page reg
0109: 74       INC   A                  (0410)     inc   A
010A: 60 D5    MOV   REG[0xD5],A        (0411)     mov   reg[ MVW_PP], A
                                        (0412) .CopyLoopTail:
010C: 18       POP   A                  (0413)     pop   A                            ; restore pXIData to [A,X]
010D: 7A 1A    DEC   [__r1]             (0414)     dec   [__r1]                       ; End of this array in flash?
010F: BF EB    JNZ   0x00FB             (0415)     jnz   .CopyNextByteLoop            ;   No,  more bytes to copy
0111: 8F C9    JMP   0x00DB             (0416)     jmp   .AccessNextStructLoop        ;   Yes, initialize another RAM block
                                        (0417) 
                                        (0418) .ClearRAMBlockToZero:
0113: 18       POP   A                  (0419)     pop   A                            ; restore pXIData to [A,X]
0114: 75       INC   X                  (0420)     inc   X                            ; pXIData++ (point to next data byte)
0115: 09 00    ADC   A,0x0              (0421)     adc   A, 0
0117: 08       PUSH  A                  (0422)     push  A
0118: 28       ROMX                     (0423)     romx                               ; Get the run length (CPU.A <- *pXIData)
0119: 53 1A    MOV   [__r1],A           (0424)     mov   [__r1], A                    ; Initialize downcounter
011B: 50 00    MOV   A,0x0              (0425)     mov   A, 0                         ; Initialize source data
                                        (0426) 
                                        (0427) .ClearRAMBlockLoop:
                                        (0428)     ; Assert: [reg[MVW_PP],[__r0]] points to next RAM destination and
                                        (0429)     ;         __r1 holds a non-zero count of the number of bytes remaining.
                                        (0430)     ;
011D: 3F 1B    MVI   [__r0],A           (0431)     mvi   [__r0], A                    ; Clear a byte
011F: 47 1B FF TST   [__r0],0xFF        (0432)     tst   [__r0], 0xff                 ; Check for page crossing
0122: B0 08    JNZ   0x012B             (0433)     jnz   .ClearLoopTail               ;   No crossing, keep going
0124: 5D D5    MOV   A,REG[0xD5]        (0434)     mov   A, reg[ MVW_PP]              ;   If crossing, bump MVW page reg
0126: 74       INC   A                  (0435)     inc   A
0127: 60 D5    MOV   REG[0xD5],A        (0436)     mov   reg[ MVW_PP], A
0129: 50 00    MOV   A,0x0              (0437)     mov   A, 0                         ; Restore the zero used for clearing
                                        (0438) .ClearLoopTail:
012B: 7A 1A    DEC   [__r1]             (0439)     dec   [__r1]                       ; Was this the last byte?
012D: BF EF    JNZ   0x011D             (0440)     jnz   .ClearRAMBlockLoop           ;   No,  continue
012F: 18       POP   A                  (0441)     pop   A                            ;   Yes, restore pXIData to [A,X] and
0130: 8F AA    JMP   0x00DB             (0442)     jmp   .AccessNextStructLoop        ;        initialize another RAM block
                                        (0443) 
                                        (0444) .C_RTE_WrapUp:
0132: 18       POP   A                  (0445)     pop   A                            ; balance stack
0133: 71 10    OR    F,0x10             
                                        (0446) 
                                        (0447) ENDIF ; SYSTEM_LARGE_MEMORY_MODEL
                                        (0448) 
                                        (0449) C_RTE_Done:
                                        (0450) 
                                        (0451) ENDIF ; C_LANGUAGE_SUPPORT
                                        (0452) 
                                        (0453)     ;-------------------------------
                                        (0454)     ; Voltage Stabilization for SMP
                                        (0455)     ;-------------------------------
                                        (0456) 
                                        (0457) IF ( POWER_SETTING & POWER_SET_5V0)    ; 5.0V Operation
                                        (0458) IF ( SWITCH_MODE_PUMP ^ 1 )            ; SMP is operational
                                        (0459)     ;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                        (0460)     ; When using the SMP at 5V, we must wait for Vdd to slew from 3.1V to
                                        (0461)     ; 5V before enabling the Precision Power-On Reset (PPOR).
                                        (0462)     ;- - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - - -
                                        (0463)     or   reg[INT_MSK0],INT_MSK0_SLEEP
                                        (0464)     M8C_SetBank1
                                        (0465)     and   reg[OSC_CR0], ~OSC_CR0_SLEEP
                                        (0466)     or    reg[OSC_CR0],  OSC_CR0_SLEEP_512Hz
                                        (0467)     M8C_SetBank0
                                        (0468)     M8C_ClearWDTAndSleep                   ; Restart the sleep timer
                                        (0469)     mov   reg[INT_VC], 0                   ; Clear all pending interrupts
                                        (0470) .WaitFor2ms:
                                        (0471)     tst   reg[INT_CLR0], INT_MSK0_SLEEP    ; Test the SleepTimer Interrupt Status
                                        (0472)     jz   .WaitFor2ms                       ; Branch fails when 2 msec has passed
                                        (0473) ENDIF ; SMP is operational
                                        (0474) ENDIF ; 5.0V Operation
                                        (0475) 
                                        (0476)     ;-------------------------------
                                        (0477)     ; Set Power-On Reset (POR) Level
                                        (0478)     ;-------------------------------
                                        (0479) 
                                        (0480)     ;  The writes to the VLT_CR register below include setting the POR to VLT_CR_POR_HIGH,
                                        (0481)     ;  VLT_CR_POR_MID or VLT_CR_POR_LOW. Correctly setting this value is critical to the proper
                                        (0482)     ;  operation of the PSoC. The POR protects the M8C from mis-executing when Vdd falls low. These
                                        (0483)     ;  values should not be changed from the settings here. Failure to follow this instruction could 
                                        (0484)     ;  lead to corruption of PSoC flash.
                                        (0485) 
                                        (0486)     M8C_SetBank1
                                        (0487) 
                                        (0488) IF (POWER_SETTING & POWER_SET_2V7)             ; 2.7V Operation?
                                        (0489)                                                ;  Yes, lowest trip already set
                                        (0490) ELSE                                           ;   No, must adjust POR...
                                        (0491) IF (POWER_SETTING & POWER_SET_3V3)             ; 3.3V Operation?
0135: 43 E3 10 OR    REG[0xE3],0x10     (0492)     or   reg[VLT_CR], VLT_CR_POR_MID           ;   Yes, change to midpoint trip
0138: 70 EF    AND   F,0xEF             
                                        (0493) ELSE
                                        (0494) IF (POWER_SETTING & POWER_SET_5V0)             ; 5.0V Operation?
                                        (0495)  IF (POWER_SETTING & POWER_SET_SLOW_IMO)       ; and Slow Mode?
                                        (0496)     or   reg[VLT_CR], VLT_CR_POR_MID           ;   Yes, set to midpoint trip
                                        (0497)  ELSE                                          ;    No, fast mode
                                        (0498)   IF ( CPU_CLOCK_JUST ^ OSC_CR0_CPU_24MHz )    ;      As fast as 24MHz?
                                        (0499)     or   reg[VLT_CR], VLT_CR_POR_MID           ;         No, change to midpoint trip
                                        (0500)   ELSE ; 24HMz                                 ;
                                        (0501)     or    reg[VLT_CR], VLT_CR_POR_HIGH         ;        Yes, switch to	highest setting
                                        (0502)   ENDIF ; 24MHz
                                        (0503)  ENDIF ; Slow Mode
                                        (0504) ENDIF ; 5.0V Operation
                                        (0505) ENDIF ; 3.3V Operation
                                        (0506) ENDIF ; 2.7V Operation
                                        (0507) 
                                        (0508)     M8C_SetBank0
                                        (0509) 
                                        (0510)     ;----------------------------
                                        (0511)     ; Wrap up and invoke "main"
                                        (0512)     ;----------------------------
                                        (0513) 
                                        (0514)     ; Disable the Sleep interrupt that was used for timing above.  In fact,
                                        (0515)     ; no interrupts should be enabled now, so may as well clear the register.
                                        (0516)     ;
013A: 62 E0 00 MOV   REG[0xE0],0x0      (0517)     mov  reg[INT_MSK0],0
013D: 71 10    OR    F,0x10             
                                        (0518) 
                                        (0519)     ; Everything has started OK. Now select requested CPU & sleep frequency.
                                        (0520)     ;
                                        (0521)     M8C_SetBank1
013F: 62 E0 02 MOV   REG[0xE0],0x2      (0522)     mov  reg[OSC_CR0],(SLEEP_TIMER_JUST | CPU_CLOCK_JUST)
0142: 70 EF    AND   F,0xEF             
                                        (0523)     M8C_SetBank0
                                        (0524) 
                                        (0525)     ; Global Interrupt are NOT enabled, this should be done in main().
                                        (0526)     ; LVD is set but will not occur unless Global Interrupts are enabled.
                                        (0527)     ; Global Interrupts should be enabled as soon as possible in main().
                                        (0528)     ;
0144: 62 E2 00 MOV   REG[0xE2],0x0      (0529)     mov  reg[INT_VC],0             ; Clear any pending interrupts which may
                                        (0530)                                    ; have been set during the boot process.
                                        (0531) IF	(TOOLCHAIN & HITECH)
                                        (0532) 	ljmp  startup                  ; Jump to C compiler startup code
                                        (0533) ELSE
                                        (0534) IF ENABLE_LJMP_TO_MAIN
                                        (0535)     ljmp  _main                    ; goto main (no return)
                                        (0536) ELSE
0147: 7C 08 AD LCALL _main              (0537)     lcall _main                    ; call main
                                        (0538) .Exit:
014A: 8F FF    JMP   0x014A             (0539)     jmp  .Exit                     ; Wait here after return till power-off or reset
                                        (0540) ENDIF
                                        (0541) ENDIF ; TOOLCHAIN
                                        (0542) 
                                        (0543)     ;---------------------------------
                                        (0544)     ; Library Access to Global Parms
                                        (0545)     ;---------------------------------
                                        (0546)     ;
                                        (0547)  bGetPowerSetting:
                                        (0548) _bGetPowerSetting:
                                        (0549)     ; Returns value of POWER_SETTING in the A register.
                                        (0550)     ; No inputs. No Side Effects.
                                        (0551)     ;
                                        (0552) IF (POWER_SETTING & POWER_SET_2V7)
                                        (0553)     mov   A, POWER_SETTING | POWER_SET_SLOW_IMO
                                        (0554) ELSE
014C: 50 08    MOV   A,0x8              (0555)     mov   A, POWER_SETTING          ; Supply voltage and internal main osc
                                        (0556) ENDIF
014E: 7F       RET                      (0557)     ret
                                        (0558) 
                                        (0559) IF	(TOOLCHAIN & HITECH)
                                        (0560) ELSE
                                        (0561)     ;---------------------------------
                                        (0562)     ; Order Critical RAM & ROM AREAs
                                        (0563)     ;---------------------------------
                                        (0564)     ;  'TOP' is all that has been defined so far...
                                        (0565) 
                                        (0566)     ;  ROM AREAs for C CONST, static & global items
                                        (0567)     ;
                                        (0568)     AREA lit               (ROM, REL, CON)   ; 'const' definitions
                                        (0569)     AREA idata             (ROM, REL, CON)   ; Constants for initializing RAM
                                        (0570) __idata_start:
                                        (0571) 
                                        (0572)     AREA func_lit          (ROM, REL, CON)   ; Function Pointers
                                        (0573) __func_lit_start:
                                        (0574) 
                                        (0575) IF ( SYSTEM_LARGE_MEMORY_MODEL )
                                        (0576)     ; We use the func_lit area to store a pointer to extended initialized
                                        (0577)     ; data (xidata) area that follows the text area. Func_lit isn't
                                        (0578)     ; relocated by the code compressor, but the text area may shrink and
                                        (0579)     ; that moves xidata around.
                                        (0580)     ;
                                        (0581) __pXIData:         word __text_end           ; ptr to extended idata
                                        (0582) ENDIF
                                        (0583) 
                                        (0584)     AREA psoc_config       (ROM, REL, CON)   ; Configuration Load & Unload
                                        (0585)     AREA UserModules       (ROM, REL, CON)   ; User Module APIs
                                        (0586) 
                                        (0587)     ; CODE segment for general use
                                        (0588)     ;
                                        (0589)     AREA text (ROM, REL, CON)
                                        (0590) __text_start:
                                        (0591) 
                                        (0592)     ; RAM area usage
                                        (0593)     ;
                                        (0594)     AREA data              (RAM, REL, CON)   ; initialized RAM
                                        (0595) __data_start:
                                        (0596) 
                                        (0597)     AREA virtual_registers (RAM, REL, CON)   ; Temp vars of C compiler
                                        (0598)     AREA InterruptRAM      (RAM, REL, CON)   ; Interrupts, on Page 0
                                        (0599)     AREA bss               (RAM, REL, CON)   ; general use
                                        (0600) __bss_start:
                                        (0601) ENDIF ; TOOLCHAIN
                                        (0602) ; end of file boot.asm
_ADC10_iCal:
    0551: 62 D0 00 MOV   REG[0xD0],0x0
    0554: 4F       MOV   X,SP
    0555: 50 00    MOV   A,0x0
    0557: 08       PUSH  A
    0558: 08       PUSH  A
    0559: 5D 76    MOV   A,REG[0x76]
    055B: 08       PUSH  A
    055C: 5D 60    MOV   A,REG[0x60]
    055E: 08       PUSH  A
    055F: 71 10    OR    F,0x10
    0561: 5D 62    MOV   A,REG[0x62]
    0563: 70 EF    AND   F,0xEF
    0565: 08       PUSH  A
    0566: 90 65    CALL  0x05CD
    0568: 71 10    OR    F,0x10
    056A: 62 E6 00 MOV   REG[0xE6],0x0
    056D: 70 EF    AND   F,0xEF
    056F: 56 FB 80 MOV   [X-5],0x80
    0572: 71 10    OR    F,0x10
    0574: 5D E6    MOV   A,REG[0xE6]
    0576: 33 FB    XOR   A,[X-5]
    0578: 60 E6    MOV   REG[0xE6],A
    057A: 70 EF    AND   F,0xEF
    057C: 9F 84    CALL  _ADC10_StartADC
    057E: 47 0C FF TST   [0xC],0xFF
    0581: AF FC    JZ    0x057E
    0583: 51 0A    MOV   A,[0xA]
    0585: 3B FC    CMP   A,[X-4]
    0587: C0 15    JC    0x059D
    0589: B0 1F    JNZ   0x05A9
    058B: 51 0B    MOV   A,[0xB]
    058D: 3B FD    CMP   A,[X-3]
    058F: C0 0D    JC    0x059D
    0591: B0 17    JNZ   0x05A9
    0593: 51 0B    MOV   A,[0xB]
    0595: 54 01    MOV   [X+1],A
    0597: 51 0A    MOV   A,[0xA]
    0599: 54 00    MOV   [X+0],A
    059B: 80 1B    JMP   0x05B7
    059D: 71 10    OR    F,0x10
    059F: 5D E6    MOV   A,REG[0xE6]
    05A1: 33 FB    XOR   A,[X-5]
    05A3: 60 E6    MOV   REG[0xE6],A
    05A5: 70 EF    AND   F,0xEF
    05A7: 80 09    JMP   0x05B1
    05A9: 51 0B    MOV   A,[0xB]
    05AB: 54 01    MOV   [X+1],A
    05AD: 51 0A    MOV   A,[0xA]
    05AF: 54 00    MOV   [X+0],A
    05B1: 01 00    ADD   A,0x0
    05B3: 6F FB    RRC   [X-5]
    05B5: BF BC    JNZ   0x0572
    05B7: 9F 6A    CALL  _ADC10_StopADC
    05B9: 18       POP   A
    05BA: 71 10    OR    F,0x10
    05BC: 60 62    MOV   REG[0x62],A
    05BE: 70 EF    AND   F,0xEF
    05C0: 18       POP   A
    05C1: 60 60    MOV   REG[0x60],A
    05C3: 18       POP   A
    05C4: 60 76    MOV   REG[0x76],A
    05C6: 18       POP   A
    05C7: 20       POP   X
    05C8: 70 3F    AND   F,0x3F
    05CA: 71 C0    OR    F,0xC0
    05CC: 7F       RET   
    05CD: 5D 76    MOV   A,REG[0x76]
    05CF: 21 F8    AND   A,0xF8
    05D1: 48 FB 10 TST   [X-5],0x10
    05D4: B0 06    JNZ   0x05DB
    05D6: 2B FB    OR    A,[X-5]
    05D8: 60 76    MOV   REG[0x76],A
    05DA: 7F       RET   
    05DB: 29 01    OR    A,0x1
    05DD: 60 76    MOV   REG[0x76],A
    05DF: 50 76    MOV   A,0x76
    05E1: 21 04    AND   A,0x4
    05E3: A0 19    JZ    0x05FD
    05E5: 48 FB 00 TST   [X-5],0x0
    05E8: B0 0D    JNZ   0x05F6
    05EA: 27 FB 0C AND   [X-5],0xC
    05ED: 5D 60    MOV   A,REG[0x60]
    05EF: 21 F3    AND   A,0xF3
    05F1: 2B FB    OR    A,[X-5]
    05F3: 60 60    MOV   REG[0x60],A
    05F5: 7F       RET   
    05F6: 71 10    OR    F,0x10
    05F8: 43 62 80 OR    REG[0x62],0x80
    05FB: 70 EF    AND   F,0xEF
    05FD: 27 FB 03 AND   [X-5],0x3
    0600: 5D 60    MOV   A,REG[0x60]
    0602: 21 FC    AND   A,0xFC
    0604: 2B FB    OR    A,[X-5]
    0606: 60 60    MOV   REG[0x60],A
    0608: 7F       RET   
FILE: D:\Studia\PSOC\TEMP\TEMP\ledcontrol.c
(0001) #include "LEDControl.h"
(0002) #include <m8c.h>        
(0003) #include "PSoCAPI.h"    
(0004) #include <stdlib.h>
(0005) 
(0006) #define Interval 50
(0007) #define IntervalLimit 80
(0008) #define BLUE	1
(0009) #define GREEN	2
(0010) #define RED		3
(0011) 
(0012) 
(0013) 	int LEDControl_RT = 50;
(0014) 	int LEDControl_BT = 50;
(0015) 	int LEDControl_GT = 50;
(0016) void LEDControl_INIT(void)
(0017) {
(0018) 	LED_BLUE_Start();
__UserModules_end|_LEDControl_INIT|__text_start|_LEDControl_INIT:
    0609: 10       PUSH  X
    060A: 7C 03 82 LCALL LED_BLUE_Off|_LED_BLUE_Start|LED_BLUE_Start|_LED_BLUE_Stop|LED_BLUE_Stop|_LED_BLUE_Off
(0019) 	LED_GREEN_Start();
    060D: 7C 03 45 LCALL _LED_GREEN_Off|LED_GREEN_Stop|LED_GREEN_Start|_LED_GREEN_Start|_LED_GREEN_Stop
(0020) 	LED_RED_Start();
    0610: 7C 03 08 LCALL _LED_RED_Start|_LED_RED_Off|_LED_RED_Stop|LED_RED_Start|LED_RED_Off|LED_RED_Stop
(0021)     LED_RED_On();
    0613: 7C 03 04 LCALL _LED_RED_On
    0616: 20       POP   X
    0617: 7F       RET   
(0022) }
(0023) void LEDControl_ChangeState(BOOL red,BOOL green,BOOL blue)
(0024) {
_LEDControl_ChangeState:
  blue                 --> X-6
  green                --> X-5
  red                  --> X-4
    0618: 10       PUSH  X
    0619: 4F       MOV   X,SP
(0025) 	if (red)
    061A: 3D FC 00 CMP   [X-4],0x0
    061D: A0 08    JZ    0x0626
(0026) 		LED_RED_On();
    061F: 10       PUSH  X
    0620: 7C 03 04 LCALL _LED_RED_On
    0623: 20       POP   X
    0624: 80 06    JMP   0x062B
(0027) 	else
(0028) 		LED_RED_Off();
    0626: 10       PUSH  X
    0627: 7C 03 08 LCALL _LED_RED_Start|_LED_RED_Off|_LED_RED_Stop|LED_RED_Start|LED_RED_Off|LED_RED_Stop
    062A: 20       POP   X
(0029) 	if (green)
    062B: 3D FB 00 CMP   [X-5],0x0
    062E: A0 08    JZ    0x0637
(0030) 		LED_GREEN_On();
    0630: 10       PUSH  X
    0631: 7C 03 41 LCALL _LED_GREEN_On
    0634: 20       POP   X
    0635: 80 06    JMP   0x063C
(0031) 	else
(0032) 		LED_GREEN_Off();
    0637: 10       PUSH  X
    0638: 7C 03 45 LCALL _LED_GREEN_Off|LED_GREEN_Stop|LED_GREEN_Start|_LED_GREEN_Start|_LED_GREEN_Stop
    063B: 20       POP   X
(0033) 	if (blue)
    063C: 3D FA 00 CMP   [X-6],0x0
    063F: A0 08    JZ    0x0648
(0034) 		LED_BLUE_On();
    0641: 10       PUSH  X
    0642: 7C 03 7E LCALL _LED_BLUE_On
    0645: 20       POP   X
    0646: 80 06    JMP   0x064D
(0035) 	else
(0036) 		LED_BLUE_Off();
    0648: 10       PUSH  X
    0649: 7C 03 82 LCALL LED_BLUE_Off|_LED_BLUE_Start|LED_BLUE_Start|_LED_BLUE_Stop|LED_BLUE_Stop|_LED_BLUE_Off
    064C: 20       POP   X
    064D: 20       POP   X
    064E: 7F       RET   
(0037) }
(0038) BYTE LEDControl_ChangeStateSwitch(BYTE led ,BOOL isASC)
(0039) {
_LEDControl_ChangeStateSwitch:
  isASC                --> X-5
  led                  --> X-4
    064F: 10       PUSH  X
    0650: 4F       MOV   X,SP
    0651: 10       PUSH  X
(0040) 	
(0041) 	switch (led)
    0652: 3D FC 00 CMP   [X-4],0x0
    0655: A0 12    JZ    0x0668
    0657: 3D FC 01 CMP   [X-4],0x1
    065A: A0 5F    JZ    0x06BA
    065C: 3D FC 02 CMP   [X-4],0x2
    065F: A0 31    JZ    0x0691
    0661: 3D FC 03 CMP   [X-4],0x3
    0664: A0 80    JZ    0x06E5
    0666: 80 A9    JMP   0x0710
(0042) 				{
(0043) 					case 0:
(0044) 						if(isASC)
    0668: 3D FB 00 CMP   [X-5],0x0
    066B: A0 13    JZ    0x067F
(0045) 						{
(0046) 						LEDControl_ChangeState(TRUE,FALSE,FALSE);	
    066D: 50 00    MOV   A,0x0
    066F: 08       PUSH  A
    0670: 08       PUSH  A
    0671: 50 01    MOV   A,0x1
    0673: 08       PUSH  A
    0674: 9F A2    CALL  _LEDControl_ChangeState
    0676: 38 FD    ADD   SP,0xFD
(0047) 						return RED;
    0678: 62 D0 00 MOV   REG[0xD0],0x0
    067B: 50 03    MOV   A,0x3
    067D: 80 97    JMP   0x0715
(0048) 						}
(0049) 						else 
(0050) 						{
(0051) 						LEDControl_ChangeState(FALSE,FALSE,TRUE);	
    067F: 50 01    MOV   A,0x1
    0681: 08       PUSH  A
    0682: 50 00    MOV   A,0x0
    0684: 08       PUSH  A
    0685: 08       PUSH  A
    0686: 9F 90    CALL  _LEDControl_ChangeState
    0688: 38 FD    ADD   SP,0xFD
(0052) 						return BLUE;
    068A: 62 D0 00 MOV   REG[0xD0],0x0
    068D: 50 01    MOV   A,0x1
    068F: 80 85    JMP   0x0715
(0053) 						}
(0054) 						break;
(0055) 					case GREEN:
(0056) 						if(isASC)
    0691: 3D FB 00 CMP   [X-5],0x0
    0694: A0 13    JZ    0x06A8
(0057) 						{
(0058) 						LEDControl_ChangeState(FALSE,FALSE,TRUE);			
    0696: 50 01    MOV   A,0x1
    0698: 08       PUSH  A
    0699: 50 00    MOV   A,0x0
    069B: 08       PUSH  A
    069C: 08       PUSH  A
    069D: 9F 79    CALL  _LEDControl_ChangeState
    069F: 38 FD    ADD   SP,0xFD
(0059) 						return BLUE;
    06A1: 62 D0 00 MOV   REG[0xD0],0x0
    06A4: 50 01    MOV   A,0x1
    06A6: 80 6E    JMP   0x0715
(0060) 						}
(0061) 						else 
(0062) 						{
(0063) 						LEDControl_ChangeState(TRUE,FALSE,FALSE);	
    06A8: 50 00    MOV   A,0x0
    06AA: 08       PUSH  A
    06AB: 08       PUSH  A
    06AC: 50 01    MOV   A,0x1
    06AE: 08       PUSH  A
    06AF: 9F 67    CALL  _LEDControl_ChangeState
    06B1: 38 FD    ADD   SP,0xFD
(0064) 						return RED;
    06B3: 62 D0 00 MOV   REG[0xD0],0x0
    06B6: 50 03    MOV   A,0x3
    06B8: 80 5C    JMP   0x0715
(0065) 						}
(0066) 						break;
(0067) 					case BLUE:
(0068) 						if(isASC)
    06BA: 3D FB 00 CMP   [X-5],0x0
    06BD: A0 13    JZ    0x06D1
(0069) 						{
(0070) 						LEDControl_ChangeState(TRUE,FALSE,FALSE);		
    06BF: 50 00    MOV   A,0x0
    06C1: 08       PUSH  A
    06C2: 08       PUSH  A
    06C3: 50 01    MOV   A,0x1
    06C5: 08       PUSH  A
    06C6: 9F 50    CALL  _LEDControl_ChangeState
    06C8: 38 FD    ADD   SP,0xFD
(0071) 						return RED;
    06CA: 62 D0 00 MOV   REG[0xD0],0x0
    06CD: 50 03    MOV   A,0x3
    06CF: 80 45    JMP   0x0715
(0072) 						}
(0073) 						else 
(0074) 						{
(0075) 						LEDControl_ChangeState(FALSE,TRUE,FALSE);	
    06D1: 50 00    MOV   A,0x0
    06D3: 08       PUSH  A
    06D4: 50 01    MOV   A,0x1
    06D6: 08       PUSH  A
    06D7: 50 00    MOV   A,0x0
    06D9: 08       PUSH  A
    06DA: 9F 3C    CALL  _LEDControl_ChangeState
    06DC: 38 FD    ADD   SP,0xFD
(0076) 						return GREEN;
    06DE: 62 D0 00 MOV   REG[0xD0],0x0
    06E1: 50 02    MOV   A,0x2
    06E3: 80 31    JMP   0x0715
(0077) 						}
(0078) 						break;
(0079) 					case RED:
(0080) 						if(isASC)
    06E5: 3D FB 00 CMP   [X-5],0x0
    06E8: A0 15    JZ    0x06FE
(0081) 						{
(0082) 						LEDControl_ChangeState(FALSE,TRUE,FALSE);			
    06EA: 50 00    MOV   A,0x0
    06EC: 08       PUSH  A
    06ED: 50 01    MOV   A,0x1
    06EF: 08       PUSH  A
    06F0: 50 00    MOV   A,0x0
    06F2: 08       PUSH  A
    06F3: 9F 23    CALL  _LEDControl_ChangeState
    06F5: 38 FD    ADD   SP,0xFD
(0083) 						return GREEN;
    06F7: 62 D0 00 MOV   REG[0xD0],0x0
    06FA: 50 02    MOV   A,0x2
    06FC: 80 18    JMP   0x0715
(0084) 						}
(0085) 						else 
(0086) 						{
(0087) 						LEDControl_ChangeState(FALSE,FALSE,TRUE);	
    06FE: 50 01    MOV   A,0x1
    0700: 08       PUSH  A
    0701: 50 00    MOV   A,0x0
    0703: 08       PUSH  A
    0704: 08       PUSH  A
    0705: 9F 11    CALL  _LEDControl_ChangeState
    0707: 38 FD    ADD   SP,0xFD
(0088) 						return BLUE;
    0709: 62 D0 00 MOV   REG[0xD0],0x0
    070C: 50 01    MOV   A,0x1
    070E: 80 06    JMP   0x0715
(0089) 						}
(0090) 						break;
(0091) 					default:
(0092) 						return 0;
    0710: 62 D0 00 MOV   REG[0xD0],0x0
    0713: 50 00    MOV   A,0x0
(0093) 						break;
    0715: 20       POP   X
    0716: 20       POP   X
    0717: 7F       RET   
(0094) 				}
(0095) 			
(0096) }
(0097) void LEDControl_ChangeFrequency(BYTE led,int value,BYTE isAdd)
(0098) {
_LEDControl_ChangeFrequency:
  isAdd                --> X-7
  value                --> X-6
  led                  --> X-4
    0718: 10       PUSH  X
    0719: 4F       MOV   X,SP
    071A: 10       PUSH  X
(0099) 	switch (led)
    071B: 3D FC 01 CMP   [X-4],0x1
    071E: A0 51    JZ    0x0770
    0720: 3D FC 02 CMP   [X-4],0x2
    0723: A0 92    JZ    0x07B6
    0725: 3D FC 03 CMP   [X-4],0x3
    0728: B0 D1    JNZ   0x07FA
(0100) 		{
(0101) 			case RED:
(0102) 				if (isAdd)
    072A: 3D F9 00 CMP   [X-7],0x0
    072D: A0 2A    JZ    0x0758
(0103) 				{
(0104) 					LEDControl_RT=LEDControl_RT+value;
    072F: 62 D0 00 MOV   REG[0xD0],0x0
    0732: 52 FB    MOV   A,[X-5]
    0734: 04 21    ADD   [LEDControl_RT+1],A
    0736: 52 FA    MOV   A,[X-6]
    0738: 0C 20    ADC   [LEDControl_RT],A
(0105) 					if(LEDControl_RT>IntervalLimit)
    073A: 50 50    MOV   A,0x50
    073C: 12 21    SUB   A,[LEDControl_RT+1]
    073E: 51 20    MOV   A,[LEDControl_RT]
    0740: 31 80    XOR   A,0x80
    0742: 62 D0 00 MOV   REG[0xD0],0x0
    0745: 53 0F    MOV   [__rX],A
    0747: 50 80    MOV   A,0x80
    0749: 1A 0F    SBB   A,[__rX]
    074B: D0 AE    JNC   0x07FA
(0106) 					LEDControl_RT=IntervalLimit;
    074D: 62 D0 00 MOV   REG[0xD0],0x0
    0750: 55 21 50 MOV   [LEDControl_RT+1],0x50
    0753: 55 20 00 MOV   [LEDControl_RT],0x0
(0107) 				}
    0756: 80 A3    JMP   0x07FA
(0108) 				else 
(0109) 				{
(0110) 					LEDControl_RT=LEDControl_RT-value;	
    0758: 62 D0 00 MOV   REG[0xD0],0x0
    075B: 52 FB    MOV   A,[X-5]
    075D: 14 21    SUB   [LEDControl_RT+1],A
    075F: 52 FA    MOV   A,[X-6]
    0761: 1C 20    SBB   [LEDControl_RT],A
(0111) 					if(LEDControl_RT<0)
    0763: 47 20 80 TST   [LEDControl_RT],0x80
    0766: A0 93    JZ    0x07FA
(0112) 						LEDControl_RT=0;
    0768: 55 21 00 MOV   [LEDControl_RT+1],0x0
    076B: 55 20 00 MOV   [LEDControl_RT],0x0
(0113) 				}
(0114) 				break;
    076E: 80 8B    JMP   0x07FA
(0115) 			case BLUE:
(0116) 				if (isAdd)
    0770: 3D F9 00 CMP   [X-7],0x0
    0773: A0 2A    JZ    0x079E
(0117) 				{
(0118) 					LEDControl_BT=LEDControl_BT+value;
    0775: 62 D0 00 MOV   REG[0xD0],0x0
    0778: 52 FB    MOV   A,[X-5]
    077A: 04 1D    ADD   [LEDControl_BT+1],A
    077C: 52 FA    MOV   A,[X-6]
    077E: 0C 1C    ADC   [LEDControl_BT],A
(0119) 					if(LEDControl_BT>IntervalLimit)
    0780: 50 50    MOV   A,0x50
    0782: 12 1D    SUB   A,[LEDControl_BT+1]
    0784: 51 1C    MOV   A,[LEDControl_BT]
    0786: 31 80    XOR   A,0x80
    0788: 62 D0 00 MOV   REG[0xD0],0x0
    078B: 53 0F    MOV   [__rX],A
    078D: 50 80    MOV   A,0x80
    078F: 1A 0F    SBB   A,[__rX]
    0791: D0 68    JNC   0x07FA
(0120) 					LEDControl_BT=IntervalLimit;
    0793: 62 D0 00 MOV   REG[0xD0],0x0
    0796: 55 1D 50 MOV   [LEDControl_BT+1],0x50
    0799: 55 1C 00 MOV   [LEDControl_BT],0x0
(0121) 				}
    079C: 80 5D    JMP   0x07FA
(0122) 				else 
(0123) 				{
(0124) 					LEDControl_BT=LEDControl_BT-value;	
    079E: 62 D0 00 MOV   REG[0xD0],0x0
    07A1: 52 FB    MOV   A,[X-5]
    07A3: 14 1D    SUB   [LEDControl_BT+1],A
    07A5: 52 FA    MOV   A,[X-6]
    07A7: 1C 1C    SBB   [LEDControl_BT],A
(0125) 					if(LEDControl_BT<0)
    07A9: 47 1C 80 TST   [LEDControl_BT],0x80
    07AC: A0 4D    JZ    0x07FA
(0126) 					LEDControl_BT=0;
    07AE: 55 1D 00 MOV   [LEDControl_BT+1],0x0
    07B1: 55 1C 00 MOV   [LEDControl_BT],0x0
(0127) 				}
(0128) 				break;
    07B4: 80 45    JMP   0x07FA
(0129) 			case GREEN:
(0130) 				if (isAdd)
    07B6: 3D F9 00 CMP   [X-7],0x0
    07B9: A0 2A    JZ    0x07E4
(0131) 				{
(0132) 					LEDControl_GT=LEDControl_GT+value;
    07BB: 62 D0 00 MOV   REG[0xD0],0x0
    07BE: 52 FB    MOV   A,[X-5]
    07C0: 04 1F    ADD   [LEDControl_GT+1],A
    07C2: 52 FA    MOV   A,[X-6]
    07C4: 0C 1E    ADC   [LEDControl_GT],A
(0133) 					if(LEDControl_GT>IntervalLimit)
    07C6: 50 50    MOV   A,0x50
    07C8: 12 1F    SUB   A,[LEDControl_GT+1]
    07CA: 51 1E    MOV   A,[LEDControl_GT]
    07CC: 31 80    XOR   A,0x80
    07CE: 62 D0 00 MOV   REG[0xD0],0x0
    07D1: 53 0F    MOV   [__rX],A
    07D3: 50 80    MOV   A,0x80
    07D5: 1A 0F    SBB   A,[__rX]
    07D7: D0 22    JNC   0x07FA
(0134) 					LEDControl_GT=IntervalLimit;
    07D9: 62 D0 00 MOV   REG[0xD0],0x0
    07DC: 55 1F 50 MOV   [LEDControl_GT+1],0x50
    07DF: 55 1E 00 MOV   [LEDControl_GT],0x0
(0135) 				}
    07E2: 80 17    JMP   0x07FA
(0136) 				else 
(0137) 				{
(0138) 					LEDControl_GT=LEDControl_GT-value;	
    07E4: 62 D0 00 MOV   REG[0xD0],0x0
    07E7: 52 FB    MOV   A,[X-5]
    07E9: 14 1F    SUB   [LEDControl_GT+1],A
    07EB: 52 FA    MOV   A,[X-6]
    07ED: 1C 1E    SBB   [LEDControl_GT],A
(0139) 					if(LEDControl_GT<0)
    07EF: 47 1E 80 TST   [LEDControl_GT],0x80
    07F2: A0 07    JZ    0x07FA
(0140) 					LEDControl_GT=0;
    07F4: 55 1F 00 MOV   [LEDControl_GT+1],0x0
    07F7: 55 1E 00 MOV   [LEDControl_GT],0x0
(0141) 				}
(0142) 				break;
(0143) 			default:
(0144) 				break; 
    07FA: 20       POP   X
    07FB: 20       POP   X
    07FC: 7F       RET   
(0145) 		}
(0146) }
(0147) int LEDControl_Blink(BYTE led, int blinkLoop)
(0148) {
_LEDControl_Blink:
  blinkLoop            --> X-6
  led                  --> X-4
    07FD: 10       PUSH  X
    07FE: 4F       MOV   X,SP
    07FF: 10       PUSH  X
(0149) 	switch (led)
    0800: 3D FC 01 CMP   [X-4],0x1
    0803: A0 3B    JZ    0x083F
    0805: 3D FC 02 CMP   [X-4],0x2
    0808: A0 66    JZ    0x086F
    080A: 3D FC 03 CMP   [X-4],0x3
    080D: B0 91    JNZ   0x089F
(0150) 		{
(0151) 			case RED:
(0152) 				if (blinkLoop>=LEDControl_RT)
    080F: 62 D0 00 MOV   REG[0xD0],0x0
    0812: 52 FB    MOV   A,[X-5]
    0814: 12 21    SUB   A,[LEDControl_RT+1]
    0816: 51 20    MOV   A,[LEDControl_RT]
    0818: 31 80    XOR   A,0x80
    081A: 62 D0 00 MOV   REG[0xD0],0x0
    081D: 53 0F    MOV   [__rX],A
    081F: 52 FA    MOV   A,[X-6]
    0821: 31 80    XOR   A,0x80
    0823: 1A 0F    SBB   A,[__rX]
    0825: C0 0C    JC    0x0832
(0153) 				{
(0154) 					LED_RED_Invert();
    0827: 10       PUSH  X
    0828: 7C 03 22 LCALL _LED_RED_Invert
    082B: 20       POP   X
(0155) 					blinkLoop = 0;
    082C: 56 FB 00 MOV   [X-5],0x0
    082F: 56 FA 00 MOV   [X-6],0x0
(0156) 				}
(0157) 				return blinkLoop;
    0832: 62 D0 00 MOV   REG[0xD0],0x0
    0835: 52 FB    MOV   A,[X-5]
    0837: 53 1A    MOV   [__r1],A
    0839: 52 FA    MOV   A,[X-6]
    083B: 53 1B    MOV   [__r0],A
    083D: 80 6C    JMP   0x08AA
(0158) 				break;
(0159) 			case BLUE:
(0160) 				if (blinkLoop>=LEDControl_BT)
    083F: 62 D0 00 MOV   REG[0xD0],0x0
    0842: 52 FB    MOV   A,[X-5]
    0844: 12 1D    SUB   A,[LEDControl_BT+1]
    0846: 51 1C    MOV   A,[LEDControl_BT]
    0848: 31 80    XOR   A,0x80
    084A: 62 D0 00 MOV   REG[0xD0],0x0
    084D: 53 0F    MOV   [__rX],A
    084F: 52 FA    MOV   A,[X-6]
    0851: 31 80    XOR   A,0x80
    0853: 1A 0F    SBB   A,[__rX]
    0855: C0 0C    JC    0x0862
(0161) 				{
(0162) 					LED_BLUE_Invert();
    0857: 10       PUSH  X
    0858: 7C 03 9C LCALL _LED_BLUE_Invert
    085B: 20       POP   X
(0163) 					blinkLoop = 0;
    085C: 56 FB 00 MOV   [X-5],0x0
    085F: 56 FA 00 MOV   [X-6],0x0
(0164) 				}
(0165) 				return blinkLoop;
    0862: 62 D0 00 MOV   REG[0xD0],0x0
    0865: 52 FB    MOV   A,[X-5]
    0867: 53 1A    MOV   [__r1],A
    0869: 52 FA    MOV   A,[X-6]
    086B: 53 1B    MOV   [__r0],A
    086D: 80 3C    JMP   0x08AA
(0166) 				break;
(0167) 			case GREEN:
(0168) 				if (blinkLoop>=LEDControl_GT)
    086F: 62 D0 00 MOV   REG[0xD0],0x0
    0872: 52 FB    MOV   A,[X-5]
    0874: 12 1F    SUB   A,[LEDControl_GT+1]
    0876: 51 1E    MOV   A,[LEDControl_GT]
    0878: 31 80    XOR   A,0x80
    087A: 62 D0 00 MOV   REG[0xD0],0x0
    087D: 53 0F    MOV   [__rX],A
    087F: 52 FA    MOV   A,[X-6]
    0881: 31 80    XOR   A,0x80
    0883: 1A 0F    SBB   A,[__rX]
    0885: C0 0C    JC    0x0892
(0169) 				{
(0170) 					LED_GREEN_Invert();
    0887: 10       PUSH  X
    0888: 7C 03 5F LCALL _LED_GREEN_Invert
    088B: 20       POP   X
(0171) 					blinkLoop = 0;
    088C: 56 FB 00 MOV   [X-5],0x0
    088F: 56 FA 00 MOV   [X-6],0x0
(0172) 				}
(0173) 				return blinkLoop;
    0892: 62 D0 00 MOV   REG[0xD0],0x0
    0895: 52 FB    MOV   A,[X-5]
    0897: 53 1A    MOV   [__r1],A
    0899: 52 FA    MOV   A,[X-6]
    089B: 53 1B    MOV   [__r0],A
    089D: 80 0C    JMP   0x08AA
(0174) 				break;
(0175) 			default:
(0176) 			return blinkLoop;
    089F: 62 D0 00 MOV   REG[0xD0],0x0
    08A2: 52 FB    MOV   A,[X-5]
    08A4: 53 1A    MOV   [__r1],A
    08A6: 52 FA    MOV   A,[X-6]
    08A8: 53 1B    MOV   [__r0],A
(0177) 				break; 
    08AA: 20       POP   X
(0178) 		}
(0179) }
    08AB: 20       POP   X
    08AC: 7F       RET   
FILE: D:\Studia\PSOC\TEMP\TEMP\main.c
(0001) #include <m8c.h>        /* part specific constants and macros */
(0002) #include "PSoCAPI.h"    /* PSoC API definitions for all User Modules */
(0003) #include "LEDControl.h"
(0004) #include "TempControl.h"
(0005) 
(0006) void main(void)
(0007) {
_main:
    08AD: 10       PUSH  X
    08AE: 4F       MOV   X,SP
    08AF: 38 02    ADD   SP,0x2
(0008) 
(0009) 
(0010) 	M8C_EnableGInt; 
    08B1: 71 01    OR    F,0x1
(0011) 	LEDControl_INIT();
    08B3: 7C 06 09 LCALL __UserModules_end|_LEDControl_INIT|__text_start|_LEDControl_INIT
    08B6: 80 6F    JMP   0x0926
(0012) 	
(0013) 	while(1)
(0014) 	{		
(0015) 		switch(TempControl_GetValue())
    08B8: 7C 0F 56 LCALL _TempControl_GetValue
    08BB: 62 D0 00 MOV   REG[0xD0],0x0
    08BE: 51 1A    MOV   A,[__r1]
    08C0: 54 01    MOV   [X+1],A
    08C2: 51 1B    MOV   A,[__r0]
    08C4: 54 00    MOV   [X+0],A
    08C6: 3D 00 00 CMP   [X+0],0x0
    08C9: B0 06    JNZ   0x08D0
    08CB: 3D 01 00 CMP   [X+1],0x0
    08CE: A0 21    JZ    0x08F0
    08D0: 3D 00 00 CMP   [X+0],0x0
    08D3: B0 06    JNZ   0x08DA
    08D5: 3D 01 01 CMP   [X+1],0x1
    08D8: A0 23    JZ    0x08FC
    08DA: 3D 00 00 CMP   [X+0],0x0
    08DD: B0 06    JNZ   0x08E4
    08DF: 3D 01 02 CMP   [X+1],0x2
    08E2: A0 27    JZ    0x090A
    08E4: 3D 00 00 CMP   [X+0],0x0
    08E7: B0 06    JNZ   0x08EE
    08E9: 3D 01 03 CMP   [X+1],0x3
    08EC: A0 2D    JZ    0x091A
    08EE: 80 37    JMP   0x0926
(0016) 		{
(0017) 			case 0:
(0018) 				LEDControl_ChangeState(FALSE,FALSE,FALSE); 
    08F0: 50 00    MOV   A,0x0
    08F2: 08       PUSH  A
    08F3: 08       PUSH  A
    08F4: 08       PUSH  A
    08F5: 7C 06 18 LCALL _LEDControl_ChangeState
    08F8: 38 FD    ADD   SP,0xFD
(0019) 				break;
    08FA: 80 2B    JMP   0x0926
(0020) 			case 1:
(0021) 				LEDControl_ChangeState(FALSE,FALSE,TRUE); 
    08FC: 50 01    MOV   A,0x1
    08FE: 08       PUSH  A
    08FF: 50 00    MOV   A,0x0
    0901: 08       PUSH  A
    0902: 08       PUSH  A
    0903: 7C 06 18 LCALL _LEDControl_ChangeState
    0906: 38 FD    ADD   SP,0xFD
(0022) 				break;
    0908: 80 1D    JMP   0x0926
(0023) 			case 2:
(0024) 				LEDControl_ChangeState(FALSE,TRUE,FALSE);
    090A: 50 00    MOV   A,0x0
    090C: 08       PUSH  A
    090D: 50 01    MOV   A,0x1
    090F: 08       PUSH  A
    0910: 50 00    MOV   A,0x0
    0912: 08       PUSH  A
    0913: 7C 06 18 LCALL _LEDControl_ChangeState
    0916: 38 FD    ADD   SP,0xFD
(0025) 				break;
    0918: 80 0D    JMP   0x0926
(0026) 			case 3:
(0027) 				LEDControl_ChangeState(TRUE,FALSE,FALSE);
    091A: 50 00    MOV   A,0x0
    091C: 08       PUSH  A
    091D: 08       PUSH  A
    091E: 50 01    MOV   A,0x1
    0920: 08       PUSH  A
    0921: 7C 06 18 LCALL _LEDControl_ChangeState
    0924: 38 FD    ADD   SP,0xFD
(0028) 				break;
(0029) 			default: 
(0030) 				break;
(0031) 		}	
(0032) 	}
    0926: 8F 91    JMP   0x08B8
(0033) }
(0034) 
    0927: 91 38    CALL  0x0A61
    0929: FE 20    INDEX 0x074B
    092B: 8F FF    JMP   0x092B
FILE: D:\Studia\PSOC\TEMP\TEMP\tempcontrol.c
(0001) 
(0002) #include <m8c.h>        /* part specific constants and macros */
(0003) #include "PSoCAPI.h"
(0004) #include "TempControl.h"
(0005) 
(0006) 
(0007) #define	MIN		-101
(0008) #define	MAX		551	
(0009) #define COUNT_VALUES    23
(0010) #define REF_RESISTOR	10000
(0011) #define REF_VOLTAGE		0x2FB
(0012) //Defines for enabling Temperature Input
(0013) #define ReadVTEMPInput      (ABF_CR0 = 0x00)
(0014) #define ReadVTEMP_EXCInput  (ABF_CR0 = 0x80)
(0015) 
(0016) const int arTherm[2][COUNT_VALUES] = 
(0017) {   
(0018)    {2301, 2505, 2725, 2960, 3211, 3477, 3757, 4051, 4358, 4675, 5000, 5331, 5664, 5998, 6328, 6652, 6967, 7269, 7557, 7829, 8083, 8317,  8462},
(0019)    {5500, 5200, 4900, 4600, 4300, 4000, 3700, 3400, 3100, 2800, 2500, 2200, 1900, 1600, 1300, 1000,  700,  400,  100, -200, -500, -800, -1000}   // array of temperature values (in hundredths of a deg C)
(0020) //     1           3           5           7           9          11          13          15          17          19          21           23
(0021) };
(0022) typedef struct ThermistorValue
(0023) {
(0024) 	long lVtherm;
(0025) 	long ivalue1;
(0026) }ThermistorValue;
(0027) 
(0028) int CalculateTemperature(ThermistorValue thermistorValue)
(0029) {
_CalculateTemperature:
  itemp1               --> X+13
  itemp2               --> X+9
  ivalue1              --> X+5
  ivalue2              --> X+1
  bPointIndex          --> X+0
  thermistorValue      --> X-5
    092D: 10       PUSH  X
    092E: 4F       MOV   X,SP
    092F: 38 15    ADD   SP,0x15
(0030) 	BYTE bPointIndex;
(0031) 	long ivalue1,ivalue2,itemp1,itemp2;
(0032) 	thermistorValue.lVtherm *= REF_RESISTOR;	// Calculate the thermistor voltage value
    0931: 62 D0 00 MOV   REG[0xD0],0x0
    0934: 52 FC    MOV   A,[X-4]
    0936: 53 1A    MOV   [__r1],A
    0938: 52 FB    MOV   A,[X-5]
    093A: 60 D4    MOV   REG[0xD4],A
    093C: 3E 1A    MVI   A,[__r1]
    093E: 53 17    MOV   [__r4],A
    0940: 3E 1A    MVI   A,[__r1]
    0942: 53 16    MOV   [__r5],A
    0944: 3E 1A    MVI   A,[__r1]
    0946: 53 15    MOV   [__r6],A
    0948: 3E 1A    MVI   A,[__r1]
    094A: 53 14    MOV   [__r7],A
    094C: 51 17    MOV   A,[__r4]
    094E: 08       PUSH  A
    094F: 51 16    MOV   A,[__r5]
    0951: 08       PUSH  A
    0952: 51 15    MOV   A,[__r6]
    0954: 08       PUSH  A
    0955: 51 14    MOV   A,[__r7]
    0957: 08       PUSH  A
    0958: 50 00    MOV   A,0x0
    095A: 08       PUSH  A
    095B: 08       PUSH  A
    095C: 50 27    MOV   A,0x27
    095E: 08       PUSH  A
    095F: 50 10    MOV   A,0x10
    0961: 08       PUSH  A
    0962: 7C 10 95 LCALL 0x1095
    0965: 38 FC    ADD   SP,0xFC
    0967: 18       POP   A
    0968: 53 18    MOV   [__r3],A
    096A: 18       POP   A
    096B: 53 19    MOV   [__r2],A
    096D: 18       POP   A
    096E: 53 1A    MOV   [__r1],A
    0970: 18       POP   A
    0971: 53 1B    MOV   [__r0],A
    0973: 52 FC    MOV   A,[X-4]
    0975: 53 16    MOV   [__r5],A
    0977: 52 FB    MOV   A,[X-5]
    0979: 60 D5    MOV   REG[0xD5],A
    097B: 51 1B    MOV   A,[__r0]
    097D: 3F 16    MVI   [__r5],A
    097F: 51 1A    MOV   A,[__r1]
    0981: 3F 16    MVI   [__r5],A
    0983: 51 19    MOV   A,[__r2]
    0985: 3F 16    MVI   [__r5],A
    0987: 51 18    MOV   A,[__r3]
    0989: 3F 16    MVI   [__r5],A
(0033) 	thermistorValue.lVtherm /= thermistorValue.ivalue1;			// get voltage ratio of thermistor voltage and excitation voltage
    098B: 52 FC    MOV   A,[X-4]
    098D: 01 04    ADD   A,0x4
    098F: 53 1A    MOV   [__r1],A
    0991: 52 FB    MOV   A,[X-5]
    0993: 09 00    ADC   A,0x0
    0995: 60 D4    MOV   REG[0xD4],A
    0997: 3E 1A    MVI   A,[__r1]
    0999: 53 17    MOV   [__r4],A
    099B: 3E 1A    MVI   A,[__r1]
    099D: 53 16    MOV   [__r5],A
    099F: 3E 1A    MVI   A,[__r1]
    09A1: 53 15    MOV   [__r6],A
    09A3: 3E 1A    MVI   A,[__r1]
    09A5: 53 14    MOV   [__r7],A
    09A7: 52 FC    MOV   A,[X-4]
    09A9: 53 1A    MOV   [__r1],A
    09AB: 52 FB    MOV   A,[X-5]
    09AD: 60 D4    MOV   REG[0xD4],A
    09AF: 3E 1A    MVI   A,[__r1]
    09B1: 53 13    MOV   [__r8],A
    09B3: 3E 1A    MVI   A,[__r1]
    09B5: 53 12    MOV   [__r9],A
    09B7: 3E 1A    MVI   A,[__r1]
    09B9: 53 11    MOV   [__r10],A
    09BB: 3E 1A    MVI   A,[__r1]
    09BD: 53 10    MOV   [__r11],A
    09BF: 51 17    MOV   A,[__r4]
    09C1: 08       PUSH  A
    09C2: 51 16    MOV   A,[__r5]
    09C4: 08       PUSH  A
    09C5: 51 15    MOV   A,[__r6]
    09C7: 08       PUSH  A
    09C8: 51 14    MOV   A,[__r7]
    09CA: 08       PUSH  A
    09CB: 51 13    MOV   A,[__r8]
    09CD: 08       PUSH  A
    09CE: 51 12    MOV   A,[__r9]
    09D0: 08       PUSH  A
    09D1: 51 11    MOV   A,[__r10]
    09D3: 08       PUSH  A
    09D4: 51 10    MOV   A,[__r11]
    09D6: 08       PUSH  A
    09D7: 7C 0F DD LCALL 0x0FDD
    09DA: 18       POP   A
    09DB: 53 18    MOV   [__r3],A
    09DD: 18       POP   A
    09DE: 53 19    MOV   [__r2],A
    09E0: 18       POP   A
    09E1: 53 1A    MOV   [__r1],A
    09E3: 18       POP   A
    09E4: 53 1B    MOV   [__r0],A
    09E6: 38 FC    ADD   SP,0xFC
    09E8: 52 FC    MOV   A,[X-4]
    09EA: 53 16    MOV   [__r5],A
    09EC: 52 FB    MOV   A,[X-5]
    09EE: 60 D5    MOV   REG[0xD5],A
    09F0: 51 1B    MOV   A,[__r0]
    09F2: 3F 16    MVI   [__r5],A
    09F4: 51 1A    MOV   A,[__r1]
    09F6: 3F 16    MVI   [__r5],A
    09F8: 51 19    MOV   A,[__r2]
    09FA: 3F 16    MVI   [__r5],A
    09FC: 51 18    MOV   A,[__r3]
    09FE: 3F 16    MVI   [__r5],A
(0034) 
(0035) 	if ((int)thermistorValue.lVtherm < arTherm[0][0])
    0A00: 50 01    MOV   A,0x1
    0A02: 10       PUSH  X
    0A03: 57 50    MOV   X,0x50
    0A05: 7C 10 E0 LCALL __lpmw
    0A08: 53 1A    MOV   [__r1],A
    0A0A: 51 0F    MOV   A,[__rX]
    0A0C: 53 1B    MOV   [__r0],A
    0A0E: 20       POP   X
    0A0F: 52 FC    MOV   A,[X-4]
    0A11: 53 18    MOV   [__r3],A
    0A13: 52 FB    MOV   A,[X-5]
    0A15: 60 D4    MOV   REG[0xD4],A
    0A17: 3E 18    MVI   A,[__r3]
    0A19: 3E 18    MVI   A,[__r3]
    0A1B: 3E 18    MVI   A,[__r3]
    0A1D: 53 15    MOV   [__r6],A
    0A1F: 3E 18    MVI   A,[__r3]
    0A21: 53 18    MOV   [__r3],A
    0A23: 51 15    MOV   A,[__r6]
    0A25: 53 19    MOV   [__r2],A
    0A27: 51 18    MOV   A,[__r3]
    0A29: 12 1A    SUB   A,[__r1]
    0A2B: 51 1B    MOV   A,[__r0]
    0A2D: 31 80    XOR   A,0x80
    0A2F: 53 0F    MOV   [__rX],A
    0A31: 51 19    MOV   A,[__r2]
    0A33: 31 80    XOR   A,0x80
    0A35: 1A 0F    SBB   A,[__rX]
    0A37: D0 1C    JNC   0x0A54
(0036) 	{
(0037) 		// The voltage ratio is too low, so the temperature is greater than what can be measured                
(0038) 		thermistorValue.lVtherm = MAX;
    0A39: 62 D0 00 MOV   REG[0xD0],0x0
    0A3C: 52 FC    MOV   A,[X-4]
    0A3E: 53 1A    MOV   [__r1],A
    0A40: 52 FB    MOV   A,[X-5]
    0A42: 60 D5    MOV   REG[0xD5],A
    0A44: 50 00    MOV   A,0x0
    0A46: 3F 1A    MVI   [__r1],A
    0A48: 3F 1A    MVI   [__r1],A
    0A4A: 50 02    MOV   A,0x2
    0A4C: 3F 1A    MVI   [__r1],A
    0A4E: 50 27    MOV   A,0x27
    0A50: 3F 1A    MVI   [__r1],A
(0039) 	}
    0A52: 83 BD    JMP   0x0E10
(0040) 	else if((int)thermistorValue.lVtherm > arTherm[0][COUNT_VALUES-1])
    0A54: 62 D0 00 MOV   REG[0xD0],0x0
    0A57: 50 01    MOV   A,0x1
    0A59: 10       PUSH  X
    0A5A: 57 7C    MOV   X,0x7C
    0A5C: 7C 10 E0 LCALL __lpmw
    0A5F: 53 1A    MOV   [__r1],A
    0A61: 51 0F    MOV   A,[__rX]
    0A63: 53 1B    MOV   [__r0],A
    0A65: 20       POP   X
    0A66: 52 FC    MOV   A,[X-4]
    0A68: 53 18    MOV   [__r3],A
    0A6A: 52 FB    MOV   A,[X-5]
    0A6C: 60 D4    MOV   REG[0xD4],A
    0A6E: 3E 18    MVI   A,[__r3]
    0A70: 3E 18    MVI   A,[__r3]
    0A72: 3E 18    MVI   A,[__r3]
    0A74: 53 15    MOV   [__r6],A
    0A76: 3E 18    MVI   A,[__r3]
    0A78: 53 18    MOV   [__r3],A
    0A7A: 51 15    MOV   A,[__r6]
    0A7C: 53 19    MOV   [__r2],A
    0A7E: 51 1A    MOV   A,[__r1]
    0A80: 12 18    SUB   A,[__r3]
    0A82: 51 19    MOV   A,[__r2]
    0A84: 31 80    XOR   A,0x80
    0A86: 53 0F    MOV   [__rX],A
    0A88: 51 1B    MOV   A,[__r0]
    0A8A: 31 80    XOR   A,0x80
    0A8C: 1A 0F    SBB   A,[__rX]
    0A8E: D0 1A    JNC   0x0AA9
(0041) 	{
(0042) 		// The voltage ratio is too high, so the temperature is less than what can be measured.
(0043) 		thermistorValue.lVtherm = MIN; 
    0A90: 62 D0 00 MOV   REG[0xD0],0x0
    0A93: 52 FC    MOV   A,[X-4]
    0A95: 53 1A    MOV   [__r1],A
    0A97: 52 FB    MOV   A,[X-5]
    0A99: 60 D5    MOV   REG[0xD5],A
    0A9B: 50 FF    MOV   A,0xFF
    0A9D: 3F 1A    MVI   [__r1],A
    0A9F: 3F 1A    MVI   [__r1],A
    0AA1: 3F 1A    MVI   [__r1],A
    0AA3: 50 9B    MOV   A,0x9B
    0AA5: 3F 1A    MVI   [__r1],A
(0044) 	}
    0AA7: 83 68    JMP   0x0E10
(0045) 	else 
(0046) 	{  
(0047) 		// Scan through the voltage ratio values in the piecewise linear curve fit data to find
(0048)         // the appropriate line to interpolate                
(0049) 		for(bPointIndex = 0; bPointIndex < (COUNT_VALUES-2); bPointIndex++) 
    0AA9: 56 00 00 MOV   [X+0],0x0
    0AAC: 80 7D    JMP   0x0B2A
(0050) 		{																			
(0051) 			if (thermistorValue.lVtherm < arTherm[0][bPointIndex+1])  break;
    0AAE: 62 D0 00 MOV   REG[0xD0],0x0
    0AB1: 52 00    MOV   A,[X+0]
    0AB3: 53 1A    MOV   [__r1],A
    0AB5: 55 1B 00 MOV   [__r0],0x0
    0AB8: 06 1A 01 ADD   [__r1],0x1
    0ABB: 0E 1B 00 ADC   [__r0],0x0
    0ABE: 65 1A    ASL   [__r1]
    0AC0: 6B 1B    RLC   [__r0]
    0AC2: 06 1A 50 ADD   [__r1],0x50
    0AC5: 0E 1B 01 ADC   [__r0],0x1
    0AC8: 51 1B    MOV   A,[__r0]
    0ACA: 10       PUSH  X
    0ACB: 58 1A    MOV   X,[__r1]
    0ACD: 7C 10 E0 LCALL __lpmw
    0AD0: 53 1A    MOV   [__r1],A
    0AD2: 51 0F    MOV   A,[__rX]
    0AD4: 53 1B    MOV   [__r0],A
    0AD6: 20       POP   X
    0AD7: 51 1A    MOV   A,[__r1]
    0AD9: 53 18    MOV   [__r3],A
    0ADB: 51 1B    MOV   A,[__r0]
    0ADD: 53 19    MOV   [__r2],A
    0ADF: 47 19 80 TST   [__r2],0x80
    0AE2: A0 09    JZ    0x0AEC
    0AE4: 55 1A FF MOV   [__r1],0xFF
    0AE7: 55 1B FF MOV   [__r0],0xFF
    0AEA: 80 0A    JMP   0x0AF5
    0AEC: 62 D0 00 MOV   REG[0xD0],0x0
    0AEF: 55 1A 00 MOV   [__r1],0x0
    0AF2: 55 1B 00 MOV   [__r0],0x0
    0AF5: 62 D0 00 MOV   REG[0xD0],0x0
    0AF8: 52 FC    MOV   A,[X-4]
    0AFA: 53 16    MOV   [__r5],A
    0AFC: 52 FB    MOV   A,[X-5]
    0AFE: 60 D4    MOV   REG[0xD4],A
    0B00: 3E 16    MVI   A,[__r5]
    0B02: 53 13    MOV   [__r8],A
    0B04: 3E 16    MVI   A,[__r5]
    0B06: 53 12    MOV   [__r9],A
    0B08: 3E 16    MVI   A,[__r5]
    0B0A: 53 11    MOV   [__r10],A
    0B0C: 3E 16    MVI   A,[__r5]
    0B0E: 12 18    SUB   A,[__r3]
    0B10: 51 11    MOV   A,[__r10]
    0B12: 1A 19    SBB   A,[__r2]
    0B14: 51 12    MOV   A,[__r9]
    0B16: 1A 1A    SBB   A,[__r1]
    0B18: 51 1B    MOV   A,[__r0]
    0B1A: 31 80    XOR   A,0x80
    0B1C: 53 0F    MOV   [__rX],A
    0B1E: 51 13    MOV   A,[__r8]
    0B20: 31 80    XOR   A,0x80
    0B22: 1A 0F    SBB   A,[__rX]
    0B24: D0 03    JNC   0x0B28
    0B26: 80 08    JMP   0x0B2F
(0052) 		}
    0B28: 77 00    INC   [X+0]
    0B2A: 3D 00 15 CMP   [X+0],0x15
    0B2D: CF 80    JC    0x0AAE
(0053) 	
(0054) 		// Retrieve the voltage ratios for interpolation
(0055) 		ivalue1 = arTherm[0][bPointIndex];
    0B2F: 62 D0 00 MOV   REG[0xD0],0x0
    0B32: 52 00    MOV   A,[X+0]
    0B34: 53 1A    MOV   [__r1],A
    0B36: 55 1B 00 MOV   [__r0],0x0
    0B39: 65 1A    ASL   [__r1]
    0B3B: 6B 1B    RLC   [__r0]
    0B3D: 06 1A 50 ADD   [__r1],0x50
    0B40: 0E 1B 01 ADC   [__r0],0x1
    0B43: 51 1B    MOV   A,[__r0]
    0B45: 10       PUSH  X
    0B46: 58 1A    MOV   X,[__r1]
    0B48: 7C 10 E0 LCALL __lpmw
    0B4B: 53 1A    MOV   [__r1],A
    0B4D: 51 0F    MOV   A,[__rX]
    0B4F: 53 1B    MOV   [__r0],A
    0B51: 20       POP   X
    0B52: 51 1A    MOV   A,[__r1]
    0B54: 54 08    MOV   [X+8],A
    0B56: 51 1B    MOV   A,[__r0]
    0B58: 54 07    MOV   [X+7],A
    0B5A: 48 07 80 TST   [X+7],0x80
    0B5D: A0 09    JZ    0x0B67
    0B5F: 56 06 FF MOV   [X+6],0xFF
    0B62: 56 05 FF MOV   [X+5],0xFF
    0B65: 80 07    JMP   0x0B6D
    0B67: 56 06 00 MOV   [X+6],0x0
    0B6A: 56 05 00 MOV   [X+5],0x0
(0056) 		ivalue2 = arTherm[0][bPointIndex + 1];
    0B6D: 62 D0 00 MOV   REG[0xD0],0x0
    0B70: 52 00    MOV   A,[X+0]
    0B72: 53 1A    MOV   [__r1],A
    0B74: 55 1B 00 MOV   [__r0],0x0
    0B77: 06 1A 01 ADD   [__r1],0x1
    0B7A: 0E 1B 00 ADC   [__r0],0x0
    0B7D: 65 1A    ASL   [__r1]
    0B7F: 6B 1B    RLC   [__r0]
    0B81: 06 1A 50 ADD   [__r1],0x50
    0B84: 0E 1B 01 ADC   [__r0],0x1
    0B87: 51 1B    MOV   A,[__r0]
    0B89: 10       PUSH  X
    0B8A: 58 1A    MOV   X,[__r1]
    0B8C: 7C 10 E0 LCALL __lpmw
    0B8F: 53 1A    MOV   [__r1],A
    0B91: 51 0F    MOV   A,[__rX]
    0B93: 53 1B    MOV   [__r0],A
    0B95: 20       POP   X
    0B96: 51 1A    MOV   A,[__r1]
    0B98: 54 04    MOV   [X+4],A
    0B9A: 51 1B    MOV   A,[__r0]
    0B9C: 54 03    MOV   [X+3],A
    0B9E: 48 03 80 TST   [X+3],0x80
    0BA1: A0 09    JZ    0x0BAB
    0BA3: 56 02 FF MOV   [X+2],0xFF
    0BA6: 56 01 FF MOV   [X+1],0xFF
    0BA9: 80 07    JMP   0x0BB1
    0BAB: 56 02 00 MOV   [X+2],0x0
    0BAE: 56 01 00 MOV   [X+1],0x0
(0057) 
(0058)         // Retrieve the temperatures for interpolation
(0059) 		itemp1 = arTherm[1][bPointIndex];
    0BB1: 62 D0 00 MOV   REG[0xD0],0x0
    0BB4: 52 00    MOV   A,[X+0]
    0BB6: 53 1A    MOV   [__r1],A
    0BB8: 55 1B 00 MOV   [__r0],0x0
    0BBB: 65 1A    ASL   [__r1]
    0BBD: 6B 1B    RLC   [__r0]
    0BBF: 06 1A 7E ADD   [__r1],0x7E
    0BC2: 0E 1B 01 ADC   [__r0],0x1
    0BC5: 51 1B    MOV   A,[__r0]
    0BC7: 10       PUSH  X
    0BC8: 58 1A    MOV   X,[__r1]
    0BCA: 7C 10 E0 LCALL __lpmw
    0BCD: 53 1A    MOV   [__r1],A
    0BCF: 51 0F    MOV   A,[__rX]
    0BD1: 53 1B    MOV   [__r0],A
    0BD3: 20       POP   X
    0BD4: 51 1A    MOV   A,[__r1]
    0BD6: 54 10    MOV   [X+16],A
    0BD8: 51 1B    MOV   A,[__r0]
    0BDA: 54 0F    MOV   [X+15],A
    0BDC: 48 0F 80 TST   [X+15],0x80
    0BDF: A0 09    JZ    0x0BE9
    0BE1: 56 0E FF MOV   [X+14],0xFF
    0BE4: 56 0D FF MOV   [X+13],0xFF
    0BE7: 80 07    JMP   0x0BEF
    0BE9: 56 0E 00 MOV   [X+14],0x0
    0BEC: 56 0D 00 MOV   [X+13],0x0
(0060) 		itemp2 = arTherm[1][bPointIndex + 1];
    0BEF: 62 D0 00 MOV   REG[0xD0],0x0
    0BF2: 52 00    MOV   A,[X+0]
    0BF4: 53 1A    MOV   [__r1],A
    0BF6: 55 1B 00 MOV   [__r0],0x0
    0BF9: 06 1A 01 ADD   [__r1],0x1
    0BFC: 0E 1B 00 ADC   [__r0],0x0
    0BFF: 65 1A    ASL   [__r1]
    0C01: 6B 1B    RLC   [__r0]
    0C03: 06 1A 7E ADD   [__r1],0x7E
    0C06: 0E 1B 01 ADC   [__r0],0x1
    0C09: 51 1B    MOV   A,[__r0]
    0C0B: 10       PUSH  X
    0C0C: 58 1A    MOV   X,[__r1]
    0C0E: 7C 10 E0 LCALL __lpmw
    0C11: 53 1A    MOV   [__r1],A
    0C13: 51 0F    MOV   A,[__rX]
    0C15: 53 1B    MOV   [__r0],A
    0C17: 20       POP   X
    0C18: 51 1A    MOV   A,[__r1]
    0C1A: 54 0C    MOV   [X+12],A
    0C1C: 51 1B    MOV   A,[__r0]
    0C1E: 54 0B    MOV   [X+11],A
    0C20: 48 0B 80 TST   [X+11],0x80
    0C23: A0 09    JZ    0x0C2D
    0C25: 56 0A FF MOV   [X+10],0xFF
    0C28: 56 09 FF MOV   [X+9],0xFF
    0C2B: 80 07    JMP   0x0C33
    0C2D: 56 0A 00 MOV   [X+10],0x0
    0C30: 56 09 00 MOV   [X+9],0x0
(0061) 
(0062) 		// Interpolate to find the temperature in hundredths of a deg C
(0063) 		thermistorValue.lVtherm = (((long) ivalue2 - thermistorValue.lVtherm) * (itemp1 - itemp2)) / (ivalue2 - ivalue1) + itemp2;
    0C33: 62 D0 00 MOV   REG[0xD0],0x0
    0C36: 52 04    MOV   A,[X+4]
    0C38: 13 08    SUB   A,[X+8]
    0C3A: 53 18    MOV   [__r3],A
    0C3C: 52 03    MOV   A,[X+3]
    0C3E: 1B 07    SBB   A,[X+7]
    0C40: 53 19    MOV   [__r2],A
    0C42: 52 02    MOV   A,[X+2]
    0C44: 1B 06    SBB   A,[X+6]
    0C46: 53 1A    MOV   [__r1],A
    0C48: 52 01    MOV   A,[X+1]
    0C4A: 1B 05    SBB   A,[X+5]
    0C4C: 54 11    MOV   [X+17],A
    0C4E: 51 1A    MOV   A,[__r1]
    0C50: 54 12    MOV   [X+18],A
    0C52: 51 19    MOV   A,[__r2]
    0C54: 54 13    MOV   [X+19],A
    0C56: 51 18    MOV   A,[__r3]
    0C58: 54 14    MOV   [X+20],A
    0C5A: 52 10    MOV   A,[X+16]
    0C5C: 13 0C    SUB   A,[X+12]
    0C5E: 53 14    MOV   [__r7],A
    0C60: 52 0F    MOV   A,[X+15]
    0C62: 1B 0B    SBB   A,[X+11]
    0C64: 53 15    MOV   [__r6],A
    0C66: 52 0E    MOV   A,[X+14]
    0C68: 1B 0A    SBB   A,[X+10]
    0C6A: 53 16    MOV   [__r5],A
    0C6C: 52 0D    MOV   A,[X+13]
    0C6E: 1B 09    SBB   A,[X+9]
    0C70: 53 17    MOV   [__r4],A
    0C72: 52 FC    MOV   A,[X-4]
    0C74: 53 12    MOV   [__r9],A
    0C76: 52 FB    MOV   A,[X-5]
    0C78: 60 D4    MOV   REG[0xD4],A
    0C7A: 3E 12    MVI   A,[__r9]
    0C7C: 53 1B    MOV   [__r0],A
    0C7E: 3E 12    MVI   A,[__r9]
    0C80: 53 1A    MOV   [__r1],A
    0C82: 3E 12    MVI   A,[__r9]
    0C84: 53 19    MOV   [__r2],A
    0C86: 3E 12    MVI   A,[__r9]
    0C88: 53 18    MOV   [__r3],A
    0C8A: 52 04    MOV   A,[X+4]
    0C8C: 12 18    SUB   A,[__r3]
    0C8E: 53 18    MOV   [__r3],A
    0C90: 52 03    MOV   A,[X+3]
    0C92: 1A 19    SBB   A,[__r2]
    0C94: 53 19    MOV   [__r2],A
    0C96: 52 02    MOV   A,[X+2]
    0C98: 1A 1A    SBB   A,[__r1]
    0C9A: 53 1A    MOV   [__r1],A
    0C9C: 52 01    MOV   A,[X+1]
    0C9E: 1A 1B    SBB   A,[__r0]
    0CA0: 53 1B    MOV   [__r0],A
    0CA2: 51 17    MOV   A,[__r4]
    0CA4: 08       PUSH  A
    0CA5: 51 16    MOV   A,[__r5]
    0CA7: 08       PUSH  A
    0CA8: 51 15    MOV   A,[__r6]
    0CAA: 08       PUSH  A
    0CAB: 51 14    MOV   A,[__r7]
    0CAD: 08       PUSH  A
    0CAE: 51 1B    MOV   A,[__r0]
    0CB0: 08       PUSH  A
    0CB1: 51 1A    MOV   A,[__r1]
    0CB3: 08       PUSH  A
    0CB4: 51 19    MOV   A,[__r2]
    0CB6: 08       PUSH  A
    0CB7: 51 18    MOV   A,[__r3]
    0CB9: 08       PUSH  A
    0CBA: 7C 10 95 LCALL 0x1095
    0CBD: 38 FC    ADD   SP,0xFC
    0CBF: 18       POP   A
    0CC0: 53 18    MOV   [__r3],A
    0CC2: 18       POP   A
    0CC3: 53 19    MOV   [__r2],A
    0CC5: 18       POP   A
    0CC6: 53 1A    MOV   [__r1],A
    0CC8: 18       POP   A
    0CC9: 53 1B    MOV   [__r0],A
    0CCB: 52 11    MOV   A,[X+17]
    0CCD: 08       PUSH  A
    0CCE: 52 12    MOV   A,[X+18]
    0CD0: 08       PUSH  A
    0CD1: 52 13    MOV   A,[X+19]
    0CD3: 08       PUSH  A
    0CD4: 52 14    MOV   A,[X+20]
    0CD6: 08       PUSH  A
    0CD7: 51 1B    MOV   A,[__r0]
    0CD9: 08       PUSH  A
    0CDA: 51 1A    MOV   A,[__r1]
    0CDC: 08       PUSH  A
    0CDD: 51 19    MOV   A,[__r2]
    0CDF: 08       PUSH  A
    0CE0: 51 18    MOV   A,[__r3]
    0CE2: 08       PUSH  A
    0CE3: 7C 0F DD LCALL 0x0FDD
    0CE6: 18       POP   A
    0CE7: 53 18    MOV   [__r3],A
    0CE9: 18       POP   A
    0CEA: 53 19    MOV   [__r2],A
    0CEC: 18       POP   A
    0CED: 53 1A    MOV   [__r1],A
    0CEF: 18       POP   A
    0CF0: 53 1B    MOV   [__r0],A
    0CF2: 38 FC    ADD   SP,0xFC
    0CF4: 52 0C    MOV   A,[X+12]
    0CF6: 04 18    ADD   [__r3],A
    0CF8: 52 0B    MOV   A,[X+11]
    0CFA: 0C 19    ADC   [__r2],A
    0CFC: 52 0A    MOV   A,[X+10]
    0CFE: 0C 1A    ADC   [__r1],A
    0D00: 52 09    MOV   A,[X+9]
    0D02: 0C 1B    ADC   [__r0],A
    0D04: 52 FC    MOV   A,[X-4]
    0D06: 53 16    MOV   [__r5],A
    0D08: 52 FB    MOV   A,[X-5]
    0D0A: 60 D5    MOV   REG[0xD5],A
    0D0C: 51 1B    MOV   A,[__r0]
    0D0E: 3F 16    MVI   [__r5],A
    0D10: 51 1A    MOV   A,[__r1]
    0D12: 3F 16    MVI   [__r5],A
    0D14: 51 19    MOV   A,[__r2]
    0D16: 3F 16    MVI   [__r5],A
    0D18: 51 18    MOV   A,[__r3]
    0D1A: 3F 16    MVI   [__r5],A
(0064) 
(0065)         // Divide the result by 10 in order to get the temperature in tenths of a deg C.                     
(0066)         // Round to the nearest tenth rather than truncating
(0067)      
(0068)         // First, get the temperature value as an integer
(0069)         ivalue1 = thermistorValue.lVtherm;
    0D1C: 52 FC    MOV   A,[X-4]
    0D1E: 53 1A    MOV   [__r1],A
    0D20: 52 FB    MOV   A,[X-5]
    0D22: 60 D4    MOV   REG[0xD4],A
    0D24: 3E 1A    MVI   A,[__r1]
    0D26: 54 05    MOV   [X+5],A
    0D28: 3E 1A    MVI   A,[__r1]
    0D2A: 54 06    MOV   [X+6],A
    0D2C: 3E 1A    MVI   A,[__r1]
    0D2E: 54 07    MOV   [X+7],A
    0D30: 3E 1A    MVI   A,[__r1]
    0D32: 54 08    MOV   [X+8],A
(0070)      
(0071)         // Next, get the sign and absolute value of the temperature
(0072)         if (ivalue1 < 0)
    0D34: 48 05 80 TST   [X+5],0x80
    0D37: A0 1E    JZ    0x0D56
(0073)         {               
(0074)             bPointIndex = 1; 
    0D39: 56 00 01 MOV   [X+0],0x1
(0075)             ivalue1 = 0 - ivalue1;
    0D3C: 50 00    MOV   A,0x0
    0D3E: 13 08    SUB   A,[X+8]
    0D40: 54 08    MOV   [X+8],A
    0D42: 50 00    MOV   A,0x0
    0D44: 1B 07    SBB   A,[X+7]
    0D46: 54 07    MOV   [X+7],A
    0D48: 50 00    MOV   A,0x0
    0D4A: 1B 06    SBB   A,[X+6]
    0D4C: 54 06    MOV   [X+6],A
    0D4E: 50 00    MOV   A,0x0
    0D50: 1B 05    SBB   A,[X+5]
    0D52: 54 05    MOV   [X+5],A
(0076)         }
    0D54: 80 04    JMP   0x0D59
(0077)         else
(0078)         {
(0079)             bPointIndex = 0;
    0D56: 56 00 00 MOV   [X+0],0x0
(0080)         }
(0081) 
(0082)        	// Calculate the truncated form
(0083)         ivalue2 = ivalue1 / 10;  
    0D59: 50 00    MOV   A,0x0
    0D5B: 08       PUSH  A
    0D5C: 08       PUSH  A
    0D5D: 08       PUSH  A
    0D5E: 50 0A    MOV   A,0xA
    0D60: 08       PUSH  A
    0D61: 52 05    MOV   A,[X+5]
    0D63: 08       PUSH  A
    0D64: 52 06    MOV   A,[X+6]
    0D66: 08       PUSH  A
    0D67: 52 07    MOV   A,[X+7]
    0D69: 08       PUSH  A
    0D6A: 52 08    MOV   A,[X+8]
    0D6C: 08       PUSH  A
    0D6D: 62 D0 00 MOV   REG[0xD0],0x0
    0D70: 7C 0F DD LCALL 0x0FDD
    0D73: 18       POP   A
    0D74: 54 04    MOV   [X+4],A
    0D76: 18       POP   A
    0D77: 54 03    MOV   [X+3],A
    0D79: 18       POP   A
    0D7A: 54 02    MOV   [X+2],A
    0D7C: 18       POP   A
    0D7D: 54 01    MOV   [X+1],A
    0D7F: 38 FC    ADD   SP,0xFC
(0084) 
(0085)         // Multiply the truncated form by 10 and add 5
(0086)         // If the result is less than or equal to the original undivided number, then the 
(0087)         // Truncated value must be incremented by 1.
(0088)         if ((ivalue2 * 10 + 5) <= ivalue1)
    0D81: 52 01    MOV   A,[X+1]
    0D83: 08       PUSH  A
    0D84: 52 02    MOV   A,[X+2]
    0D86: 08       PUSH  A
    0D87: 52 03    MOV   A,[X+3]
    0D89: 08       PUSH  A
    0D8A: 52 04    MOV   A,[X+4]
    0D8C: 08       PUSH  A
    0D8D: 50 00    MOV   A,0x0
    0D8F: 08       PUSH  A
    0D90: 08       PUSH  A
    0D91: 08       PUSH  A
    0D92: 50 0A    MOV   A,0xA
    0D94: 08       PUSH  A
    0D95: 7C 10 95 LCALL 0x1095
    0D98: 38 FC    ADD   SP,0xFC
    0D9A: 18       POP   A
    0D9B: 53 18    MOV   [__r3],A
    0D9D: 18       POP   A
    0D9E: 53 19    MOV   [__r2],A
    0DA0: 18       POP   A
    0DA1: 53 1A    MOV   [__r1],A
    0DA3: 18       POP   A
    0DA4: 53 1B    MOV   [__r0],A
    0DA6: 06 18 05 ADD   [__r3],0x5
    0DA9: 0E 19 00 ADC   [__r2],0x0
    0DAC: 0E 1A 00 ADC   [__r1],0x0
    0DAF: 0E 1B 00 ADC   [__r0],0x0
    0DB2: 52 08    MOV   A,[X+8]
    0DB4: 12 18    SUB   A,[__r3]
    0DB6: 52 07    MOV   A,[X+7]
    0DB8: 1A 19    SBB   A,[__r2]
    0DBA: 52 06    MOV   A,[X+6]
    0DBC: 1A 1A    SBB   A,[__r1]
    0DBE: 51 1B    MOV   A,[__r0]
    0DC0: 31 80    XOR   A,0x80
    0DC2: 53 0F    MOV   [__rX],A
    0DC4: 52 05    MOV   A,[X+5]
    0DC6: 31 80    XOR   A,0x80
    0DC8: 1A 0F    SBB   A,[__rX]
    0DCA: C0 0D    JC    0x0DD8
(0089)         {
(0090)             ivalue2++;
    0DCC: 07 04 01 ADD   [X+4],0x1
    0DCF: 0F 03 00 ADC   [X+3],0x0
    0DD2: 0F 02 00 ADC   [X+2],0x0
    0DD5: 0F 01 00 ADC   [X+1],0x0
(0091)         }
(0092)              
(0093)         // Change the sign to negative if necessary               
(0094)         if (bPointIndex)
    0DD8: 3D 00 00 CMP   [X+0],0x0
    0DDB: A0 19    JZ    0x0DF5
(0095)         {
(0096)             ivalue2 = 0 - ivalue2;
    0DDD: 50 00    MOV   A,0x0
    0DDF: 13 04    SUB   A,[X+4]
    0DE1: 54 04    MOV   [X+4],A
    0DE3: 50 00    MOV   A,0x0
    0DE5: 1B 03    SBB   A,[X+3]
    0DE7: 54 03    MOV   [X+3],A
    0DE9: 50 00    MOV   A,0x0
    0DEB: 1B 02    SBB   A,[X+2]
    0DED: 54 02    MOV   [X+2],A
    0DEF: 50 00    MOV   A,0x0
    0DF1: 1B 01    SBB   A,[X+1]
    0DF3: 54 01    MOV   [X+1],A
(0097)         }
(0098)   
(0099)         // Store the temperature value
(0100)         thermistorValue.lVtherm = ivalue2;
    0DF5: 62 D0 00 MOV   REG[0xD0],0x0
    0DF8: 52 FC    MOV   A,[X-4]
    0DFA: 53 1A    MOV   [__r1],A
    0DFC: 52 FB    MOV   A,[X-5]
    0DFE: 60 D5    MOV   REG[0xD5],A
    0E00: 52 01    MOV   A,[X+1]
    0E02: 3F 1A    MVI   [__r1],A
    0E04: 52 02    MOV   A,[X+2]
    0E06: 3F 1A    MVI   [__r1],A
    0E08: 52 03    MOV   A,[X+3]
    0E0A: 3F 1A    MVI   [__r1],A
    0E0C: 52 04    MOV   A,[X+4]
    0E0E: 3F 1A    MVI   [__r1],A
(0101) 	}
(0102) 		return thermistorValue.lVtherm;
    0E10: 62 D0 00 MOV   REG[0xD0],0x0
    0E13: 52 FC    MOV   A,[X-4]
    0E15: 53 1A    MOV   [__r1],A
    0E17: 52 FB    MOV   A,[X-5]
    0E19: 60 D4    MOV   REG[0xD4],A
    0E1B: 3E 1A    MVI   A,[__r1]
    0E1D: 3E 1A    MVI   A,[__r1]
    0E1F: 3E 1A    MVI   A,[__r1]
    0E21: 53 15    MOV   [__r6],A
    0E23: 3E 1A    MVI   A,[__r1]
    0E25: 53 1A    MOV   [__r1],A
    0E27: 51 15    MOV   A,[__r6]
    0E29: 53 1B    MOV   [__r0],A
    0E2B: 38 EB    ADD   SP,0xEB
    0E2D: 20       POP   X
    0E2E: 7F       RET   
(0103) }
(0104) 
(0105) ThermistorValue GetValueFromThermistor(void)
(0106) {
_GetValueFromThermistor:
  thermistorValue      --> X+2
  i                    --> X+0
    0E2F: 10       PUSH  X
    0E30: 4F       MOV   X,SP
    0E31: 38 0A    ADD   SP,0xA
(0107) 	int i;
(0108) 	ThermistorValue thermistorValue;
(0109) 	thermistorValue.ivalue1=0;
    0E33: 56 06 00 MOV   [X+6],0x0
    0E36: 56 07 00 MOV   [X+7],0x0
    0E39: 56 08 00 MOV   [X+8],0x0
    0E3C: 56 09 00 MOV   [X+9],0x0
(0110) 	thermistorValue.lVtherm=0;
    0E3F: 56 02 00 MOV   [X+2],0x0
    0E42: 56 03 00 MOV   [X+3],0x0
    0E45: 56 04 00 MOV   [X+4],0x0
    0E48: 56 05 00 MOV   [X+5],0x0
(0111) 	ADC10_Start(ADC10_FULLRANGE);     // Start the User Module  
    0E4B: 10       PUSH  X
    0E4C: 50 03    MOV   A,0x3
    0E4E: 7C 04 D4 LCALL _ADC10_Start
(0112) 	ADC10_iCal(0x1FF, ADC10_CAL_VBG);  // Calibrate the ADC so 1.3V = 0x01FF  
    0E51: 50 03    MOV   A,0x3
    0E53: 08       PUSH  A
    0E54: 50 01    MOV   A,0x1
    0E56: 08       PUSH  A
    0E57: 50 FF    MOV   A,0xFF
    0E59: 08       PUSH  A
    0E5A: 7C 05 51 LCALL _ADC10_iCal
    0E5D: 38 FD    ADD   SP,0xFD
    0E5F: 62 D0 00 MOV   REG[0xD0],0x0
(0113) 	ADC10_StartADC();	
    0E62: 7C 05 02 LCALL _ADC10_StartADC
    0E65: 20       POP   X
(0114) 	ReadVTEMPInput;        // Enable the Analog Column Input Mux to
    0E66: 71 10    OR    F,0x10
    0E68: 62 62 00 MOV   REG[0x62],0x0
    0E6B: 70 CF    AND   F,0xCF
(0115) 	
(0116) 	while(ADC10_fIsDataAvailable() == 0){};  /*checking for the availability of data */
    0E6D: 10       PUSH  X
    0E6E: 7C 05 30 LCALL _ADC10_fIsDataAvailable
    0E71: 20       POP   X
    0E72: 62 D0 00 MOV   REG[0xD0],0x0
    0E75: 39 00    CMP   A,0x0
    0E77: AF F5    JZ    0x0E6D
(0117) 	thermistorValue.lVtherm = ADC10_iGetDataClearFlag();   /* Get the data and clear the flag */
    0E79: 10       PUSH  X
    0E7A: 7C 05 36 LCALL _ADC10_iGetDataClearFlag
    0E7D: 62 D0 00 MOV   REG[0xD0],0x0
    0E80: 5A 1B    MOV   [__r0],X
    0E82: 20       POP   X
    0E83: 54 05    MOV   [X+5],A
    0E85: 51 1B    MOV   A,[__r0]
    0E87: 54 04    MOV   [X+4],A
    0E89: 48 04 80 TST   [X+4],0x80
    0E8C: A0 09    JZ    0x0E96
    0E8E: 56 03 FF MOV   [X+3],0xFF
    0E91: 56 02 FF MOV   [X+2],0xFF
    0E94: 80 07    JMP   0x0E9C
    0E96: 56 03 00 MOV   [X+3],0x0
    0E99: 56 02 00 MOV   [X+2],0x0
(0118) 		
(0119)     ReadVTEMP_EXCInput;    // Enable the Analog Column Input Mux to
    0E9C: 71 10    OR    F,0x10
    0E9E: 62 62 80 MOV   REG[0x62],0x80
(0120)                            // read Port0.7/VTemp_exc input
(0121) 
(0122) 	for(i=0; i<20000; i++){;}	// Give a delay before changing Analog input source
    0EA1: 56 01 00 MOV   [X+1],0x0
    0EA4: 56 00 00 MOV   [X+0],0x0
    0EA7: 70 CF    AND   F,0xCF
    0EA9: 77 01    INC   [X+1]
    0EAB: 0F 00 00 ADC   [X+0],0x0
    0EAE: 52 01    MOV   A,[X+1]
    0EB0: 11 20    SUB   A,0x20
    0EB2: 52 00    MOV   A,[X+0]
    0EB4: 31 80    XOR   A,0x80
    0EB6: 19 CE    SBB   A,0xCE
    0EB8: CF F0    JC    0x0EA9
(0123) 	while(ADC10_fIsDataAvailable() == 0){};  /*checking for the availability of data */
    0EBA: 10       PUSH  X
    0EBB: 7C 05 30 LCALL _ADC10_fIsDataAvailable
    0EBE: 20       POP   X
    0EBF: 62 D0 00 MOV   REG[0xD0],0x0
    0EC2: 39 00    CMP   A,0x0
    0EC4: AF F5    JZ    0x0EBA
(0124) 	thermistorValue.ivalue1 = ADC10_iGetDataClearFlag();   /* Get the data and clear the flag */
    0EC6: 10       PUSH  X
    0EC7: 7C 05 36 LCALL _ADC10_iGetDataClearFlag
    0ECA: 62 D0 00 MOV   REG[0xD0],0x0
    0ECD: 5A 1B    MOV   [__r0],X
    0ECF: 20       POP   X
    0ED0: 54 09    MOV   [X+9],A
    0ED2: 51 1B    MOV   A,[__r0]
    0ED4: 54 08    MOV   [X+8],A
    0ED6: 48 08 80 TST   [X+8],0x80
    0ED9: A0 09    JZ    0x0EE3
    0EDB: 56 07 FF MOV   [X+7],0xFF
    0EDE: 56 06 FF MOV   [X+6],0xFF
    0EE1: 80 07    JMP   0x0EE9
    0EE3: 56 07 00 MOV   [X+7],0x0
    0EE6: 56 06 00 MOV   [X+6],0x0
(0125) 		
(0126) 	ADC10_Stop();
    0EE9: 10       PUSH  X
    0EEA: 7C 04 EF LCALL _ADC10_Stop
(0127) 	ADC10_StopADC();
    0EED: 7C 05 23 LCALL _ADC10_StopADC
    0EF0: 20       POP   X
(0128) 	return thermistorValue;
    0EF1: 62 D0 00 MOV   REG[0xD0],0x0
    0EF4: 5A 1A    MOV   [__r1],X
    0EF6: 06 1A 02 ADD   [__r1],0x2
    0EF9: 52 FC    MOV   A,[X-4]
    0EFB: 53 18    MOV   [__r3],A
    0EFD: 52 FB    MOV   A,[X-5]
    0EFF: 62 D4 01 MOV   REG[0xD4],0x1
    0F02: 60 D5    MOV   REG[0xD5],A
    0F04: 10       PUSH  X
    0F05: 57 08    MOV   X,0x8
    0F07: 62 D0 00 MOV   REG[0xD0],0x0
    0F0A: 3E 1A    MVI   A,[__r1]
    0F0C: 3F 18    MVI   [__r3],A
    0F0E: 79       DEC   X
    0F0F: BF F7    JNZ   0x0F07
    0F11: 20       POP   X
    0F12: 38 F6    ADD   SP,0xF6
    0F14: 20       POP   X
    0F15: 7F       RET   
(0129) }
(0130) 	
(0131) int GetTemperature(void)
(0132) {
_GetTemperature:
  thermistorValue      --> X+0
    0F16: 10       PUSH  X
    0F17: 4F       MOV   X,SP
    0F18: 38 10    ADD   SP,0x10
(0133) 	ThermistorValue thermistorValue;
(0134) 	thermistorValue = GetValueFromThermistor();
    0F1A: 62 D0 00 MOV   REG[0xD0],0x0
    0F1D: 50 01    MOV   A,0x1
    0F1F: 08       PUSH  A
    0F20: 10       PUSH  X
    0F21: 9F 0C    CALL  _GetValueFromThermistor
    0F23: 38 FE    ADD   SP,0xFE
(0135) 	return CalculateTemperature(thermistorValue);	
    0F25: 62 D0 00 MOV   REG[0xD0],0x0
    0F28: 5A 1A    MOV   [__r1],X
    0F2A: 06 1A 08 ADD   [__r1],0x8
    0F2D: 5A 18    MOV   [__r3],X
    0F2F: 62 D4 01 MOV   REG[0xD4],0x1
    0F32: 62 D5 01 MOV   REG[0xD5],0x1
    0F35: 10       PUSH  X
    0F36: 57 08    MOV   X,0x8
    0F38: 62 D0 00 MOV   REG[0xD0],0x0
    0F3B: 3E 18    MVI   A,[__r3]
    0F3D: 3F 1A    MVI   [__r1],A
    0F3F: 79       DEC   X
    0F40: BF F7    JNZ   0x0F38
    0F42: 20       POP   X
    0F43: 5A 1A    MOV   [__r1],X
    0F45: 06 1A 08 ADD   [__r1],0x8
    0F48: 50 01    MOV   A,0x1
    0F4A: 08       PUSH  A
    0F4B: 51 1A    MOV   A,[__r1]
    0F4D: 08       PUSH  A
    0F4E: 99 DD    CALL  _CalculateTemperature
    0F50: 38 FE    ADD   SP,0xFE
    0F52: 38 F0    ADD   SP,0xF0
    0F54: 20       POP   X
    0F55: 7F       RET   
(0136) 		
(0137) }
(0138) 
(0139) int TempControl_GetValue(void)
(0140) {
_TempControl_GetValue:
  lVtherm              --> X+0
    0F56: 10       PUSH  X
    0F57: 4F       MOV   X,SP
    0F58: 38 02    ADD   SP,0x2
(0141) 	
(0142) 	int lVtherm;
(0143) 	lVtherm = GetTemperature();	
    0F5A: 9F BA    CALL  _GetTemperature
    0F5C: 62 D0 00 MOV   REG[0xD0],0x0
    0F5F: 51 1A    MOV   A,[__r1]
    0F61: 54 01    MOV   [X+1],A
    0F63: 51 1B    MOV   A,[__r0]
    0F65: 54 00    MOV   [X+0],A
(0144) 	if ((lVtherm >= -100) && (lVtherm < 240)) // TRUE if temp is between -10 and 24
    0F67: 52 01    MOV   A,[X+1]
    0F69: 11 9C    SUB   A,0x9C
    0F6B: 52 00    MOV   A,[X+0]
    0F6D: 31 80    XOR   A,0x80
    0F6F: 19 7F    SBB   A,0x7F
    0F71: C0 18    JC    0x0F8A
    0F73: 52 01    MOV   A,[X+1]
    0F75: 11 F0    SUB   A,0xF0
    0F77: 52 00    MOV   A,[X+0]
    0F79: 31 80    XOR   A,0x80
    0F7B: 19 80    SBB   A,0x80
    0F7D: D0 0C    JNC   0x0F8A
(0145) 	{
(0146) 		return 1;
    0F7F: 62 D0 00 MOV   REG[0xD0],0x0
    0F82: 55 1A 01 MOV   [__r1],0x1
    0F85: 55 1B 00 MOV   [__r0],0x0
    0F88: 80 50    JMP   0x0FD9
(0147) 	}
(0148) 	else if ((lVtherm >= 240) && (lVtherm < 280)) // TRUE if temp is between 24 and 28
    0F8A: 52 01    MOV   A,[X+1]
    0F8C: 11 F0    SUB   A,0xF0
    0F8E: 52 00    MOV   A,[X+0]
    0F90: 31 80    XOR   A,0x80
    0F92: 19 80    SBB   A,0x80
    0F94: C0 18    JC    0x0FAD
    0F96: 52 01    MOV   A,[X+1]
    0F98: 11 18    SUB   A,0x18
    0F9A: 52 00    MOV   A,[X+0]
    0F9C: 31 80    XOR   A,0x80
    0F9E: 19 81    SBB   A,0x81
    0FA0: D0 0C    JNC   0x0FAD
(0149) 	{
(0150) 		return 2;		
    0FA2: 62 D0 00 MOV   REG[0xD0],0x0
    0FA5: 55 1A 02 MOV   [__r1],0x2
    0FA8: 55 1B 00 MOV   [__r0],0x0
    0FAB: 80 2D    JMP   0x0FD9
(0151) 	}
(0152) 	else if ((lVtherm >= 280) && (lVtherm < 550)) // TRUE if temp is between 23 and 55
    0FAD: 52 01    MOV   A,[X+1]
    0FAF: 11 18    SUB   A,0x18
    0FB1: 52 00    MOV   A,[X+0]
    0FB3: 31 80    XOR   A,0x80
    0FB5: 19 81    SBB   A,0x81
    0FB7: C0 18    JC    0x0FD0
    0FB9: 52 01    MOV   A,[X+1]
    0FBB: 11 26    SUB   A,0x26
    0FBD: 52 00    MOV   A,[X+0]
    0FBF: 31 80    XOR   A,0x80
    0FC1: 19 82    SBB   A,0x82
    0FC3: D0 0C    JNC   0x0FD0
(0153) 	{
(0154) 		return 3;	
    0FC5: 62 D0 00 MOV   REG[0xD0],0x0
    0FC8: 55 1A 03 MOV   [__r1],0x3
    0FCB: 55 1B 00 MOV   [__r0],0x0
    0FCE: 80 0A    JMP   0x0FD9
(0155) 	}
(0156) 	else
(0157) 	{
(0158) 		return 0;
    0FD0: 62 D0 00 MOV   REG[0xD0],0x0
(0159) 	}			
(0160) }
(0161) 
    0FD3: 55 1A 00 MOV   [__r1],0x0
    0FD6: 55 1B 00 MOV   [__r0],0x0
    0FD9: 38 FE    ADD   SP,0xFE
    0FDB: 20       POP   X
    0FDC: 7F       RET   
__lpmw:
    10E0: 08       PUSH  A
    10E1: 28       ROMX  
    10E2: 53 0F    MOV   [__rX],A
    10E4: 18       POP   A
    10E5: 75       INC   X
    10E6: 09 00    ADC   A,0x0
    10E8: 28       ROMX  
    10E9: 7F       RET   
